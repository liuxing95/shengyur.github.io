{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/1_2.jpg","path":"img/1_2.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/flex.png","path":"img/flex.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/flexDemo.jpg","path":"img/flexDemo.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/license.png","path":"img/license.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/describe.jpg","path":"img/describe.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/lufi.jpeg","path":"img/lufi.jpeg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/sass.jpg","path":"img/sass.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/1+2.jpg","path":"img/1+2.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BLOG.jpg","path":"img/BLOG.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/fl.jpeg","path":"img/fl.jpeg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/hexo4000.png","path":"img/hexo4000.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/zhang.jpg","path":"img/zhang.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/README.md","hash":"1048dc5e0f5f0c490a0ffca40ce9e75a06a83fb2","modified":1524155161000},{"_id":"source/.DS_Store","hash":"0d546b458fedc7d8f567e3429a54ad7f3d0bdc6a","modified":1529148874000},{"_id":"themes/maupassant/.DS_Store","hash":"b4b33445001dd555fdbe5f2655e26ff6758f0456","modified":1528988500000},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1523973498000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1523973498000},{"_id":"themes/maupassant/_config.yml","hash":"ef9fae5458cacb23e6720c1eeb9aa9f58b8d9d6d","modified":1528367001000},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1523973498000},{"_id":"source/favicon.ico","hash":"09740f8468e4238f27d9e9d5b7b8b6bd48a0dfc1","modified":1523974374000},{"_id":"source/_posts/CSS效率工具之 Sass的常见用法.md","hash":"4e43c19bfe352d4e314dcae946717e16bc027205","modified":1527344810000},{"_id":"source/_posts/.DS_Store","hash":"4e24aa71ec9324fc1371da689902f9df90973da4","modified":1529148833000},{"_id":"source/_posts/ES6_super.md","hash":"4df858ce22700c1bfbd7ee81c01a280185044121","modified":1529150489000},{"_id":"source/_posts/JavaScript-test-framework.md","hash":"79da32ae47108b6affd64664da67a4da3dc0d186","modified":1528559416000},{"_id":"source/_posts/Ramda 函数库的使用.md","hash":"de40c944628aa55bb1d08ae5d514017de2bd9e96","modified":1528733812000},{"_id":"source/_posts/Nodejs之npm&package.json学习.md","hash":"fd32d48e92448ef51ecc8ce1368697174534e9a1","modified":1526660821000},{"_id":"source/_posts/React基础之 抄文档.md","hash":"2fba8a6e869bbb743bbb98412335a85b97d461a2","modified":1528733947000},{"_id":"source/_posts/React基础之 父组件如何调用子组件中的方法.md","hash":"e4a4b16d7fd85f2d48c974347b1f93eee5959350","modified":1527940808000},{"_id":"source/_posts/React-Element中的StyleSheet.reset方法为何可以重置样式？.md","hash":"c11efdea247a252e097f05fe17bc6f3c3a509a30","modified":1528895123000},{"_id":"source/_posts/React进阶之 React性能优化.md","hash":"ea1d68dbd1ec3095b83faa43c4a3790f916dc375","modified":1526998233000},{"_id":"source/_posts/flex布局从入门到运用.md","hash":"f17baf5fa4d047e8229139e1163144b2e34101a6","modified":1526126295000},{"_id":"source/_posts/React进阶之 使用mobx进行状态管理.md","hash":"31f4477ad10280448ba58ceb8af08e0c3944ef49","modified":1529028744000},{"_id":"source/_posts/axios常用攻略.md","hash":"7a143251ba4ad0d7a85358d3454c2f7a46b4b33e","modified":1528988657000},{"_id":"source/_posts/git常用基本命令.md","hash":"ec5d683bff568f369d307e7ad4fdf83ce73a8934","modified":1527344055000},{"_id":"source/_posts/git踩坑小记录.md","hash":"27c7520f139eda67cc009bea9658007a58c1cb0f","modified":1527344647000},{"_id":"source/_posts/hexo博客的部署优化与管理.md","hash":"85b67dc218e20d4abfb87453953fe51da09c79a0","modified":1529162943000},{"_id":"source/_posts/less配合vscode使用的配置.md","hash":"e91c68410e665de6a000470476239aaed621318c","modified":1527345229000},{"_id":"source/_posts/jquery源码解读01-总体架构.md","hash":"bed1ac16647c16859267b0b2c24f9ae0579a1f06","modified":1525269696000},{"_id":"source/_posts/hexo+github+Maupassant搭建博客.md","hash":"7959ddd6086d3f6cfb728c3672ca7fa32076e613","modified":1529151260000},{"_id":"source/_posts/mock工具使用.md","hash":"184218593e2c760a7f390a7c52cd3b67c08d6d08","modified":1529028483000},{"_id":"source/_posts/node版本切换工具nvm的常用命令.md","hash":"3eaeb2f4d2325bc233a39d6200bd0053240919dd","modified":1525524691000},{"_id":"source/_posts/vscode之多设备配置同步.md","hash":"e0fbdf198be814c8dfe2e61f8d1714f6a9a604b4","modified":1527783705000},{"_id":"source/_posts/从面试的角度夯实前端基础.md","hash":"16554112d7bf318b207d15f64ffc4cd631bf0e9b","modified":1528125033000},{"_id":"source/_posts/函数式编程入门.md","hash":"eab25124f8f402dd2ecc33d0b601023f83ddc520","modified":1528596963000},{"_id":"source/_posts/复制知乎简书的文本内容，为什么会自带版权声明？.md","hash":"3546fc0e21f5850c0a7fc8c45ce29f82956382d9","modified":1525269725000},{"_id":"source/_posts/数组与对象的深浅拷贝.md","hash":"3e804dd32e443fb60946fab6ae7d842c33a13771","modified":1528892548000},{"_id":"source/about/index.md","hash":"dedc492db47f25a6b55e54757bc63ef16b91541b","modified":1524845996000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1523973498000},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1523973498000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1523973482000},{"_id":"themes/maupassant/.git/index","hash":"613015e60197437ca977e78e02c41514e2bcb586","modified":1529160717000},{"_id":"themes/maupassant/.git/packed-refs","hash":"173e6e733ade4ee56d29907aff7d181d2f539e5c","modified":1523973498000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1523973498000},{"_id":"themes/maupassant/languages/en.yml","hash":"9dc51349f64e882433957c00dc757366229e0269","modified":1523973498000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1523973498000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1523973498000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1523973498000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ffce5df2448a80dbad71da115c84b81f42a42778","modified":1523973498000},{"_id":"themes/maupassant/layout/.DS_Store","hash":"0818527eb211dfb26a430bdf9628d91422703a29","modified":1527878061000},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1523973498000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1523973498000},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1523973498000},{"_id":"themes/maupassant/layout/archive.pug","hash":"665582bb4092fcd81bfaf4d08fc1689abee1e6c4","modified":1523973498000},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1523973498000},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1523973498000},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1523973498000},{"_id":"themes/maupassant/layout/post.pug","hash":"d0325a145fadc81083e71264c651306b11e4962d","modified":1523973498000},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1523973498000},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1523973498000},{"_id":"themes/maupassant/source/.DS_Store","hash":"d4381eeac841c26c231d30a01828328a1a3fd391","modified":1528990658000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1523973482000},{"_id":"themes/maupassant/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1523973482000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"2d3beab52f55464ea791892dd585c5aeabc19983","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"510535f1730834a37e057b17f22c7c63d1517daf","modified":1525186462000},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1524760338000},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"a02e78c558682a40a7ae583c0159868bca51b4e4","modified":1528040160000},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"84c7eac1d29be42a0ddfea8c91c6a5b7cea26492","modified":1527878609000},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"9925dc2f58d600d3890111d694c76315f6b8b95b","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"1202fc6685c368de8a8f080827fbbc285d86c274","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1523973498000},{"_id":"themes/maupassant/source/css/donate.css","hash":"d0079ba8202d925a93ab1cb44f2087b81f476755","modified":1523973498000},{"_id":"themes/maupassant/source/donate/index.html","hash":"88cc1b52c1d8ce455d7e819c356a50554e6d90bc","modified":1523973498000},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1523973498000},{"_id":"themes/maupassant/source/css/style.scss","hash":"547bed40ce40b44bf527b02924df5be26472ac73","modified":1527878616000},{"_id":"themes/maupassant/source/img/.DS_Store","hash":"6631c96666bbce3dae5f5c9c326b1329d4376da7","modified":1528988546000},{"_id":"themes/maupassant/source/img/1_2.jpg","hash":"f2976eda60c23d58b0b08465802da5efb281cd93","modified":1524725719000},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1523973498000},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1523973498000},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1523973498000},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1523973498000},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1523973498000},{"_id":"themes/maupassant/source/img/flex.png","hash":"1ecaac9b18d66edf3ab7aeaadde91dd7b47ac4f5","modified":1525662776000},{"_id":"themes/maupassant/source/img/flexDemo.jpg","hash":"2713986a8aaa4abd88c51c6869b4e3602f29d6e5","modified":1525701162000},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1523973498000},{"_id":"themes/maupassant/source/img/license.png","hash":"140f114850c37c18ae9b0421a720ce2ce14d7ed0","modified":1526655645000},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1523973498000},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1523973498000},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1523973498000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1523973498000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1523973498000},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1523973498000},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1523973498000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1523973498000},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1523973498000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1523973498000},{"_id":"themes/maupassant/source/img/describe.jpg","hash":"aa74dd130cab8104b0077cfca43a6c529a225bde","modified":1524755508000},{"_id":"themes/maupassant/source/img/lufi.jpeg","hash":"dbcf416d6e6e249d9d4de7efb2810dfa687881c5","modified":1528681245000},{"_id":"themes/maupassant/source/img/sass.jpg","hash":"60483c1264119b7d7cc97cb501fe9a7c1e604f61","modified":1527259350000},{"_id":"themes/maupassant/.git/objects/pack/pack-af07c7f9ceb9dfeaa56ca1686fc858ae0d162e11.idx","hash":"174eff35f63b9c65c3b53ff826614b0a9c62f821","modified":1523973498000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"fa1c4b944193934a792617657c7a2e0eaa08dd22","modified":1523973498000},{"_id":"themes/maupassant/source/img/1+2.jpg","hash":"b5cc36ed3b7b37ea9ff79463a751807534898f64","modified":1524725674000},{"_id":"themes/maupassant/source/img/BLOG.jpg","hash":"5e1f542310c2201f8d229a13f5b6193486bbe9f3","modified":1524151040000},{"_id":"themes/maupassant/source/img/fl.jpeg","hash":"c06bd9b79a45b3adbcdd1f0342690e59210511cd","modified":1528595744000},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1523973498000},{"_id":"themes/maupassant/source/img/hexo4000.png","hash":"5456237c018d7774fdce1efa72167b841fc3b489","modified":1524063566000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"2d3beab52f55464ea791892dd585c5aeabc19983","modified":1523973498000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1523973498000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"2d3beab52f55464ea791892dd585c5aeabc19983","modified":1523973498000},{"_id":"themes/maupassant/source/img/zhang.jpg","hash":"0db5610922f8cc3dc2ac4a46217642cae23e664e","modified":1524151302000},{"_id":"themes/maupassant/.git/objects/pack/pack-af07c7f9ceb9dfeaa56ca1686fc858ae0d162e11.pack","hash":"4a2c9a6b9d9dc188b2a5cf44439657d4c30d625e","modified":1523973498000},{"_id":"public/search.xml","hash":"a328353357c4f2d38f8dd5fa583237efb96dd125","modified":1529163275270},{"_id":"public/about/index.html","hash":"432db2e2680dc9e7a250b1fc12a9f871ceed9068","modified":1529163275277},{"_id":"public/2018/06/16/hexo博客的部署优化与管理/index.html","hash":"46d633721e3cc5e24a224cfc219e027b07fc3a1a","modified":1529163275277},{"_id":"public/2018/06/14/axios常用攻略/index.html","hash":"5917ee5f2c638f2e4d6de90be089fbc9c9e3d187","modified":1529163275277},{"_id":"public/2018/06/13/React-Element中的StyleSheet.reset方法为何可以重置样式？/index.html","hash":"230ace65c6e603ae69ec7b9be24573167d594a25","modified":1529163275277},{"_id":"public/2018/06/11/React基础之 抄文档/index.html","hash":"e031ea47d6caed990288a739b4e44ba920ad3d72","modified":1529163275277},{"_id":"public/2018/06/10/Ramda 函数库的使用/index.html","hash":"2f941c8f157ec10821ae989aa375578925749312","modified":1529163275277},{"_id":"public/2018/06/09/函数式编程入门/index.html","hash":"4de60b3b73c6c9dda29fd69e5bc0983726bbef1b","modified":1529163275277},{"_id":"public/2018/06/02/React基础之 父组件如何调用子组件中的方法/index.html","hash":"a90b644ba5c475d22136a15574704100fe2aacaf","modified":1529163275278},{"_id":"public/2018/06/01/vscode之多设备配置同步/index.html","hash":"e3db86991042760a75d8c0aa83ea99c0227d708a","modified":1529163275278},{"_id":"public/2018/05/26/git踩坑小记录/index.html","hash":"ec31c309c47be99c433786f2c02517dd50e3a80c","modified":1529163275278},{"_id":"public/2018/05/21/React进阶之 React性能优化/index.html","hash":"6c4a81d411566c27936fea30e11d45939bfd6c7c","modified":1529163275278},{"_id":"public/2018/05/05/node版本切换工具nvm的常用命令/index.html","hash":"337027573355feab2465196a24d4155120055534","modified":1529163275278},{"_id":"public/2018/05/05/less配合vscode使用的配置/index.html","hash":"e549fa7c947474df449971edbd0c33aeba8bb866","modified":1529163275278},{"_id":"public/2018/05/02/从面试的角度夯实前端基础/index.html","hash":"d4fa3b25fad0467359d859d5c1b1f4a18ee09b40","modified":1529163275278},{"_id":"public/2018/05/01/复制知乎简书的文本内容，为什么会自带版权声明？/index.html","hash":"3461a3a60f6521fee404450b24222103ef6ce163","modified":1529163275278},{"_id":"public/archives/index.html","hash":"5e3c0c0359ed5323728b29b4b1a2fdd16ba5e756","modified":1529163275279},{"_id":"public/archives/page/2/index.html","hash":"274e21756545ddbd99a420b6b7084372d66b16a7","modified":1529163275279},{"_id":"public/archives/page/3/index.html","hash":"fbc195c42483896e86f3cda9e13d762e43f1d30d","modified":1529163275279},{"_id":"public/archives/2018/index.html","hash":"aec96ba15b0fd03386b191637c8025affeb14b31","modified":1529163275279},{"_id":"public/archives/2018/page/2/index.html","hash":"844c99c60ae3e54b87edb03bd626aa186e243a12","modified":1529163275279},{"_id":"public/archives/2018/page/3/index.html","hash":"b186f6d2775e0965f1d67aa379270664cc16083a","modified":1529163275279},{"_id":"public/archives/2018/04/index.html","hash":"993c91444455def02656ca85351debe71379b5e4","modified":1529163275279},{"_id":"public/archives/2018/05/index.html","hash":"a13254134754ed5f2dff461c09e874a7460e549a","modified":1529163275279},{"_id":"public/archives/2018/06/index.html","hash":"6c630104c97a0b3f7dd9079f365f69f8c2c464db","modified":1529163275279},{"_id":"public/archives/2018/06/page/2/index.html","hash":"f69e7d517aa15936c73897d9e86a90b32c43d8ff","modified":1529163275279},{"_id":"public/categories/Tools/index.html","hash":"c2e46c10ed57ebff753ceae7c048d08ee81639f7","modified":1529163275279},{"_id":"public/categories/Foundation/index.html","hash":"818a2b3e71eb2b3d9f5f42d66164be5a0e44f0e9","modified":1529163275279},{"_id":"public/categories/JsTest/index.html","hash":"3301245a34ff74c36282ff12510cd287d1ceefd0","modified":1529163275279},{"_id":"public/categories/Frame/index.html","hash":"fad5fcd59f53cd1f83a8323b52c3723290033617","modified":1529163275279},{"_id":"public/categories/Nodejs/index.html","hash":"30790011d08704b4530682229420614ce6c3f43f","modified":1529163275279},{"_id":"public/categories/Questions/index.html","hash":"100d0e3587bbd81a9ca26c1561070970fb30a005","modified":1529163275280},{"_id":"public/categories/Analysis/index.html","hash":"e460577a99e1ae772bf1a5c1f3eb43027d26f660","modified":1529163275280},{"_id":"public/categories/技术思想/index.html","hash":"d4a3253da375f4342083ee41f60fb76ffce023f3","modified":1529163275280},{"_id":"public/categories/Frame/函数式编程/index.html","hash":"a8b347ca1036327ec196d77135206c3d4f3253c6","modified":1529163275280},{"_id":"public/tags/Sass/index.html","hash":"3a1667d1bd6a36943dbad18bd9037da9ad23b74e","modified":1529163275280},{"_id":"public/tags/ES6/index.html","hash":"7bebee4a1b8239902360c43e7a21585b5296e928","modified":1529163275280},{"_id":"public/tags/Jest/index.html","hash":"7203f121240622e0c364b8453d50709bcbab083f","modified":1529163275280},{"_id":"public/tags/Ramda/index.html","hash":"3c1c9acb3e5425e803fa629c9fdadec7778b07ce","modified":1529163275280},{"_id":"public/tags/Nodejs/index.html","hash":"30790011d08704b4530682229420614ce6c3f43f","modified":1529163275280},{"_id":"public/tags/React/index.html","hash":"c2252e6466363c7ad67fb0c9d14f79246e7e3673","modified":1529163275280},{"_id":"public/tags/Javascript/index.html","hash":"702538ce1361f7b0aa2a18ad3e644a10c9950494","modified":1529163275281},{"_id":"public/tags/axios/index.html","hash":"607490eeb71f6fc85a00632f34707e70f44092c9","modified":1529163275281},{"_id":"public/tags/git/index.html","hash":"ae4b4ed5b4b17402e13a5d6c2ed5630dc5bf216b","modified":1529163275281},{"_id":"public/tags/Hexo/index.html","hash":"b3b3d64f0830116ac7ef8cba234f9c20d0230ed1","modified":1529163275281},{"_id":"public/tags/Less/index.html","hash":"d7a868a68cf9d252c96df0601cd4f83c75fe689b","modified":1529163275281},{"_id":"public/tags/vscode/index.html","hash":"a74d253d570b67282b5a9a04a788365a687eb2e3","modified":1529163275281},{"_id":"public/tags/jQuery源码/index.html","hash":"e2f52b0892ca645ec7081c0f2573d5537bf356c2","modified":1529163275281},{"_id":"public/tags/mock/index.html","hash":"83e30dcee6f57267f95cbaadd55b2a5e4a74d48a","modified":1529163275281},{"_id":"public/tags/HTTP/index.html","hash":"5572d1b99a925a190fbf153e8f5e9dd0b4a6b520","modified":1529163275281},{"_id":"public/tags/安全/index.html","hash":"f32342843f505482b0a16bbcd823a6a2fc58ea18","modified":1529163275281},{"_id":"public/tags/Node/index.html","hash":"4d6923a15706eb49fdf49aa137ae0e1d9a66752d","modified":1529163275281},{"_id":"public/tags/函数式编程/index.html","hash":"cb39ea534d8d9879e4aa3154d9637186501c571a","modified":1529163275281},{"_id":"public/page/3/index.html","hash":"e107f3ebc179d536429cb38fe04c4ae96fced754","modified":1529163275281},{"_id":"public/2018/06/14/mock工具使用/index.html","hash":"b94e4c13401ddc96c5b95ecf3c21354e284d1b51","modified":1529163275281},{"_id":"public/2018/06/13/数组与对象的深浅拷贝/index.html","hash":"8ff78889aff1043051bdce52dd5ec28598d18d34","modified":1529163275281},{"_id":"public/2018/06/11/React进阶之 使用mobx进行状态管理/index.html","hash":"96dcc586460e383e7a004fbdf4fdd9f53700e1de","modified":1529163275281},{"_id":"public/2018/06/04/JavaScript-test-framework/index.html","hash":"7a622f749785ffcccd60d8b5c53756aaa3aa2316","modified":1529163275281},{"_id":"public/2018/05/25/CSS效率工具之 Sass的常见用法/index.html","hash":"71cd5642b0553b7df037696e773c67e0f6b51d6d","modified":1529163275282},{"_id":"public/2018/05/22/ES6_super/index.html","hash":"1fc6c06fe024f1253d3bb58afa65908958aae556","modified":1529163275282},{"_id":"public/2018/05/18/Nodejs之npm&package.json学习/index.html","hash":"d406171ff4e80b501d5133260c6b0e8a9219eab5","modified":1529163275282},{"_id":"public/2018/05/06/flex布局从入门到运用/index.html","hash":"c39585ce966d821b5e3f3f20c96e3b1979ad43c1","modified":1529163275282},{"_id":"public/2018/04/27/jquery源码解读01-总体架构/index.html","hash":"6c5ca9a08cb7fa4e7459776c525f1271f4e31fc4","modified":1529163275282},{"_id":"public/2018/04/18/hexo+github+Maupassant搭建博客/index.html","hash":"eb5910841dee50ede9cfc1f5d1060ffe3812d721","modified":1529163275282},{"_id":"public/2018/04/17/git常用基本命令/index.html","hash":"321e32bd77c433273ce3832472966dad72c9d3bc","modified":1529163275282},{"_id":"public/index.html","hash":"b055efee36543395dd49b2a9dc4f4f5c1089fe2b","modified":1529163275282},{"_id":"public/page/2/index.html","hash":"f13d6c1b65826df3fea8555f395ae5931cf6b9ec","modified":1529163275282},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1529163275291},{"_id":"public/img/1_2.jpg","hash":"f2976eda60c23d58b0b08465802da5efb281cd93","modified":1529163275291},{"_id":"public/README.md","hash":"1048dc5e0f5f0c490a0ffca40ce9e75a06a83fb2","modified":1529163275292},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1529163275292},{"_id":"public/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1529163275292},{"_id":"public/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1529163275292},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1529163275292},{"_id":"public/img/flex.png","hash":"1ecaac9b18d66edf3ab7aeaadde91dd7b47ac4f5","modified":1529163275292},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1529163275292},{"_id":"public/img/flexDemo.jpg","hash":"2713986a8aaa4abd88c51c6869b4e3602f29d6e5","modified":1529163275292},{"_id":"public/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1529163275292},{"_id":"public/img/license.png","hash":"140f114850c37c18ae9b0421a720ce2ce14d7ed0","modified":1529163275292},{"_id":"public/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1529163275292},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1529163275292},{"_id":"public/favicon.ico","hash":"09740f8468e4238f27d9e9d5b7b8b6bd48a0dfc1","modified":1529163275337},{"_id":"public/img/sass.jpg","hash":"60483c1264119b7d7cc97cb501fe9a7c1e604f61","modified":1529163275337},{"_id":"public/img/describe.jpg","hash":"aa74dd130cab8104b0077cfca43a6c529a225bde","modified":1529163275337},{"_id":"public/img/lufi.jpeg","hash":"dbcf416d6e6e249d9d4de7efb2810dfa687881c5","modified":1529163275338},{"_id":"public/donate/index.html","hash":"88cc1b52c1d8ce455d7e819c356a50554e6d90bc","modified":1529163275344},{"_id":"public/css/donate.css","hash":"d0079ba8202d925a93ab1cb44f2087b81f476755","modified":1529163275344},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1529163275344},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1529163275344},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1529163275344},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1529163275344},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1529163275345},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1529163275345},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1529163275345},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1529163275345},{"_id":"public/css/style.css","hash":"bec4cd8e3a4c354f5841226683a2acfac0c000f3","modified":1529163275345},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1529163275345},{"_id":"public/img/1+2.jpg","hash":"b5cc36ed3b7b37ea9ff79463a751807534898f64","modified":1529163275345},{"_id":"public/img/BLOG.jpg","hash":"5e1f542310c2201f8d229a13f5b6193486bbe9f3","modified":1529163275345},{"_id":"public/img/fl.jpeg","hash":"c06bd9b79a45b3adbcdd1f0342690e59210511cd","modified":1529163275346},{"_id":"public/img/hexo4000.png","hash":"5456237c018d7774fdce1efa72167b841fc3b489","modified":1529163275349},{"_id":"public/img/zhang.jpg","hash":"0db5610922f8cc3dc2ac4a46217642cae23e664e","modified":1529163275359}],"Category":[{"name":"效率工具","_id":"cjihkbv4u000qka0t42zxb62o"},{"name":"前端基础","_id":"cjihkbv5e000ska0tgdaw0g3u"},{"name":"前端自动化测试","_id":"cjihkbv5f000uka0t24vv401j"},{"name":"库/框架","_id":"cjihkbv5g000wka0t64j8yvhv"},{"name":"Nodejs","_id":"cjihkbv5g000yka0tcgkbb3xo"},{"name":"十万个为什么","_id":"cjihkbv5m0014ka0tokg7mko7"},{"name":"源码浅析","_id":"cjihkbv61001mka0t41r85cwe"},{"name":"技术思想","_id":"cjihkbv69001yka0tc4rnmbkw"},{"name":"函数式编程","parent":"cjihkbv5g000wka0t64j8yvhv","_id":"cjihkbv6i0027ka0t3iso0eak"}],"Data":[],"Page":[{"title":"关于","date":"2018-04-27T16:00:58.000Z","_content":"<span></span>\n<p><i class=\"fa fa-user\"></i> Nickname: <a href=\"https://shengyur.github.io/\">shengyu</a></p>\n<p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:sheldo.cn@gmail.com\" target=\"_blank\" rel=\"noopener\">sheldo.cn@gmail.com</a></p>\n<p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/shengyur\" target=\"_blank\" rel=\"noopener\">shengyur</a></p>\n<p><i class=\"fa fa-location-arrow\"></i> Location: 江苏 南京</a></p>\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-04-28 00:00:58\n---\n<span></span>\n<p><i class=\"fa fa-user\"></i> Nickname: <a href=\"https://shengyur.github.io/\">shengyu</a></p>\n<p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:sheldo.cn@gmail.com\" target=\"_blank\" rel=\"noopener\">sheldo.cn@gmail.com</a></p>\n<p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/shengyur\" target=\"_blank\" rel=\"noopener\">shengyur</a></p>\n<p><i class=\"fa fa-location-arrow\"></i> Location: 江苏 南京</a></p>\n","updated":"2018-04-27T16:19:56.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjihkbv220000ka0t3lfhvkk9","content":"<p><span></span></p>\n<p><i class=\"fa fa-user\"></i> Nickname: <a href=\"https://shengyur.github.io/\" target=\"_blank\" rel=\"noopener\">shengyu</a></p><br><p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:sheldo.cn@gmail.com\" target=\"_blank\" rel=\"noopener\">sheldo.cn@gmail.com</a></p><br><p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/shengyur\" target=\"_blank\" rel=\"noopener\">shengyur</a></p><br><p><i class=\"fa fa-location-arrow\"></i> Location: 江苏 南京</p>\n","site":{"data":{}},"excerpt":"","more":"<p><span></span></p>\n<p><i class=\"fa fa-user\"></i> Nickname: <a href=\"https://shengyur.github.io/\" target=\"_blank\" rel=\"noopener\">shengyu</a></p><br><p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:sheldo.cn@gmail.com\" target=\"_blank\" rel=\"noopener\">sheldo.cn@gmail.com</a></p><br><p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/shengyur\" target=\"_blank\" rel=\"noopener\">shengyur</a></p><br><p><i class=\"fa fa-location-arrow\"></i> Location: 江苏 南京</p>\n"}],"Post":[{"title":"CSS效率工具之 Sass的常见用法","date":"2018-05-24T16:00:00.000Z","_content":"<figure>\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/sass.jpg\">\n</figure>\n### 一 使用变量\n1. 可以使用变量：\n声明变量的方式：使用$符号，$highlight-color  $sidebar-width\n\n2. 变量存在作用域\n作用域使用方式：类似ES6的块级作用域，使用{}区分作用域\n  <!--more-->\n\n```\n$nav-color: #F90;\nnav {\n  $width: 100px;\n  width: $width;\n  color: $nav-color;\n}\n\n//编译后\n\nnav {\n  width: 100px;\n  color: #F90;\n}\n```\n\n3. 变量如何命名更好\nsass的变量名可以包括中划线和下划线，如$highlight-color（更普遍）、$highlight_color ，在sass中，这两种写法的内容是互通的，比如，对sass来说$link-color和$link_color其实指向的是同一个变量，但是在sass中纯css部分不互通，比如类名、ID或属性名。\n\n```\n$link-color: blue;\na {\n  color: $link_color;\n}\n\n//编译后\n\na {\n  color: blue;\n}\n```\n\n### 二 嵌套CSS\n1. 可以避免书写重复的长串选择器\n\n```\n#content article h1 { color: #333 }\n#content article p { margin-bottom: 1.4em }\n#content aside { background-color: #EEE }\n /* 编译后 */\n#content article h1 { color: #333 }\n#content article p { margin-bottom: 1.4em }\n#content aside { background-color: #EEE }\n```\n\n例外情况：\n比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构 &。\n\n2. 父选择器的标识符&\n\n```\narticle a {\n  color: blue;\n  &:hover { color: red }\n}\n```\n\n当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&被父选择器直接替换：\n\n```\narticle a { color: blue }\narticle a:hover { color: red }\n```\n\n3.  群组选择器的嵌套(减少重复敲写)\n.container h1, .container h2, .container h3 { margin-bottom: .8em }\n可以写成：\n\n```\n.container {\n  h1, h2, h3 {margin-bottom: .8em}\n}\n```\n\n4. 子组合选择器和同层组合选择器：>、+和~ 都支持使用\n\n&gt;:子组合选择器,用于选择一个元素的直接子元素\n+:同层相邻组合选择器+选择header元素后紧跟的p元素\n~:同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素\n\n```\narticle ~ article { border-top: 1px dashed #ccc }\n```\n\n5. 属性也可以嵌套\n\n```\nnav {\n  border: {\n  style: solid;\n  width: 1px;\n  color: #ccc;\n  }\n}\n```\n\n嵌套属性的规则：\n把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。\n\n```\nnav {\n  border-style: solid;\n  border-width: 1px;\n  border-color: #ccc;\n}\n```\n\n### 三、导入SASS文件\ncss原生的特性@import规则，允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。\n\nsass的@import规则，在生成css文件时，就会把相关样式导入进来。而且导入时，可以省略后缀的书写\n如@import\"sidebar\";这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。\n\n常用的就以上几点了，记录一下方便以后翻阅。\n\n参考：https://www.sass.hk/guide/\n","source":"_posts/CSS效率工具之 Sass的常见用法.md","raw":"title: CSS效率工具之 Sass的常见用法\ndate: 2018/05/25\ncategories: 效率工具\ntags:\n  - Sass\n---\n<figure>\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/sass.jpg\">\n</figure>\n### 一 使用变量\n1. 可以使用变量：\n声明变量的方式：使用$符号，$highlight-color  $sidebar-width\n\n2. 变量存在作用域\n作用域使用方式：类似ES6的块级作用域，使用{}区分作用域\n  <!--more-->\n\n```\n$nav-color: #F90;\nnav {\n  $width: 100px;\n  width: $width;\n  color: $nav-color;\n}\n\n//编译后\n\nnav {\n  width: 100px;\n  color: #F90;\n}\n```\n\n3. 变量如何命名更好\nsass的变量名可以包括中划线和下划线，如$highlight-color（更普遍）、$highlight_color ，在sass中，这两种写法的内容是互通的，比如，对sass来说$link-color和$link_color其实指向的是同一个变量，但是在sass中纯css部分不互通，比如类名、ID或属性名。\n\n```\n$link-color: blue;\na {\n  color: $link_color;\n}\n\n//编译后\n\na {\n  color: blue;\n}\n```\n\n### 二 嵌套CSS\n1. 可以避免书写重复的长串选择器\n\n```\n#content article h1 { color: #333 }\n#content article p { margin-bottom: 1.4em }\n#content aside { background-color: #EEE }\n /* 编译后 */\n#content article h1 { color: #333 }\n#content article p { margin-bottom: 1.4em }\n#content aside { background-color: #EEE }\n```\n\n例外情况：\n比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构 &。\n\n2. 父选择器的标识符&\n\n```\narticle a {\n  color: blue;\n  &:hover { color: red }\n}\n```\n\n当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&被父选择器直接替换：\n\n```\narticle a { color: blue }\narticle a:hover { color: red }\n```\n\n3.  群组选择器的嵌套(减少重复敲写)\n.container h1, .container h2, .container h3 { margin-bottom: .8em }\n可以写成：\n\n```\n.container {\n  h1, h2, h3 {margin-bottom: .8em}\n}\n```\n\n4. 子组合选择器和同层组合选择器：>、+和~ 都支持使用\n\n&gt;:子组合选择器,用于选择一个元素的直接子元素\n+:同层相邻组合选择器+选择header元素后紧跟的p元素\n~:同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素\n\n```\narticle ~ article { border-top: 1px dashed #ccc }\n```\n\n5. 属性也可以嵌套\n\n```\nnav {\n  border: {\n  style: solid;\n  width: 1px;\n  color: #ccc;\n  }\n}\n```\n\n嵌套属性的规则：\n把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。\n\n```\nnav {\n  border-style: solid;\n  border-width: 1px;\n  border-color: #ccc;\n}\n```\n\n### 三、导入SASS文件\ncss原生的特性@import规则，允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。\n\nsass的@import规则，在生成css文件时，就会把相关样式导入进来。而且导入时，可以省略后缀的书写\n如@import\"sidebar\";这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。\n\n常用的就以上几点了，记录一下方便以后翻阅。\n\n参考：https://www.sass.hk/guide/\n","slug":"CSS效率工具之 Sass的常见用法","published":1,"updated":"2018-05-26T14:26:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv2d0001ka0tfk3b2h0d","content":"<p><figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/sass.jpg\"><br></figure></p>\n<h3 id=\"一-使用变量\"><a href=\"#一-使用变量\" class=\"headerlink\" title=\"一 使用变量\"></a>一 使用变量</h3><ol>\n<li><p>可以使用变量：<br>声明变量的方式：使用$符号，$highlight-color  $sidebar-width</p>\n</li>\n<li><p>变量存在作用域<br>作用域使用方式：类似ES6的块级作用域，使用{}区分作用域</p>\n<a id=\"more\"></a>\n</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$nav-color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"variable\">$width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$nav-color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>变量如何命名更好<br>sass的变量名可以包括中划线和下划线，如$highlight-color（更普遍）、$highlight_color ，在sass中，这两种写法的内容是互通的，比如，对sass来说$link-color和$link_color其实指向的是同一个变量，但是在sass中纯css部分不互通，比如类名、ID或属性名。</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$link</span>-<span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$link_color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-嵌套CSS\"><a href=\"#二-嵌套CSS\" class=\"headerlink\" title=\"二 嵌套CSS\"></a>二 嵌套CSS</h3><ol>\n<li>可以避免书写重复的长串选择器</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">h1</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">1.4em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#EEE</span> &#125;</span><br><span class=\"line\"> <span class=\"comment\">/* 编译后 */</span></span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">h1</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">1.4em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#EEE</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>例外情况：<br>比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构 &amp;。</p>\n<ol start=\"2\">\n<li>父选择器的标识符&amp;</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">  &amp;:hover &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">color</span>: blue &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span>:hover &#123; <span class=\"attribute\">color</span>: red &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>群组选择器的嵌套(减少重复敲写)<br>.container h1, .container h2, .container h3 { margin-bottom: .8em }<br>可以写成：</li>\n</ol>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"class\">container </span>&#123;</span><br><span class=\"line\">  h1, h2, <span class=\"class\">h3 </span>&#123;margin-bottom: <span class=\"number\">.8</span>em&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>子组合选择器和同层组合选择器：&gt;、+和~ 都支持使用</li>\n</ol>\n<p>&gt;:子组合选择器,用于选择一个元素的直接子元素<br>+:同层相邻组合选择器+选择header元素后紧跟的p元素<br>~:同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> ~ <span class=\"selector-tag\">article</span> &#123; <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> dashed <span class=\"number\">#ccc</span> &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>属性也可以嵌套</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: &#123;</span><br><span class=\"line\">  style: solid;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嵌套属性的规则：<br>把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、导入SASS文件\"><a href=\"#三、导入SASS文件\" class=\"headerlink\" title=\"三、导入SASS文件\"></a>三、导入SASS文件</h3><p>css原生的特性@import规则，允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。</p>\n<p>sass的@import规则，在生成css文件时，就会把相关样式导入进来。而且导入时，可以省略后缀的书写<br>如@import”sidebar”;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。</p>\n<p>常用的就以上几点了，记录一下方便以后翻阅。</p>\n<p>参考：<a href=\"https://www.sass.hk/guide/\" target=\"_blank\" rel=\"noopener\">https://www.sass.hk/guide/</a></p>\n","site":{"data":{}},"excerpt":"<p><figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/sass.jpg\"><br></figure></p>\n<h3 id=\"一-使用变量\"><a href=\"#一-使用变量\" class=\"headerlink\" title=\"一 使用变量\"></a>一 使用变量</h3><ol>\n<li><p>可以使用变量：<br>声明变量的方式：使用$符号，$highlight-color  $sidebar-width</p>\n</li>\n<li><p>变量存在作用域<br>作用域使用方式：类似ES6的块级作用域，使用{}区分作用域</p>","more":"</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$nav-color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"variable\">$width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$nav-color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>变量如何命名更好<br>sass的变量名可以包括中划线和下划线，如$highlight-color（更普遍）、$highlight_color ，在sass中，这两种写法的内容是互通的，比如，对sass来说$link-color和$link_color其实指向的是同一个变量，但是在sass中纯css部分不互通，比如类名、ID或属性名。</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$link</span>-<span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$link_color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-嵌套CSS\"><a href=\"#二-嵌套CSS\" class=\"headerlink\" title=\"二 嵌套CSS\"></a>二 嵌套CSS</h3><ol>\n<li>可以避免书写重复的长串选择器</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">h1</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">1.4em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#EEE</span> &#125;</span><br><span class=\"line\"> <span class=\"comment\">/* 编译后 */</span></span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">h1</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">1.4em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#EEE</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>例外情况：<br>比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构 &amp;。</p>\n<ol start=\"2\">\n<li>父选择器的标识符&amp;</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">  &amp;:hover &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">color</span>: blue &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span>:hover &#123; <span class=\"attribute\">color</span>: red &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>群组选择器的嵌套(减少重复敲写)<br>.container h1, .container h2, .container h3 { margin-bottom: .8em }<br>可以写成：</li>\n</ol>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"class\">container </span>&#123;</span><br><span class=\"line\">  h1, h2, <span class=\"class\">h3 </span>&#123;margin-bottom: <span class=\"number\">.8</span>em&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>子组合选择器和同层组合选择器：&gt;、+和~ 都支持使用</li>\n</ol>\n<p>&gt;:子组合选择器,用于选择一个元素的直接子元素<br>+:同层相邻组合选择器+选择header元素后紧跟的p元素<br>~:同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> ~ <span class=\"selector-tag\">article</span> &#123; <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> dashed <span class=\"number\">#ccc</span> &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>属性也可以嵌套</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: &#123;</span><br><span class=\"line\">  style: solid;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嵌套属性的规则：<br>把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、导入SASS文件\"><a href=\"#三、导入SASS文件\" class=\"headerlink\" title=\"三、导入SASS文件\"></a>三、导入SASS文件</h3><p>css原生的特性@import规则，允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。</p>\n<p>sass的@import规则，在生成css文件时，就会把相关样式导入进来。而且导入时，可以省略后缀的书写<br>如@import”sidebar”;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。</p>\n<p>常用的就以上几点了，记录一下方便以后翻阅。</p>\n<p>参考：<a href=\"https://www.sass.hk/guide/\" target=\"_blank\" rel=\"noopener\">https://www.sass.hk/guide/</a></p>"},{"title":"ES6 Class的继承之super关键字","date":"2018-05-21T16:00:00.000Z","_content":"\nsuper关键字有两种用法，既可以当成函数使用，也可以当成对象使用。在这两种情况下，它的用法完全不同。\n\n在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。\n\n1. 当super作为函数调用时\nsuper作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n\n```\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();//调用父类的构造函数，否则会报错\n  }\n}\n```\n\n注意：\nsuper虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。\n<!--more-->\n\n\n```\nclass A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n```\n\n上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。\n**作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错**\n\n提示：\nnew.target属性，一般用在构造函数之中，返回new命令作用于的那个构造函数。\n\n2. super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\n```\nclass Human {\n  constructor() {}\n  static ping() {\n    return 'ping';\n  }\n}\nclass Computer extends Human {\n  constructor() {}\n  static pingpong() {\n    return super.ping() + ' pong';//在 静态方法 中，super指向父类\n  }\n}\nComputer.pingpong(); // 'ping pong'\n```\n\n提示：\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法 **不会被实例继承，而是直接通过类来调用**，这就称为“静态方法”。\n\n```\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2 在普通方法中，super指向父类的原型对象\n  }\n}\n\nlet b = new B();\n```\n\n上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\n这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。\n\n```\nclass A {\n  constructor() {\n    this.p = 2;\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\n上面代码中，p是父类A实例的属性，super.p就引用不到它。\n\n如果属性定义在父类的原型对象上，super就可以取到。\n\nES6 规定,**在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例**。\n\n```\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super(); //this指向当前的子类实例--b\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n```\n\n由于this指向子类实例，所以 **如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性**。\n\n```\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;  //b.x=2\n    super.x = 3;  //this.x=3\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n```\n\n\n\n参考：\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\nhttp://es6.ruanyifeng.com/?search=prop&x=0&y=0#docs/class-extends\n","source":"_posts/ES6_super.md","raw":"title: ES6 Class的继承之super关键字\ndate: 2018/05/22\ncategories: 前端基础\ntags:\n  - ES6\n---\n\nsuper关键字有两种用法，既可以当成函数使用，也可以当成对象使用。在这两种情况下，它的用法完全不同。\n\n在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。\n\n1. 当super作为函数调用时\nsuper作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n\n```\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();//调用父类的构造函数，否则会报错\n  }\n}\n```\n\n注意：\nsuper虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。\n<!--more-->\n\n\n```\nclass A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n```\n\n上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。\n**作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错**\n\n提示：\nnew.target属性，一般用在构造函数之中，返回new命令作用于的那个构造函数。\n\n2. super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\n```\nclass Human {\n  constructor() {}\n  static ping() {\n    return 'ping';\n  }\n}\nclass Computer extends Human {\n  constructor() {}\n  static pingpong() {\n    return super.ping() + ' pong';//在 静态方法 中，super指向父类\n  }\n}\nComputer.pingpong(); // 'ping pong'\n```\n\n提示：\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法 **不会被实例继承，而是直接通过类来调用**，这就称为“静态方法”。\n\n```\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2 在普通方法中，super指向父类的原型对象\n  }\n}\n\nlet b = new B();\n```\n\n上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\n这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。\n\n```\nclass A {\n  constructor() {\n    this.p = 2;\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\n上面代码中，p是父类A实例的属性，super.p就引用不到它。\n\n如果属性定义在父类的原型对象上，super就可以取到。\n\nES6 规定,**在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例**。\n\n```\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super(); //this指向当前的子类实例--b\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n```\n\n由于this指向子类实例，所以 **如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性**。\n\n```\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;  //b.x=2\n    super.x = 3;  //this.x=3\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n```\n\n\n\n参考：\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\nhttp://es6.ruanyifeng.com/?search=prop&x=0&y=0#docs/class-extends\n","slug":"ES6_super","published":1,"updated":"2018-06-16T12:01:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv2r0002ka0t7m8vsbjw","content":"<p>super关键字有两种用法，既可以当成函数使用，也可以当成对象使用。在这两种情况下，它的用法完全不同。</p>\n<p>在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。</p>\n<ol>\n<li>当super作为函数调用时<br>super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();<span class=\"comment\">//调用父类的构造函数，否则会报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：<br>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。<br><a id=\"more\"></a></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    console.log(<span class=\"keyword\">new</span>.target.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。<br><strong>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错</strong></p>\n<p>提示：<br>new.target属性，一般用在构造函数之中，返回new命令作用于的那个构造函数。</p>\n<ol start=\"2\">\n<li>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">  static ping() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"symbol\">'pin</span>g';</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Computer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">  static pingpong() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.ping() + ' pong';<span class=\"comment\">//在 静态方法 中，super指向父类</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">Computer</span>.pingpong(); <span class=\"comment\">// 'ping pong'</span></span><br></pre></td></tr></table></figure>\n<p>提示：<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法 <strong>不会被实例继承，而是直接通过类来调用</strong>，这就称为“静态方法”。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  p() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    console.log(<span class=\"keyword\">super</span>.p()); <span class=\"comment\">// 2 在普通方法中，super指向父类的原型对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br></pre></td></tr></table></figure>\n<p>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。<br>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.p = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  get m() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br><span class=\"line\">b.m <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p>\n<p>如果属性定义在父类的原型对象上，super就可以取到。</p>\n<p>ES6 规定,<strong>在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</strong>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  print() &#123;</span><br><span class=\"line\">    console.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(); <span class=\"comment\">//this指向当前的子类实例--b</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  m() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.print();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br><span class=\"line\">b.m() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>由于this指向子类实例，所以 <strong>如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性</strong>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;  <span class=\"comment\">//b.x=2</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.x = <span class=\"number\">3</span>;  <span class=\"comment\">//this.x=3</span></span><br><span class=\"line\">    console.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    console.log(<span class=\"keyword\">this</span>.x); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super</a><br><a href=\"http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends</a></p>\n","site":{"data":{}},"excerpt":"<p>super关键字有两种用法，既可以当成函数使用，也可以当成对象使用。在这两种情况下，它的用法完全不同。</p>\n<p>在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。</p>\n<ol>\n<li>当super作为函数调用时<br>super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();<span class=\"comment\">//调用父类的构造函数，否则会报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：<br>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。<br>","more":"</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    console.log(<span class=\"keyword\">new</span>.target.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。<br><strong>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错</strong></p>\n<p>提示：<br>new.target属性，一般用在构造函数之中，返回new命令作用于的那个构造函数。</p>\n<ol start=\"2\">\n<li>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">  static ping() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"symbol\">'pin</span>g';</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Computer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">  static pingpong() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.ping() + ' pong';<span class=\"comment\">//在 静态方法 中，super指向父类</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">Computer</span>.pingpong(); <span class=\"comment\">// 'ping pong'</span></span><br></pre></td></tr></table></figure>\n<p>提示：<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法 <strong>不会被实例继承，而是直接通过类来调用</strong>，这就称为“静态方法”。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  p() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    console.log(<span class=\"keyword\">super</span>.p()); <span class=\"comment\">// 2 在普通方法中，super指向父类的原型对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br></pre></td></tr></table></figure>\n<p>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。<br>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.p = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  get m() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br><span class=\"line\">b.m <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p>\n<p>如果属性定义在父类的原型对象上，super就可以取到。</p>\n<p>ES6 规定,<strong>在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</strong>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  print() &#123;</span><br><span class=\"line\">    console.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(); <span class=\"comment\">//this指向当前的子类实例--b</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  m() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.print();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br><span class=\"line\">b.m() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>由于this指向子类实例，所以 <strong>如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性</strong>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;  <span class=\"comment\">//b.x=2</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.x = <span class=\"number\">3</span>;  <span class=\"comment\">//this.x=3</span></span><br><span class=\"line\">    console.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    console.log(<span class=\"keyword\">this</span>.x); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super</a><br><a href=\"http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends</a></p>"},{"title":"前端自动化测试探索","date":"2018-06-03T16:00:00.000Z","toc":true,"_content":"\n\n### 常用的前端测试工具一览\n前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为 **测试框架**、**断言库**、**测试覆盖率工具** 等几类。在正式开始本文之前，我们先来大致了解下它们：\n### 测试框架\n测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。\n测试一般分两种：BDD和TDD\n<!--more-->\n1. 先介绍Test-Driven Development(TDD)即测试驱动开发，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。国外使用这种开发模式较多，github上大型的开源项目，如果没跑过测试用例，大概是没人敢在生产环境中使用的。\n测试驱动对开发过程的要求：\n- 单元尽量解耦，否则单元不可测\n- 开发前，先设计接口，再实现细节\n- 便于回归和内部代码重构 (把所有单元测试，集成测试等都做好之后，实现重构就更加从容，可以一块一块进行)\n2. BDD指的是Behavior Drive Development，也就是行为驱动开发。传统的开发模式中，客户很难从技术层面理解问题，开发人员很难从业务需求考虑问题，BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析需求，然后将这些需求写成一个个的故事(应用场景)。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，通过设定各种业务场景中该展示的状态、适用的事件，以及场景的执行结果，基本就完成了一个完整测试的定义。\n\n常见的测试框架有 [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/),以及本文要介绍的 [Jest](https://facebook.github.io/jest/zh-Hans/) 。\n\n### 断言库\n断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 [Should.js](https://shouldjs.github.io/), [Chai.js](http://www.chaijs.com/) 等。\n\n### 测试覆盖率工具\n用于统计测试用例对代码的测试情况，生成相应的报表，比如 [istanbul](https://github.com/gotwarlost/istanbul)。\n\n### Jest\n\n1. 为什么选择Jest\nJest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n而作为一个面向前端的测试框架， Jest 可以利用其特有的[快照测试](https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content)功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。\n\n此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。\n\n2. 安装\nJest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：\n```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\nJest 的测试脚本名形如*.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的*.test.js 或.spec.js 文件、完成测试。\n3. 基本使用\n4. 用例的表示\n表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：\nsum.js\n```\nfunction sum(a, b) {\n    return a + b;\n  }\n  module.exports = sum;\n```\nsum.test.js\n```\nconst sum = require('./sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  //expect(sum(1, 2)).toBe(3);//成功\n  expect(sum(1, 2)).toBe(5);//失败  \n});\n```\n其中toBe('Hello world')便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。\n写完了用例，运行在项目目录下执行npm test，即可看到测试结果：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg)\n修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg)\n\n\n5. 用例的预处理或后处理：\n有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。\n- 对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；\n- 如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；\n- 后处理，可以使用对应的 afterAll() 和 afterEach() 函数。\n- 如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：\n\ncheckAll.js\n```\nfunction obj(){\n  const o={\n    foo:true,\n    bar:false\n  };\n  return o\n}\nmodule.exports=obj();\n```\ncheckAll.test.js\n```\nvar testObject = require('./checkAll');\n\n\ndescribe('test testObject', () => {\n    beforeAll(() => {\n        // 预处理操作\n    })\n\n    test('is foo', () => {\n       expect(testObject.foo).toBeTruthy();\n    })\n\n    test('is not bar', () => {\n        expect(testObject.bar).toBeFalsy();\n    })\n\n    afterAll(() => {\n        // 后处理操作\n    })\n})\n```\n执行npm test\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg)\n\n\n\n### Mocha\nMocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.js内置的assert模块作为断言\n让我们一起看看assert有哪些常见用法：\n\n\n\n原文：\n- https://segmentfault.com/a/1190000004558796\n- https://zhuanlan.zhihu.com/p/28162082\n","source":"_posts/JavaScript-test-framework.md","raw":"title: 前端自动化测试探索\ndate: 2018/06/04\ncategories: 前端自动化测试\ntoc: true\ntags:\n  - Jest\n---\n\n\n### 常用的前端测试工具一览\n前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为 **测试框架**、**断言库**、**测试覆盖率工具** 等几类。在正式开始本文之前，我们先来大致了解下它们：\n### 测试框架\n测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。\n测试一般分两种：BDD和TDD\n<!--more-->\n1. 先介绍Test-Driven Development(TDD)即测试驱动开发，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。国外使用这种开发模式较多，github上大型的开源项目，如果没跑过测试用例，大概是没人敢在生产环境中使用的。\n测试驱动对开发过程的要求：\n- 单元尽量解耦，否则单元不可测\n- 开发前，先设计接口，再实现细节\n- 便于回归和内部代码重构 (把所有单元测试，集成测试等都做好之后，实现重构就更加从容，可以一块一块进行)\n2. BDD指的是Behavior Drive Development，也就是行为驱动开发。传统的开发模式中，客户很难从技术层面理解问题，开发人员很难从业务需求考虑问题，BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析需求，然后将这些需求写成一个个的故事(应用场景)。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，通过设定各种业务场景中该展示的状态、适用的事件，以及场景的执行结果，基本就完成了一个完整测试的定义。\n\n常见的测试框架有 [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/),以及本文要介绍的 [Jest](https://facebook.github.io/jest/zh-Hans/) 。\n\n### 断言库\n断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 [Should.js](https://shouldjs.github.io/), [Chai.js](http://www.chaijs.com/) 等。\n\n### 测试覆盖率工具\n用于统计测试用例对代码的测试情况，生成相应的报表，比如 [istanbul](https://github.com/gotwarlost/istanbul)。\n\n### Jest\n\n1. 为什么选择Jest\nJest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n而作为一个面向前端的测试框架， Jest 可以利用其特有的[快照测试](https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content)功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。\n\n此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。\n\n2. 安装\nJest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：\n```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\nJest 的测试脚本名形如*.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的*.test.js 或.spec.js 文件、完成测试。\n3. 基本使用\n4. 用例的表示\n表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：\nsum.js\n```\nfunction sum(a, b) {\n    return a + b;\n  }\n  module.exports = sum;\n```\nsum.test.js\n```\nconst sum = require('./sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  //expect(sum(1, 2)).toBe(3);//成功\n  expect(sum(1, 2)).toBe(5);//失败  \n});\n```\n其中toBe('Hello world')便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。\n写完了用例，运行在项目目录下执行npm test，即可看到测试结果：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg)\n修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg)\n\n\n5. 用例的预处理或后处理：\n有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。\n- 对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；\n- 如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；\n- 后处理，可以使用对应的 afterAll() 和 afterEach() 函数。\n- 如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：\n\ncheckAll.js\n```\nfunction obj(){\n  const o={\n    foo:true,\n    bar:false\n  };\n  return o\n}\nmodule.exports=obj();\n```\ncheckAll.test.js\n```\nvar testObject = require('./checkAll');\n\n\ndescribe('test testObject', () => {\n    beforeAll(() => {\n        // 预处理操作\n    })\n\n    test('is foo', () => {\n       expect(testObject.foo).toBeTruthy();\n    })\n\n    test('is not bar', () => {\n        expect(testObject.bar).toBeFalsy();\n    })\n\n    afterAll(() => {\n        // 后处理操作\n    })\n})\n```\n执行npm test\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg)\n\n\n\n### Mocha\nMocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.js内置的assert模块作为断言\n让我们一起看看assert有哪些常见用法：\n\n\n\n原文：\n- https://segmentfault.com/a/1190000004558796\n- https://zhuanlan.zhihu.com/p/28162082\n","slug":"JavaScript-test-framework","published":1,"updated":"2018-06-09T15:50:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv2u0003ka0tyb5km0eh","content":"<h3 id=\"常用的前端测试工具一览\"><a href=\"#常用的前端测试工具一览\" class=\"headerlink\" title=\"常用的前端测试工具一览\"></a>常用的前端测试工具一览</h3><p>前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为 <strong>测试框架</strong>、<strong>断言库</strong>、<strong>测试覆盖率工具</strong> 等几类。在正式开始本文之前，我们先来大致了解下它们：</p>\n<h3 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h3><p>测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。<br>测试一般分两种：BDD和TDD<br><a id=\"more\"></a></p>\n<ol>\n<li>先介绍Test-Driven Development(TDD)即测试驱动开发，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。国外使用这种开发模式较多，github上大型的开源项目，如果没跑过测试用例，大概是没人敢在生产环境中使用的。<br>测试驱动对开发过程的要求：</li>\n</ol>\n<ul>\n<li>单元尽量解耦，否则单元不可测</li>\n<li>开发前，先设计接口，再实现细节</li>\n<li>便于回归和内部代码重构 (把所有单元测试，集成测试等都做好之后，实现重构就更加从容，可以一块一块进行)</li>\n</ul>\n<ol start=\"2\">\n<li>BDD指的是Behavior Drive Development，也就是行为驱动开发。传统的开发模式中，客户很难从技术层面理解问题，开发人员很难从业务需求考虑问题，BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析需求，然后将这些需求写成一个个的故事(应用场景)。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，通过设定各种业务场景中该展示的状态、适用的事件，以及场景的执行结果，基本就完成了一个完整测试的定义。</li>\n</ol>\n<p>常见的测试框架有 <a href=\"https://jasmine.github.io/\" target=\"_blank\" rel=\"noopener\">Jasmine</a>, <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a>,以及本文要介绍的 <a href=\"https://facebook.github.io/jest/zh-Hans/\" target=\"_blank\" rel=\"noopener\">Jest</a> 。</p>\n<h3 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h3><p>断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 <a href=\"https://shouldjs.github.io/\" target=\"_blank\" rel=\"noopener\">Should.js</a>, <a href=\"http://www.chaijs.com/\" target=\"_blank\" rel=\"noopener\">Chai.js</a> 等。</p>\n<h3 id=\"测试覆盖率工具\"><a href=\"#测试覆盖率工具\" class=\"headerlink\" title=\"测试覆盖率工具\"></a>测试覆盖率工具</h3><p>用于统计测试用例对代码的测试情况，生成相应的报表，比如 <a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"noopener\">istanbul</a>。</p>\n<h3 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h3><ol>\n<li>为什么选择Jest<br>Jest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</li>\n</ol>\n<p>而作为一个面向前端的测试框架， Jest 可以利用其特有的<a href=\"https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content\" target=\"_blank\" rel=\"noopener\">快照测试</a>功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。</p>\n<p>此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。</p>\n<ol start=\"2\">\n<li>安装<br>Jest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"test\"</span>: <span class=\"string\">\"jest\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Jest 的测试脚本名形如<em>.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的</em>.test.js 或.spec.js 文件、完成测试。</p>\n<ol start=\"3\">\n<li>基本使用</li>\n<li>用例的表示<br>表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：<br>sum.js<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> <span class=\"built_in\">sum</span>(a, b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">module</span>.exports = <span class=\"built_in\">sum</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>sum.test.js<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const sum = require('./sum')<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">test('adds <span class=\"number\">1</span> + <span class=\"number\">2</span> to equal <span class=\"number\">3</span>', () =&gt; &#123;</span><br><span class=\"line\">  //expect(<span class=\"name\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">3</span>)<span class=\"comment\">;//成功</span></span><br><span class=\"line\">  expect(<span class=\"name\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">5</span>)<span class=\"comment\">;//失败  </span></span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中toBe(‘Hello world’)便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档<a href=\"https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。</a><br>写完了用例，运行在项目目录下执行npm test，即可看到测试结果：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg\" alt=\"\"><br>修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg\" alt=\"\"></p>\n<ol start=\"5\">\n<li>用例的预处理或后处理：<br>有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。</li>\n</ol>\n<ul>\n<li>对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；</li>\n<li>如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；</li>\n<li>后处理，可以使用对应的 afterAll() 和 afterEach() 函数。</li>\n<li>如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：</li>\n</ul>\n<p>checkAll.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">obj</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> o=&#123;</span><br><span class=\"line\">    foo:<span class=\"literal\">true</span>,</span><br><span class=\"line\">    bar:<span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports=obj();</span><br></pre></td></tr></table></figure></p>\n<p>checkAll.test.js<br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var testObject = <span class=\"built_in\">require</span>(<span class=\"string\">'./checkAll'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'test testObject'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    beforeAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span> 预处理操作</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    test(<span class=\"string\">'is foo'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">       expect(testObject.foo).toBeTruthy();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    test(<span class=\"string\">'is not bar'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        expect(testObject.bar).toBeFalsy();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    afterAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span> 后处理操作</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>执行npm test<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg\" alt=\"\"></p>\n<h3 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a>Mocha</h3><p>Mocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.js内置的assert模块作为断言<br>让我们一起看看assert有哪些常见用法：</p>\n<p>原文：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000004558796\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000004558796</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28162082\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/28162082</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"常用的前端测试工具一览\"><a href=\"#常用的前端测试工具一览\" class=\"headerlink\" title=\"常用的前端测试工具一览\"></a>常用的前端测试工具一览</h3><p>前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为 <strong>测试框架</strong>、<strong>断言库</strong>、<strong>测试覆盖率工具</strong> 等几类。在正式开始本文之前，我们先来大致了解下它们：</p>\n<h3 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h3><p>测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。<br>测试一般分两种：BDD和TDD<br>","more":"</p>\n<ol>\n<li>先介绍Test-Driven Development(TDD)即测试驱动开发，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。国外使用这种开发模式较多，github上大型的开源项目，如果没跑过测试用例，大概是没人敢在生产环境中使用的。<br>测试驱动对开发过程的要求：</li>\n</ol>\n<ul>\n<li>单元尽量解耦，否则单元不可测</li>\n<li>开发前，先设计接口，再实现细节</li>\n<li>便于回归和内部代码重构 (把所有单元测试，集成测试等都做好之后，实现重构就更加从容，可以一块一块进行)</li>\n</ul>\n<ol start=\"2\">\n<li>BDD指的是Behavior Drive Development，也就是行为驱动开发。传统的开发模式中，客户很难从技术层面理解问题，开发人员很难从业务需求考虑问题，BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析需求，然后将这些需求写成一个个的故事(应用场景)。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，通过设定各种业务场景中该展示的状态、适用的事件，以及场景的执行结果，基本就完成了一个完整测试的定义。</li>\n</ol>\n<p>常见的测试框架有 <a href=\"https://jasmine.github.io/\" target=\"_blank\" rel=\"noopener\">Jasmine</a>, <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a>,以及本文要介绍的 <a href=\"https://facebook.github.io/jest/zh-Hans/\" target=\"_blank\" rel=\"noopener\">Jest</a> 。</p>\n<h3 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h3><p>断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 <a href=\"https://shouldjs.github.io/\" target=\"_blank\" rel=\"noopener\">Should.js</a>, <a href=\"http://www.chaijs.com/\" target=\"_blank\" rel=\"noopener\">Chai.js</a> 等。</p>\n<h3 id=\"测试覆盖率工具\"><a href=\"#测试覆盖率工具\" class=\"headerlink\" title=\"测试覆盖率工具\"></a>测试覆盖率工具</h3><p>用于统计测试用例对代码的测试情况，生成相应的报表，比如 <a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"noopener\">istanbul</a>。</p>\n<h3 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h3><ol>\n<li>为什么选择Jest<br>Jest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</li>\n</ol>\n<p>而作为一个面向前端的测试框架， Jest 可以利用其特有的<a href=\"https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content\" target=\"_blank\" rel=\"noopener\">快照测试</a>功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。</p>\n<p>此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。</p>\n<ol start=\"2\">\n<li>安装<br>Jest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"test\"</span>: <span class=\"string\">\"jest\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Jest 的测试脚本名形如<em>.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的</em>.test.js 或.spec.js 文件、完成测试。</p>\n<ol start=\"3\">\n<li>基本使用</li>\n<li>用例的表示<br>表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：<br>sum.js<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> <span class=\"built_in\">sum</span>(a, b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">module</span>.exports = <span class=\"built_in\">sum</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>sum.test.js<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const sum = require('./sum')<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">test('adds <span class=\"number\">1</span> + <span class=\"number\">2</span> to equal <span class=\"number\">3</span>', () =&gt; &#123;</span><br><span class=\"line\">  //expect(<span class=\"name\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">3</span>)<span class=\"comment\">;//成功</span></span><br><span class=\"line\">  expect(<span class=\"name\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">5</span>)<span class=\"comment\">;//失败  </span></span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中toBe(‘Hello world’)便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档<a href=\"https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。</a><br>写完了用例，运行在项目目录下执行npm test，即可看到测试结果：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg\" alt=\"\"><br>修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg\" alt=\"\"></p>\n<ol start=\"5\">\n<li>用例的预处理或后处理：<br>有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。</li>\n</ol>\n<ul>\n<li>对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；</li>\n<li>如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；</li>\n<li>后处理，可以使用对应的 afterAll() 和 afterEach() 函数。</li>\n<li>如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：</li>\n</ul>\n<p>checkAll.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">obj</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> o=&#123;</span><br><span class=\"line\">    foo:<span class=\"literal\">true</span>,</span><br><span class=\"line\">    bar:<span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports=obj();</span><br></pre></td></tr></table></figure></p>\n<p>checkAll.test.js<br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var testObject = <span class=\"built_in\">require</span>(<span class=\"string\">'./checkAll'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'test testObject'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    beforeAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span> 预处理操作</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    test(<span class=\"string\">'is foo'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">       expect(testObject.foo).toBeTruthy();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    test(<span class=\"string\">'is not bar'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        expect(testObject.bar).toBeFalsy();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    afterAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span> 后处理操作</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>执行npm test<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg\" alt=\"\"></p>\n<h3 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a>Mocha</h3><p>Mocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.js内置的assert模块作为断言<br>让我们一起看看assert有哪些常见用法：</p>\n<p>原文：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000004558796\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000004558796</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28162082\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/28162082</a></li>\n</ul>"},{"title":"Ramda 函数库的使用","date":"2018-06-09T16:00:00.000Z","_content":"\n\n\n\n\n参考：\n1. [Ramda 函数库参考教程](http://www.ruanyifeng.com/blog/2017/03/ramda.html)\n2. [Ramda文档](https://ramdajs.com/docs/)\n","source":"_posts/Ramda 函数库的使用.md","raw":"title: Ramda 函数库的使用\ndate: 2018/06/10\ncategories:\n  - 库/框架\n  - 函数式编程\ntags:\n  - Ramda\n  -\n---\n\n\n\n\n\n参考：\n1. [Ramda 函数库参考教程](http://www.ruanyifeng.com/blog/2017/03/ramda.html)\n2. [Ramda文档](https://ramdajs.com/docs/)\n","slug":"Ramda 函数库的使用","published":1,"updated":"2018-06-11T16:16:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv300004ka0t05u1vb2h","content":"<p>参考：</p>\n<ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/03/ramda.html\" target=\"_blank\" rel=\"noopener\">Ramda 函数库参考教程</a></li>\n<li><a href=\"https://ramdajs.com/docs/\" target=\"_blank\" rel=\"noopener\">Ramda文档</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：</p>\n<ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/03/ramda.html\" target=\"_blank\" rel=\"noopener\">Ramda 函数库参考教程</a></li>\n<li><a href=\"https://ramdajs.com/docs/\" target=\"_blank\" rel=\"noopener\">Ramda文档</a></li>\n</ol>\n"},{"title":"Nodejs之npm&package.json学习","date":"2018-05-17T16:00:00.000Z","_content":"\n作为前端，因为经常用到gulp，webpack等工具，所以我们最常见到的是npm和package.json，所以先总结一下它们俩的常用命令。\n\n## npm\n### 初始化\n```\n npm init //会询问package.json的各种信息，从而确认\n\n npm init --y //全部使用默认值,快速生成package.json\n```\n### 安装依赖包\n```\n npm install <package name> <package name> ...\n\n npm install <package name> -g\n\n npm install <package name> --save\n\n npm install <package name> --save-dev\n\n npm install <pacakage name>  --O //--save-optional  -B: --save-bundle  -E: --save-exact\n```\nnpm install <package name> -g :全局安装，需要注意的是全局模式并不是将一个模块安装包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用，-g的含义是将一个包安装为全局可用的可执行命令,例如gulp，webpack等。\n\n--save与--save-dev的区别 :\n--save:是生产环境中项目运行需要的依赖,比如代码所依赖的库或框架(Jquery,React等)，安装后被记录在package.json中的dependencies关键字下；\n--save-dev:开发时候需要的依赖，安装后被记录在devDependencies关键字下。如一些开发时候需要用的gulp，webpack工具。\n\n同样--O/B/E分别会被记录到对应的关键字下。\n\n### 更新依赖包\n```\n npm update\n\n npm update  -g\n\n npm outdated\n\n npm outdated -g\n```\n\n在项目目录下运行npm update可以升级项目中所用依赖到最新版本，而npm update -g则可以升级全局安装的依赖包到最新版。\n\nnpm outdated用于检查模块是否过时并列出。\n\n### 卸载依赖\n```\n npm uninstall <package name> <package name> ...\n\n npm uninstall <package name> -g\n\n npm uninstall <package name> --save\n\n npm uninstall <package name> --save-dev\n```\n使用npm uninstall可以卸载依赖，但是卸载后，在package.json中的纪录并不会被删除，要想在卸载依赖的同时删除在package.json中的纪录，需要在卸载的时候使用安装时的所有的选项，例如，如果安装时候使用了npm install <package name> --save则卸载的时候，同样使用npm uninstall <pacakage name> --save，而如果使用了--save-dev，卸载时候也需要加相同的选项。\n\n### 使用自定义npm命令\n在package.json中，有一个scripts关键字，只需要在该关键字内写入自定义命令以及对应执行的实际命令即可。\n```\n\"scripts\":{\n    \"test\": \"nonde ./test.js\",\n    \"dev\": \"gulp --gulpfile gulpfile-dev.js\",\n    \"build\": \"gulp --gulpfile gulpfile-build.js\"\n}\n```\n上面的配置中，只要我们在终端运行npm dev就是运行了gulp --gulpfile gulpfile-dev.js，这样就省去了我们在终端输入很长的一段命令，非常方便。\n\n### 其他\nnpm view <pacakage name>可以查看包的package.json文件，如果只是看包的某个特性，在后面加上相应的key即可，例如npm v zepto version就是查看当前安装的zepto的版本，v是view的简写。\n\nnpm ls可以分析出当前当前项目下能够通过模块路径找到的所有包，并生成依赖树。\n\nnpm doc <package name>可以打开该依赖包的官网，其实就是打开了package.json中的homepage。\n\n## package.json文件\n在运行npm init后会生成package.json文件，该文件用于记录项目中所用到的依赖以及项目的配置信息（比如名称、版本、许可证等）。npm install命令根据这个配置文件自动下载项目运行和开发所需要的依赖。\n一个比较完整的package.json文件如下：\n```\n{\n    \"name\": \"project\", //包名\n    \"version\": \"1.0.0\", //版本号\n    \"author\": \"张三\", //包的作者的名字\n    \"description\": \"第一个node.js程序\",//包的描述\n    \"keywords\":[\"node.js\",\"javascript\"], //关键字\n    \"repository\": { //包代码存放的地方，可以是git或者svn\n        \"type\": \"git\",\n        \"url\": \"https://path/to/url\"\n    },\n    \"license\":\"MIT\",//开源许可证\n    \"engines\": {\"node\": \"0.10.x\"},\n    \"bugs\":{\"url\":\"http://path/to/bug\",\"email\":\"bug@example.com\"},\n    \"contributors\":[{\"name\":\"李四\",\"email\":\"lisi@example.com\"}],\n    \"scripts\": {\n        \"start\": \"node index.js\"\n    },\n    \"dependencies\": {\n        \"express\": \"latest\",\n        \"mongoose\": \"~3.8.3\"\n    },\n    \"devDependencies\": {\n        \"grunt\": \"~0.4.1\",\n        \"grunt-contrib-concat\": \"~0.3.0\"\n    }\n}\n```\n1. 小标签1：如何为代码选择开源许可证，这是一个问题。\n世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种----GPL、BSD、MIT、Mozilla、Apache和LGPL----之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是阮一峰老师制作的中文版，请点击看大图。\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/license.png)\n2. engines\n```\n可选字段。既可以指定node版本:\n { \"engines\" : {\"node\" : \">=0.10.3 <0.12\" } }\n也可以指定npm版本：\n { \"engines\" : {\"npm\" : \"~1.0.20\" } }\n```\n\n3. scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包.\n示例如下:\n```\n\n\"scripts\":{\n\n    “install”:\"install.js\",\n\n    \"test\":\"test.js\"\n\n}\n```\n4. main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果该字段不存在，则node会检查目录下的index.js，index.node，index.json作为默认入口。\n\n\n\n\n\n\n原文：\nhttps://segmentfault.com/a/1190000007624021\nhttp://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\n","source":"_posts/Nodejs之npm&package.json学习.md","raw":"title: Nodejs之npm&package.json学习\ndate: 2018/05/18\ncategories: Nodejs\ntags:\n  - Nodejs\n---\n\n作为前端，因为经常用到gulp，webpack等工具，所以我们最常见到的是npm和package.json，所以先总结一下它们俩的常用命令。\n\n## npm\n### 初始化\n```\n npm init //会询问package.json的各种信息，从而确认\n\n npm init --y //全部使用默认值,快速生成package.json\n```\n### 安装依赖包\n```\n npm install <package name> <package name> ...\n\n npm install <package name> -g\n\n npm install <package name> --save\n\n npm install <package name> --save-dev\n\n npm install <pacakage name>  --O //--save-optional  -B: --save-bundle  -E: --save-exact\n```\nnpm install <package name> -g :全局安装，需要注意的是全局模式并不是将一个模块安装包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用，-g的含义是将一个包安装为全局可用的可执行命令,例如gulp，webpack等。\n\n--save与--save-dev的区别 :\n--save:是生产环境中项目运行需要的依赖,比如代码所依赖的库或框架(Jquery,React等)，安装后被记录在package.json中的dependencies关键字下；\n--save-dev:开发时候需要的依赖，安装后被记录在devDependencies关键字下。如一些开发时候需要用的gulp，webpack工具。\n\n同样--O/B/E分别会被记录到对应的关键字下。\n\n### 更新依赖包\n```\n npm update\n\n npm update  -g\n\n npm outdated\n\n npm outdated -g\n```\n\n在项目目录下运行npm update可以升级项目中所用依赖到最新版本，而npm update -g则可以升级全局安装的依赖包到最新版。\n\nnpm outdated用于检查模块是否过时并列出。\n\n### 卸载依赖\n```\n npm uninstall <package name> <package name> ...\n\n npm uninstall <package name> -g\n\n npm uninstall <package name> --save\n\n npm uninstall <package name> --save-dev\n```\n使用npm uninstall可以卸载依赖，但是卸载后，在package.json中的纪录并不会被删除，要想在卸载依赖的同时删除在package.json中的纪录，需要在卸载的时候使用安装时的所有的选项，例如，如果安装时候使用了npm install <package name> --save则卸载的时候，同样使用npm uninstall <pacakage name> --save，而如果使用了--save-dev，卸载时候也需要加相同的选项。\n\n### 使用自定义npm命令\n在package.json中，有一个scripts关键字，只需要在该关键字内写入自定义命令以及对应执行的实际命令即可。\n```\n\"scripts\":{\n    \"test\": \"nonde ./test.js\",\n    \"dev\": \"gulp --gulpfile gulpfile-dev.js\",\n    \"build\": \"gulp --gulpfile gulpfile-build.js\"\n}\n```\n上面的配置中，只要我们在终端运行npm dev就是运行了gulp --gulpfile gulpfile-dev.js，这样就省去了我们在终端输入很长的一段命令，非常方便。\n\n### 其他\nnpm view <pacakage name>可以查看包的package.json文件，如果只是看包的某个特性，在后面加上相应的key即可，例如npm v zepto version就是查看当前安装的zepto的版本，v是view的简写。\n\nnpm ls可以分析出当前当前项目下能够通过模块路径找到的所有包，并生成依赖树。\n\nnpm doc <package name>可以打开该依赖包的官网，其实就是打开了package.json中的homepage。\n\n## package.json文件\n在运行npm init后会生成package.json文件，该文件用于记录项目中所用到的依赖以及项目的配置信息（比如名称、版本、许可证等）。npm install命令根据这个配置文件自动下载项目运行和开发所需要的依赖。\n一个比较完整的package.json文件如下：\n```\n{\n    \"name\": \"project\", //包名\n    \"version\": \"1.0.0\", //版本号\n    \"author\": \"张三\", //包的作者的名字\n    \"description\": \"第一个node.js程序\",//包的描述\n    \"keywords\":[\"node.js\",\"javascript\"], //关键字\n    \"repository\": { //包代码存放的地方，可以是git或者svn\n        \"type\": \"git\",\n        \"url\": \"https://path/to/url\"\n    },\n    \"license\":\"MIT\",//开源许可证\n    \"engines\": {\"node\": \"0.10.x\"},\n    \"bugs\":{\"url\":\"http://path/to/bug\",\"email\":\"bug@example.com\"},\n    \"contributors\":[{\"name\":\"李四\",\"email\":\"lisi@example.com\"}],\n    \"scripts\": {\n        \"start\": \"node index.js\"\n    },\n    \"dependencies\": {\n        \"express\": \"latest\",\n        \"mongoose\": \"~3.8.3\"\n    },\n    \"devDependencies\": {\n        \"grunt\": \"~0.4.1\",\n        \"grunt-contrib-concat\": \"~0.3.0\"\n    }\n}\n```\n1. 小标签1：如何为代码选择开源许可证，这是一个问题。\n世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种----GPL、BSD、MIT、Mozilla、Apache和LGPL----之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是阮一峰老师制作的中文版，请点击看大图。\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/license.png)\n2. engines\n```\n可选字段。既可以指定node版本:\n { \"engines\" : {\"node\" : \">=0.10.3 <0.12\" } }\n也可以指定npm版本：\n { \"engines\" : {\"npm\" : \"~1.0.20\" } }\n```\n\n3. scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包.\n示例如下:\n```\n\n\"scripts\":{\n\n    “install”:\"install.js\",\n\n    \"test\":\"test.js\"\n\n}\n```\n4. main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果该字段不存在，则node会检查目录下的index.js，index.node，index.json作为默认入口。\n\n\n\n\n\n\n原文：\nhttps://segmentfault.com/a/1190000007624021\nhttp://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\n","slug":"Nodejs之npm&package.json学习","published":1,"updated":"2018-05-18T16:27:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv350005ka0tyvlm6n2j","content":"<p>作为前端，因为经常用到gulp，webpack等工具，所以我们最常见到的是npm和package.json，所以先总结一下它们俩的常用命令。</p>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">init</span> <span class=\"comment\">//会询问package.json的各种信息，从而确认</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">init</span> --y <span class=\"comment\">//全部使用默认值,快速生成package.json</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; -g</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save-dev</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;pacakage <span class=\"keyword\">name</span>&gt;  <span class=\"comment\">--O //--save-optional  -B: --save-bundle  -E: --save-exact</span></span><br></pre></td></tr></table></figure>\n<p>npm install <package name=\"\"> -g :全局安装，需要注意的是全局模式并不是将一个模块安装包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用，-g的含义是将一个包安装为全局可用的可执行命令,例如gulp，webpack等。</package></p>\n<p>–save与–save-dev的区别 :<br>–save:是生产环境中项目运行需要的依赖,比如代码所依赖的库或框架(Jquery,React等)，安装后被记录在package.json中的dependencies关键字下；<br>–save-dev:开发时候需要的依赖，安装后被记录在devDependencies关键字下。如一些开发时候需要用的gulp，webpack工具。</p>\n<p>同样–O/B/E分别会被记录到对应的关键字下。</p>\n<h3 id=\"更新依赖包\"><a href=\"#更新依赖包\" class=\"headerlink\" title=\"更新依赖包\"></a>更新依赖包</h3><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> update  -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> outdated</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> outdated -g</span><br></pre></td></tr></table></figure>\n<p>在项目目录下运行npm update可以升级项目中所用依赖到最新版本，而npm update -g则可以升级全局安装的依赖包到最新版。</p>\n<p>npm outdated用于检查模块是否过时并列出。</p>\n<h3 id=\"卸载依赖\"><a href=\"#卸载依赖\" class=\"headerlink\" title=\"卸载依赖\"></a>卸载依赖</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; -g</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save-dev</span></span><br></pre></td></tr></table></figure>\n<p>使用npm uninstall可以卸载依赖，但是卸载后，在package.json中的纪录并不会被删除，要想在卸载依赖的同时删除在package.json中的纪录，需要在卸载的时候使用安装时的所有的选项，例如，如果安装时候使用了npm install <package name=\"\"> –save则卸载的时候，同样使用npm uninstall <pacakage name=\"\"> –save，而如果使用了–save-dev，卸载时候也需要加相同的选项。</pacakage></package></p>\n<h3 id=\"使用自定义npm命令\"><a href=\"#使用自定义npm命令\" class=\"headerlink\" title=\"使用自定义npm命令\"></a>使用自定义npm命令</h3><p>在package.json中，有一个scripts关键字，只需要在该关键字内写入自定义命令以及对应执行的实际命令即可。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"nonde ./test.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"gulp --gulpfile gulpfile-dev.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"gulp --gulpfile gulpfile-build.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的配置中，只要我们在终端运行npm dev就是运行了gulp –gulpfile gulpfile-dev.js，这样就省去了我们在终端输入很长的一段命令，非常方便。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>npm view <pacakage name=\"\">可以查看包的package.json文件，如果只是看包的某个特性，在后面加上相应的key即可，例如npm v zepto version就是查看当前安装的zepto的版本，v是view的简写。</pacakage></p>\n<p>npm ls可以分析出当前当前项目下能够通过模块路径找到的所有包，并生成依赖树。</p>\n<p>npm doc <package name=\"\">可以打开该依赖包的官网，其实就是打开了package.json中的homepage。</package></p>\n<h2 id=\"package-json文件\"><a href=\"#package-json文件\" class=\"headerlink\" title=\"package.json文件\"></a>package.json文件</h2><p>在运行npm init后会生成package.json文件，该文件用于记录项目中所用到的依赖以及项目的配置信息（比如名称、版本、许可证等）。npm install命令根据这个配置文件自动下载项目运行和开发所需要的依赖。<br>一个比较完整的package.json文件如下：<br><figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"project\"</span>, //包名</span><br><span class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>, //版本号</span><br><span class=\"line\">    <span class=\"string\">\"author\"</span>: <span class=\"string\">\"张三\"</span>, //包的作者的名字</span><br><span class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"第一个node.js程序\"</span>,//包的描述</span><br><span class=\"line\">    <span class=\"string\">\"keywords\"</span>:[<span class=\"string\">\"node.js\"</span>,<span class=\"string\">\"javascript\"</span>], //关键字</span><br><span class=\"line\">    <span class=\"string\">\"repository\"</span>: &#123; //包代码存放的地方，可以是git或者svn</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://path/to/url\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"license\"</span>:<span class=\"string\">\"MIT\"</span>,//开源许可证</span><br><span class=\"line\">    <span class=\"string\">\"engines\"</span>: &#123;<span class=\"string\">\"node\"</span>: <span class=\"string\">\"0.10.x\"</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"bugs\"</span>:&#123;<span class=\"string\">\"url\"</span>:<span class=\"string\">\"http://path/to/bug\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"bug@example.com\"</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"contributors\"</span>:[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"李四\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"lisi@example.com\"</span>&#125;],</span><br><span class=\"line\">    <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"start\"</span>: <span class=\"string\">\"node index.js\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"express\"</span>: <span class=\"string\">\"latest\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"mongoose\"</span>: <span class=\"string\">\"~3.8.3\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"grunt\"</span>: <span class=\"string\">\"~0.4.1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"grunt-contrib-concat\"</span>: <span class=\"string\">\"~0.3.0\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>小标签1：如何为代码选择开源许可证，这是一个问题。<br>世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是阮一峰老师制作的中文版，请点击看大图。<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/license.png\" alt=\"\"></li>\n<li><p>engines</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可选字段。既可以指定node版本:</span><br><span class=\"line\"> &#123; <span class=\"string\">\"engines\"</span> : &#123;<span class=\"string\">\"node\"</span> : <span class=\"string\">\"&gt;=0.10.3 &lt;0.12\"</span> &#125; &#125;</span><br><span class=\"line\">也可以指定npm版本：</span><br><span class=\"line\"> &#123; <span class=\"string\">\"engines\"</span> : &#123;<span class=\"string\">\"npm\"</span> : <span class=\"string\">\"~1.0.20\"</span> &#125; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包.<br>示例如下:</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    “<span class=\"keyword\">install</span>”:<span class=\"string\">\"install.js\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>:<span class=\"string\">\"test.js\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果该字段不存在，则node会检查目录下的index.js，index.node，index.json作为默认入口。</p>\n</li>\n</ol>\n<p>原文：<br><a href=\"https://segmentfault.com/a/1190000007624021\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007624021</a><br><a href=\"http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>作为前端，因为经常用到gulp，webpack等工具，所以我们最常见到的是npm和package.json，所以先总结一下它们俩的常用命令。</p>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">init</span> <span class=\"comment\">//会询问package.json的各种信息，从而确认</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">init</span> --y <span class=\"comment\">//全部使用默认值,快速生成package.json</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; -g</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save-dev</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;pacakage <span class=\"keyword\">name</span>&gt;  <span class=\"comment\">--O //--save-optional  -B: --save-bundle  -E: --save-exact</span></span><br></pre></td></tr></table></figure>\n<p>npm install <package name=\"\"> -g :全局安装，需要注意的是全局模式并不是将一个模块安装包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用，-g的含义是将一个包安装为全局可用的可执行命令,例如gulp，webpack等。</package></p>\n<p>–save与–save-dev的区别 :<br>–save:是生产环境中项目运行需要的依赖,比如代码所依赖的库或框架(Jquery,React等)，安装后被记录在package.json中的dependencies关键字下；<br>–save-dev:开发时候需要的依赖，安装后被记录在devDependencies关键字下。如一些开发时候需要用的gulp，webpack工具。</p>\n<p>同样–O/B/E分别会被记录到对应的关键字下。</p>\n<h3 id=\"更新依赖包\"><a href=\"#更新依赖包\" class=\"headerlink\" title=\"更新依赖包\"></a>更新依赖包</h3><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> update  -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> outdated</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> outdated -g</span><br></pre></td></tr></table></figure>\n<p>在项目目录下运行npm update可以升级项目中所用依赖到最新版本，而npm update -g则可以升级全局安装的依赖包到最新版。</p>\n<p>npm outdated用于检查模块是否过时并列出。</p>\n<h3 id=\"卸载依赖\"><a href=\"#卸载依赖\" class=\"headerlink\" title=\"卸载依赖\"></a>卸载依赖</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; -g</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save-dev</span></span><br></pre></td></tr></table></figure>\n<p>使用npm uninstall可以卸载依赖，但是卸载后，在package.json中的纪录并不会被删除，要想在卸载依赖的同时删除在package.json中的纪录，需要在卸载的时候使用安装时的所有的选项，例如，如果安装时候使用了npm install <package name=\"\"> –save则卸载的时候，同样使用npm uninstall <pacakage name=\"\"> –save，而如果使用了–save-dev，卸载时候也需要加相同的选项。</pacakage></package></p>\n<h3 id=\"使用自定义npm命令\"><a href=\"#使用自定义npm命令\" class=\"headerlink\" title=\"使用自定义npm命令\"></a>使用自定义npm命令</h3><p>在package.json中，有一个scripts关键字，只需要在该关键字内写入自定义命令以及对应执行的实际命令即可。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"nonde ./test.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"gulp --gulpfile gulpfile-dev.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"gulp --gulpfile gulpfile-build.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的配置中，只要我们在终端运行npm dev就是运行了gulp –gulpfile gulpfile-dev.js，这样就省去了我们在终端输入很长的一段命令，非常方便。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>npm view <pacakage name=\"\">可以查看包的package.json文件，如果只是看包的某个特性，在后面加上相应的key即可，例如npm v zepto version就是查看当前安装的zepto的版本，v是view的简写。</pacakage></p>\n<p>npm ls可以分析出当前当前项目下能够通过模块路径找到的所有包，并生成依赖树。</p>\n<p>npm doc <package name=\"\">可以打开该依赖包的官网，其实就是打开了package.json中的homepage。</package></p>\n<h2 id=\"package-json文件\"><a href=\"#package-json文件\" class=\"headerlink\" title=\"package.json文件\"></a>package.json文件</h2><p>在运行npm init后会生成package.json文件，该文件用于记录项目中所用到的依赖以及项目的配置信息（比如名称、版本、许可证等）。npm install命令根据这个配置文件自动下载项目运行和开发所需要的依赖。<br>一个比较完整的package.json文件如下：<br><figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"project\"</span>, //包名</span><br><span class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>, //版本号</span><br><span class=\"line\">    <span class=\"string\">\"author\"</span>: <span class=\"string\">\"张三\"</span>, //包的作者的名字</span><br><span class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"第一个node.js程序\"</span>,//包的描述</span><br><span class=\"line\">    <span class=\"string\">\"keywords\"</span>:[<span class=\"string\">\"node.js\"</span>,<span class=\"string\">\"javascript\"</span>], //关键字</span><br><span class=\"line\">    <span class=\"string\">\"repository\"</span>: &#123; //包代码存放的地方，可以是git或者svn</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://path/to/url\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"license\"</span>:<span class=\"string\">\"MIT\"</span>,//开源许可证</span><br><span class=\"line\">    <span class=\"string\">\"engines\"</span>: &#123;<span class=\"string\">\"node\"</span>: <span class=\"string\">\"0.10.x\"</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"bugs\"</span>:&#123;<span class=\"string\">\"url\"</span>:<span class=\"string\">\"http://path/to/bug\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"bug@example.com\"</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"contributors\"</span>:[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"李四\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"lisi@example.com\"</span>&#125;],</span><br><span class=\"line\">    <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"start\"</span>: <span class=\"string\">\"node index.js\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"express\"</span>: <span class=\"string\">\"latest\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"mongoose\"</span>: <span class=\"string\">\"~3.8.3\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"grunt\"</span>: <span class=\"string\">\"~0.4.1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"grunt-contrib-concat\"</span>: <span class=\"string\">\"~0.3.0\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>小标签1：如何为代码选择开源许可证，这是一个问题。<br>世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是阮一峰老师制作的中文版，请点击看大图。<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/license.png\" alt=\"\"></li>\n<li><p>engines</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可选字段。既可以指定node版本:</span><br><span class=\"line\"> &#123; <span class=\"string\">\"engines\"</span> : &#123;<span class=\"string\">\"node\"</span> : <span class=\"string\">\"&gt;=0.10.3 &lt;0.12\"</span> &#125; &#125;</span><br><span class=\"line\">也可以指定npm版本：</span><br><span class=\"line\"> &#123; <span class=\"string\">\"engines\"</span> : &#123;<span class=\"string\">\"npm\"</span> : <span class=\"string\">\"~1.0.20\"</span> &#125; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包.<br>示例如下:</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    “<span class=\"keyword\">install</span>”:<span class=\"string\">\"install.js\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>:<span class=\"string\">\"test.js\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果该字段不存在，则node会检查目录下的index.js，index.node，index.json作为默认入口。</p>\n</li>\n</ol>\n<p>原文：<br><a href=\"https://segmentfault.com/a/1190000007624021\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007624021</a><br><a href=\"http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a></p>\n"},{"title":"React基础之 抄文档","date":"2018-06-10T16:00:00.000Z","_content":"### React 组件 API\n#### 强制更新：forceUpdate()\n```\ncomponent.forceUpdate(callback)\n```\n\n“By default, when your component’s state or props change, your component will re-render. If your render() method depends on some other data, you can tell React that the component needs re-rendering by calling forceUpdate().\n\nCalling forceUpdate() will cause render() to be called on the component, skipping shouldComponentUpdate(). This will trigger the normal lifecycle methods for child components, including the shouldComponentUpdate() method of each child. React will still only update the DOM if the markup changes.\n\nNormally you should try to avoid all uses of forceUpdate() and only read from this.props and this.state in render().”\n\n默认情况下，当组件的state或者props属性变化时，组件将会重新渲染。然而，如果你的render()方法依赖一些别的数据。你可以通过调用forceUpdate()来让组件实现重新渲染。\n调用forceUpdate()，将会导致组件直接跳过shouldComponentUpdate()方法，去执行render()方法，这会触发子组件们正常的生命周期方法，包括每个子组件的shouldComponentUpdate()方法。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。\n**一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。**\n\n- 使用场景：\nforceUpdate就是重新render。有些变量不在state上，但是你又想达到这个变量更新的时候，刷新render；或者state里的某个变量层次太深，更新的时候没有自动触发render。这些时候都可以手动调用forceUpdate自动触发render\n\n\n原文：\n- http://www.runoob.com/react/react-component-api.html\n- https://reactjs.org/docs/react-component.html#forceupdate\n","source":"_posts/React基础之 抄文档.md","raw":"title: React基础之 抄文档\ndate: 2018/06/11\ncategories: 库/框架\ntags:\n  - React\n---\n### React 组件 API\n#### 强制更新：forceUpdate()\n```\ncomponent.forceUpdate(callback)\n```\n\n“By default, when your component’s state or props change, your component will re-render. If your render() method depends on some other data, you can tell React that the component needs re-rendering by calling forceUpdate().\n\nCalling forceUpdate() will cause render() to be called on the component, skipping shouldComponentUpdate(). This will trigger the normal lifecycle methods for child components, including the shouldComponentUpdate() method of each child. React will still only update the DOM if the markup changes.\n\nNormally you should try to avoid all uses of forceUpdate() and only read from this.props and this.state in render().”\n\n默认情况下，当组件的state或者props属性变化时，组件将会重新渲染。然而，如果你的render()方法依赖一些别的数据。你可以通过调用forceUpdate()来让组件实现重新渲染。\n调用forceUpdate()，将会导致组件直接跳过shouldComponentUpdate()方法，去执行render()方法，这会触发子组件们正常的生命周期方法，包括每个子组件的shouldComponentUpdate()方法。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。\n**一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。**\n\n- 使用场景：\nforceUpdate就是重新render。有些变量不在state上，但是你又想达到这个变量更新的时候，刷新render；或者state里的某个变量层次太深，更新的时候没有自动触发render。这些时候都可以手动调用forceUpdate自动触发render\n\n\n原文：\n- http://www.runoob.com/react/react-component-api.html\n- https://reactjs.org/docs/react-component.html#forceupdate\n","slug":"React基础之 抄文档","published":1,"updated":"2018-06-11T16:19:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv390006ka0t60f41hfm","content":"<h3 id=\"React-组件-API\"><a href=\"#React-组件-API\" class=\"headerlink\" title=\"React 组件 API\"></a>React 组件 API</h3><h4 id=\"强制更新：forceUpdate\"><a href=\"#强制更新：forceUpdate\" class=\"headerlink\" title=\"强制更新：forceUpdate()\"></a>强制更新：forceUpdate()</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">component</span><span class=\"selector-class\">.forceUpdate</span>(<span class=\"selector-tag\">callback</span>)</span><br></pre></td></tr></table></figure>\n<p>“By default, when your component’s state or props change, your component will re-render. If your render() method depends on some other data, you can tell React that the component needs re-rendering by calling forceUpdate().</p>\n<p>Calling forceUpdate() will cause render() to be called on the component, skipping shouldComponentUpdate(). This will trigger the normal lifecycle methods for child components, including the shouldComponentUpdate() method of each child. React will still only update the DOM if the markup changes.</p>\n<p>Normally you should try to avoid all uses of forceUpdate() and only read from this.props and this.state in render().”</p>\n<p>默认情况下，当组件的state或者props属性变化时，组件将会重新渲染。然而，如果你的render()方法依赖一些别的数据。你可以通过调用forceUpdate()来让组件实现重新渲染。<br>调用forceUpdate()，将会导致组件直接跳过shouldComponentUpdate()方法，去执行render()方法，这会触发子组件们正常的生命周期方法，包括每个子组件的shouldComponentUpdate()方法。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。<br><strong>一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。</strong></p>\n<ul>\n<li>使用场景：<br>forceUpdate就是重新render。有些变量不在state上，但是你又想达到这个变量更新的时候，刷新render；或者state里的某个变量层次太深，更新的时候没有自动触发render。这些时候都可以手动调用forceUpdate自动触发render</li>\n</ul>\n<p>原文：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/react/react-component-api.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/react/react-component-api.html</a></li>\n<li><a href=\"https://reactjs.org/docs/react-component.html#forceupdate\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/docs/react-component.html#forceupdate</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"React-组件-API\"><a href=\"#React-组件-API\" class=\"headerlink\" title=\"React 组件 API\"></a>React 组件 API</h3><h4 id=\"强制更新：forceUpdate\"><a href=\"#强制更新：forceUpdate\" class=\"headerlink\" title=\"强制更新：forceUpdate()\"></a>强制更新：forceUpdate()</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">component</span><span class=\"selector-class\">.forceUpdate</span>(<span class=\"selector-tag\">callback</span>)</span><br></pre></td></tr></table></figure>\n<p>“By default, when your component’s state or props change, your component will re-render. If your render() method depends on some other data, you can tell React that the component needs re-rendering by calling forceUpdate().</p>\n<p>Calling forceUpdate() will cause render() to be called on the component, skipping shouldComponentUpdate(). This will trigger the normal lifecycle methods for child components, including the shouldComponentUpdate() method of each child. React will still only update the DOM if the markup changes.</p>\n<p>Normally you should try to avoid all uses of forceUpdate() and only read from this.props and this.state in render().”</p>\n<p>默认情况下，当组件的state或者props属性变化时，组件将会重新渲染。然而，如果你的render()方法依赖一些别的数据。你可以通过调用forceUpdate()来让组件实现重新渲染。<br>调用forceUpdate()，将会导致组件直接跳过shouldComponentUpdate()方法，去执行render()方法，这会触发子组件们正常的生命周期方法，包括每个子组件的shouldComponentUpdate()方法。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。<br><strong>一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。</strong></p>\n<ul>\n<li>使用场景：<br>forceUpdate就是重新render。有些变量不在state上，但是你又想达到这个变量更新的时候，刷新render；或者state里的某个变量层次太深，更新的时候没有自动触发render。这些时候都可以手动调用forceUpdate自动触发render</li>\n</ul>\n<p>原文：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/react/react-component-api.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/react/react-component-api.html</a></li>\n<li><a href=\"https://reactjs.org/docs/react-component.html#forceupdate\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/docs/react-component.html#forceupdate</a></li>\n</ul>\n"},{"title":"React基础之 父组件调用子组件的方法","date":"2018-06-01T16:00:00.000Z","_content":"直接上代码~~\n```\nexport default class Parent extends Component {\n     render() {\n         return(\n             <div>\n                 <Child alias={this.doSth} /><br/>\n                 <button onClick={this.click} >父组件click</button>\n             </div>\n         )\n     }\n\n     doSth = (ref) => {    //获取子组件的作用域\n         this.anything = ref\n     }\n\n     click = (e) => {\n         this.anything.myName()\n     }\n\n }\n\n class Child extends Component {\n     componentDidMount(){\n         this.props.alias(this)  //子组件中的this作为参数传入\n     }\n\n     myName = () => alert('click me ')\n\n     render() {\n         return ('我是子组件')\n     }\n }\n```\n\n简化下代码：\n```\n\nexport default class Parent extends Component {\n  render() {\n      return(\n          <div>\n              <Child alias={(ref)=>{this.anything = ref}}/><br/>\n              <button onClick={()=>{this.anything.myName()}} >父组件click</button>\n          </div>\n      )\n  }\n}\n\nclass Child extends Component {\n  componentDidMount(){\n      this.props.alias(this)\n  }\n\n  myName = () => alert('click me ')\n\n  render() {\n      return ('我是子组件')\n  }\n}\n```\n\n\n上面点击按钮,会弹出子组件的输出\n\n原文：\nhttps://blog.csdn.net/hesonggg/article/details/79373565\n","source":"_posts/React基础之 父组件如何调用子组件中的方法.md","raw":"title: React基础之 父组件调用子组件的方法\ndate: 2018/06/02\ncategories: 库/框架\ntags:\n  - React\n---\n直接上代码~~\n```\nexport default class Parent extends Component {\n     render() {\n         return(\n             <div>\n                 <Child alias={this.doSth} /><br/>\n                 <button onClick={this.click} >父组件click</button>\n             </div>\n         )\n     }\n\n     doSth = (ref) => {    //获取子组件的作用域\n         this.anything = ref\n     }\n\n     click = (e) => {\n         this.anything.myName()\n     }\n\n }\n\n class Child extends Component {\n     componentDidMount(){\n         this.props.alias(this)  //子组件中的this作为参数传入\n     }\n\n     myName = () => alert('click me ')\n\n     render() {\n         return ('我是子组件')\n     }\n }\n```\n\n简化下代码：\n```\n\nexport default class Parent extends Component {\n  render() {\n      return(\n          <div>\n              <Child alias={(ref)=>{this.anything = ref}}/><br/>\n              <button onClick={()=>{this.anything.myName()}} >父组件click</button>\n          </div>\n      )\n  }\n}\n\nclass Child extends Component {\n  componentDidMount(){\n      this.props.alias(this)\n  }\n\n  myName = () => alert('click me ')\n\n  render() {\n      return ('我是子组件')\n  }\n}\n```\n\n\n上面点击按钮,会弹出子组件的输出\n\n原文：\nhttps://blog.csdn.net/hesonggg/article/details/79373565\n","slug":"React基础之 父组件如何调用子组件中的方法","published":1,"updated":"2018-06-02T12:00:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3a0007ka0tw72nbvsc","content":"<p>直接上代码~~<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">     render() &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span>(</span><br><span class=\"line\">             &lt;div&gt;</span><br><span class=\"line\">                 &lt;<span class=\"type\">Child</span> alias=&#123;<span class=\"keyword\">this</span>.doSth&#125; /&gt;&lt;br/&gt;</span><br><span class=\"line\">                 &lt;button onClick=&#123;<span class=\"keyword\">this</span>.click&#125; &gt;父组件click&lt;/button&gt;</span><br><span class=\"line\">             &lt;/div&gt;</span><br><span class=\"line\">         )</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     doSth = (ref) =&gt; &#123;    <span class=\"comment\">//获取子组件的作用域</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.anything = ref</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     click = (e) =&gt; &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.anything.myName()</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">     componentDidMount()&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.props.alias(<span class=\"keyword\">this</span>)  <span class=\"comment\">//子组件中的this作为参数传入</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     myName = () =&gt; alert(<span class=\"symbol\">'click</span> me ')</span><br><span class=\"line\"></span><br><span class=\"line\">     render() &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> ('我是子组件')</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>简化下代码：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>(</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">              &lt;<span class=\"type\">Child</span> alias=&#123;(ref)=&gt;&#123;<span class=\"keyword\">this</span>.anything = ref&#125;&#125;/&gt;&lt;br/&gt;</span><br><span class=\"line\">              &lt;button onClick=&#123;()=&gt;&#123;<span class=\"keyword\">this</span>.anything.myName()&#125;&#125; &gt;父组件click&lt;/button&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.alias(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  myName = () =&gt; alert(<span class=\"symbol\">'click</span> me ')</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ('我是子组件')</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面点击按钮,会弹出子组件的输出</p>\n<p>原文：<br><a href=\"https://blog.csdn.net/hesonggg/article/details/79373565\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hesonggg/article/details/79373565</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>直接上代码~~<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">     render() &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span>(</span><br><span class=\"line\">             &lt;div&gt;</span><br><span class=\"line\">                 &lt;<span class=\"type\">Child</span> alias=&#123;<span class=\"keyword\">this</span>.doSth&#125; /&gt;&lt;br/&gt;</span><br><span class=\"line\">                 &lt;button onClick=&#123;<span class=\"keyword\">this</span>.click&#125; &gt;父组件click&lt;/button&gt;</span><br><span class=\"line\">             &lt;/div&gt;</span><br><span class=\"line\">         )</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     doSth = (ref) =&gt; &#123;    <span class=\"comment\">//获取子组件的作用域</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.anything = ref</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     click = (e) =&gt; &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.anything.myName()</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">     componentDidMount()&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.props.alias(<span class=\"keyword\">this</span>)  <span class=\"comment\">//子组件中的this作为参数传入</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     myName = () =&gt; alert(<span class=\"symbol\">'click</span> me ')</span><br><span class=\"line\"></span><br><span class=\"line\">     render() &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> ('我是子组件')</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>简化下代码：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>(</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">              &lt;<span class=\"type\">Child</span> alias=&#123;(ref)=&gt;&#123;<span class=\"keyword\">this</span>.anything = ref&#125;&#125;/&gt;&lt;br/&gt;</span><br><span class=\"line\">              &lt;button onClick=&#123;()=&gt;&#123;<span class=\"keyword\">this</span>.anything.myName()&#125;&#125; &gt;父组件click&lt;/button&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.alias(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  myName = () =&gt; alert(<span class=\"symbol\">'click</span> me ')</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ('我是子组件')</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面点击按钮,会弹出子组件的输出</p>\n<p>原文：<br><a href=\"https://blog.csdn.net/hesonggg/article/details/79373565\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hesonggg/article/details/79373565</a></p>\n"},{"title":"React-Element中的StyleSheet.reset方法为何可以重置样式？","date":"2018-06-12T16:00:00.000Z","_content":"\n在React-Element的Select组件中，一上来就来了行看不懂的代码，\n```\nStyleSheet.reset(`\n  .ishow-select-dropdown {\n    position: absolute !important;\n  }\n`)\n```\n发现该方法可以实现，在当前页面插入带着样式的style标签，来实现对css的覆盖，心生疑虑，这到底是react的API还是es7黑魔法？\n\n而后发现 Style只是从外部引入的一个模块，代码 动态添加了style节点\n\n```\nexports.reset = css => {\n  const style = document.createElement('style'); //通过指定名称创建一个style元素\n\n  style.type = 'text/css';\n  //1.必需的 type 属性规定样式表的 MIME 类型。  2.type 属性指示 <style> 与 </style> 标签之间的内容。 3.值 \"text/css\" 指示内容是标准的 CSS。\n\n  if (style.styleSheet){\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n«»\n  (document.head || document.getElementsByTagName('head')[0]).appendChild(style);\n}\n```\n\n被这波原生js操作晃瞎了眼呀~只好再复习下原生用法\n\n- [style 标签的 type 属性](http://www.w3school.com.cn/tags/att_style_type.asp)\n","source":"_posts/React-Element中的StyleSheet.reset方法为何可以重置样式？.md","raw":"title: React-Element中的StyleSheet.reset方法为何可以重置样式？\ndate: 2018/06/13\ncategories: 十万个为什么\ntags:\n  - Javascript\n  - React\n\n---\n\n在React-Element的Select组件中，一上来就来了行看不懂的代码，\n```\nStyleSheet.reset(`\n  .ishow-select-dropdown {\n    position: absolute !important;\n  }\n`)\n```\n发现该方法可以实现，在当前页面插入带着样式的style标签，来实现对css的覆盖，心生疑虑，这到底是react的API还是es7黑魔法？\n\n而后发现 Style只是从外部引入的一个模块，代码 动态添加了style节点\n\n```\nexports.reset = css => {\n  const style = document.createElement('style'); //通过指定名称创建一个style元素\n\n  style.type = 'text/css';\n  //1.必需的 type 属性规定样式表的 MIME 类型。  2.type 属性指示 <style> 与 </style> 标签之间的内容。 3.值 \"text/css\" 指示内容是标准的 CSS。\n\n  if (style.styleSheet){\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n«»\n  (document.head || document.getElementsByTagName('head')[0]).appendChild(style);\n}\n```\n\n被这波原生js操作晃瞎了眼呀~只好再复习下原生用法\n\n- [style 标签的 type 属性](http://www.w3school.com.cn/tags/att_style_type.asp)\n","slug":"React-Element中的StyleSheet.reset方法为何可以重置样式？","published":1,"updated":"2018-06-13T13:05:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3e0008ka0txvmcz347","content":"<p>在React-Element的Select组件中，一上来就来了行看不懂的代码，<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">StyleSheet</span><span class=\"selector-class\">.reset</span>(`</span><br><span class=\"line\">  <span class=\"selector-class\">.ishow-select-dropdown</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute <span class=\"meta\">!important</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">`)</span><br></pre></td></tr></table></figure></p>\n<p>发现该方法可以实现，在当前页面插入带着样式的style标签，来实现对css的覆盖，心生疑虑，这到底是react的API还是es7黑魔法？</p>\n<p>而后发现 Style只是从外部引入的一个模块，代码 动态添加了style节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.reset = <span class=\"function\"><span class=\"params\">css</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> style = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'style'</span>); <span class=\"comment\">//通过指定名称创建一个style元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">  style.type = <span class=\"string\">'text/css'</span>;</span><br><span class=\"line\">  <span class=\"comment\">//1.必需的 type 属性规定样式表的 MIME 类型。  2.type 属性指示 &lt;style&gt; 与 &lt;/style&gt; 标签之间的内容。 3.值 \"text/css\" 指示内容是标准的 CSS。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (style.styleSheet)&#123;</span><br><span class=\"line\">    style.styleSheet.cssText = css;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    style.appendChild(<span class=\"built_in\">document</span>.createTextNode(css));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">«»</span><br><span class=\"line\">  (<span class=\"built_in\">document</span>.head || <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>]).appendChild(style);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>被这波原生js操作晃瞎了眼呀~只好再复习下原生用法</p>\n<ul>\n<li><a href=\"http://www.w3school.com.cn/tags/att_style_type.asp\" target=\"_blank\" rel=\"noopener\">style 标签的 type 属性</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在React-Element的Select组件中，一上来就来了行看不懂的代码，<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">StyleSheet</span><span class=\"selector-class\">.reset</span>(`</span><br><span class=\"line\">  <span class=\"selector-class\">.ishow-select-dropdown</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute <span class=\"meta\">!important</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">`)</span><br></pre></td></tr></table></figure></p>\n<p>发现该方法可以实现，在当前页面插入带着样式的style标签，来实现对css的覆盖，心生疑虑，这到底是react的API还是es7黑魔法？</p>\n<p>而后发现 Style只是从外部引入的一个模块，代码 动态添加了style节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.reset = <span class=\"function\"><span class=\"params\">css</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> style = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'style'</span>); <span class=\"comment\">//通过指定名称创建一个style元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">  style.type = <span class=\"string\">'text/css'</span>;</span><br><span class=\"line\">  <span class=\"comment\">//1.必需的 type 属性规定样式表的 MIME 类型。  2.type 属性指示 &lt;style&gt; 与 &lt;/style&gt; 标签之间的内容。 3.值 \"text/css\" 指示内容是标准的 CSS。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (style.styleSheet)&#123;</span><br><span class=\"line\">    style.styleSheet.cssText = css;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    style.appendChild(<span class=\"built_in\">document</span>.createTextNode(css));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">«»</span><br><span class=\"line\">  (<span class=\"built_in\">document</span>.head || <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>]).appendChild(style);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>被这波原生js操作晃瞎了眼呀~只好再复习下原生用法</p>\n<ul>\n<li><a href=\"http://www.w3school.com.cn/tags/att_style_type.asp\" target=\"_blank\" rel=\"noopener\">style 标签的 type 属性</a></li>\n</ul>\n"},{"title":"React进阶之 React性能优化","date":"2018-05-20T16:00:00.000Z","_content":"\n### 利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\n### 谈一谈创建React Component的几种方式\n### React PureComponent 使用指南\n\n原文：\nhttps://www.cnblogs.com/penghuwan/p/6707254.html\nhttps://www.cnblogs.com/Unknw/p/6431375.html\nhttp://www.wulv.site/2017-05-31/react-purecomponent.html\n","source":"_posts/React进阶之 React性能优化.md","raw":"title: React进阶之 React性能优化\ndate: 2018/05/21\ncategories: 库/框架\ntags:\n  - React\n---\n\n### 利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\n### 谈一谈创建React Component的几种方式\n### React PureComponent 使用指南\n\n原文：\nhttps://www.cnblogs.com/penghuwan/p/6707254.html\nhttps://www.cnblogs.com/Unknw/p/6431375.html\nhttp://www.wulv.site/2017-05-31/react-purecomponent.html\n","slug":"React进阶之 React性能优化","published":1,"updated":"2018-05-22T14:10:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3i0009ka0t5qzclws9","content":"<h3 id=\"利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\"><a href=\"#利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\" class=\"headerlink\" title=\"利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\"></a>利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性</h3><h3 id=\"谈一谈创建React-Component的几种方式\"><a href=\"#谈一谈创建React-Component的几种方式\" class=\"headerlink\" title=\"谈一谈创建React Component的几种方式\"></a>谈一谈创建React Component的几种方式</h3><h3 id=\"React-PureComponent-使用指南\"><a href=\"#React-PureComponent-使用指南\" class=\"headerlink\" title=\"React PureComponent 使用指南\"></a>React PureComponent 使用指南</h3><p>原文：<br><a href=\"https://www.cnblogs.com/penghuwan/p/6707254.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/penghuwan/p/6707254.html</a><br><a href=\"https://www.cnblogs.com/Unknw/p/6431375.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Unknw/p/6431375.html</a><br><a href=\"http://www.wulv.site/2017-05-31/react-purecomponent.html\" target=\"_blank\" rel=\"noopener\">http://www.wulv.site/2017-05-31/react-purecomponent.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\"><a href=\"#利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\" class=\"headerlink\" title=\"利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\"></a>利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性</h3><h3 id=\"谈一谈创建React-Component的几种方式\"><a href=\"#谈一谈创建React-Component的几种方式\" class=\"headerlink\" title=\"谈一谈创建React Component的几种方式\"></a>谈一谈创建React Component的几种方式</h3><h3 id=\"React-PureComponent-使用指南\"><a href=\"#React-PureComponent-使用指南\" class=\"headerlink\" title=\"React PureComponent 使用指南\"></a>React PureComponent 使用指南</h3><p>原文：<br><a href=\"https://www.cnblogs.com/penghuwan/p/6707254.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/penghuwan/p/6707254.html</a><br><a href=\"https://www.cnblogs.com/Unknw/p/6431375.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Unknw/p/6431375.html</a><br><a href=\"http://www.wulv.site/2017-05-31/react-purecomponent.html\" target=\"_blank\" rel=\"noopener\">http://www.wulv.site/2017-05-31/react-purecomponent.html</a></p>\n"},{"title":"flex布局从懵逼到运用","date":"2018-05-05T16:00:00.000Z","_content":"\n\n<figure>\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"></img>\n</figure>\n\n本文包括了Flex布局的语法介绍，以及几种运用Flex布局实现的实例，涵盖了常见的使用场景。\n\n### 一、Flex 布局是什么？\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n任何一个容器都可以指定为 Flex 布局。\n```\n.box{\n  display: flex;\n}\n```\n行内元素也可以使用 Flex 布局。\n```\n.box{\n  display: inline-flex;\n}\n```\nWebkit 内核的浏览器，必须加上-webkit前缀。\n```\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n```\n注意：**设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效**。\n\n### 二、基本概念\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"></img>\n容器默认存在两根轴，水平的叫做 **主轴**(main axis),垂直的叫做 **交叉轴**(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n### 三、容器的属性\n```\n<div class=\"container\">\n        <div class=\"item\">1</div>\n        <div class=\"item\">2</div>\n        <div class=\"item\">3</div>\n</div>\n```\n以下6个属性设置在容器上\n```\n  flex-direction\n  flex-wrap\n  flex-flow\n  justify-content\n  align-items\n  align-content\n```\n\n#### 1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\n\n```\n  .container {\n    flex-direction: row | row-reverse | column | column-reverse;\n  }\n```\n- row(默认值)：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿。\n\n#### 2. flex-wrap属性，默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\n```\n.container{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n- nowrap（默认）：不换行。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n#### 3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n```\n.container{\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n#### 4.justify-content属性，定义了项目在 **主轴** 上的对齐方式\n```\n.container{\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍\n\n#### 5.align-items属性,定义项目在 **交叉轴** 上如何对齐\n```\n.container{\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n#### 6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n```\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n### 四、项目的属性\n以下6个属性设置在项目上。\n- order\n- flex-grow\n- flex-shrink\n- flex-basis\n- flex\n- align-self\n\n#### 1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n```\n.item {\n  order: <integer>;\n}\n```\n\n####  2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n```\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n#### 3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n```\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n#### 4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）\n浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n```\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n#### 5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n```\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'> <'flex-basis'> ]\n}\n```\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n#### 6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.\n可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch\n```\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n\nflex布局练习代码：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flexDemo.jpg)\nHTML:\n```\n<div class=\"container\">\n    <div class=\"item\">1</div>\n    <div class=\"item\">2</div>\n    <div class=\"item\">3</div>\n    <div class=\"item\">4</div>\n    <div class=\"item\">5</div>\n    <div class=\"item\">6</div>\n    <div class=\"item\">7</div>\n    <div class=\"item\">8</div>\n    <div class=\"item\">9</div>\n    <div class=\"item\">10</div>\n    <div class=\"item\">11</div>\n</div>\n```\nCSS:\n```\n.container {\n    width: 300px;\n    /* height: 400px; */\n    background-color: blanchedalmond;\n    display: flex;\n    flex-flow: row wrap;\n    /* 默认 */\n    justify-content: flex-start;\n    align-items: flex-start;\n    align-content: space-around;\n}\n.container .item {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 5px;\n    width: 50px;\n    height: 50px;\n    background-color: rgba(0, 0, 255, 0.315)\n}\n.container .item:nth-of-type(1) {\n    flex-grow: 7;\n    width: 100px;\n    height: 100px;\n}\n.container .item:nth-of-type(2) {\n    flex-shrink: 0;\n    /*flex-shrink为0时，即使空间不够，也不缩小*/\n    width: 100px;\n    height: 100px;\n}\n.container .item:nth-of-type(3) {\n    /* order: 1; */\n    flex-basis: 200px;\n    width: 200px;\n    height: 60px;\n}\n.container .item:nth-of-type(4) {\n    width: 30px;\n    height: 30px;\n}\n.container .item:nth-of-type(5) {\n    width: 70px;\n    height: 70px;\n}\n```\n\n### 五、flex运用实例\n1. 如何使用flex布局绘制筛子的6个面？\n\n\n2. 网格布局\n\n3. 圣杯布局\n\n4. 输入框组件的布局\n\n5. 悬挂式布局\n\n6. 固定的底栏\n\n7. 流式布局\n\n未完待续...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n原文：阮老师的博客\n- http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$\n- http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\n","source":"_posts/flex布局从入门到运用.md","raw":"title: flex布局从懵逼到运用\ndate: 2018/05/06\ncategories: 前端基础\n---\n\n\n<figure>\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"></img>\n</figure>\n\n本文包括了Flex布局的语法介绍，以及几种运用Flex布局实现的实例，涵盖了常见的使用场景。\n\n### 一、Flex 布局是什么？\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n任何一个容器都可以指定为 Flex 布局。\n```\n.box{\n  display: flex;\n}\n```\n行内元素也可以使用 Flex 布局。\n```\n.box{\n  display: inline-flex;\n}\n```\nWebkit 内核的浏览器，必须加上-webkit前缀。\n```\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n```\n注意：**设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效**。\n\n### 二、基本概念\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"></img>\n容器默认存在两根轴，水平的叫做 **主轴**(main axis),垂直的叫做 **交叉轴**(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n### 三、容器的属性\n```\n<div class=\"container\">\n        <div class=\"item\">1</div>\n        <div class=\"item\">2</div>\n        <div class=\"item\">3</div>\n</div>\n```\n以下6个属性设置在容器上\n```\n  flex-direction\n  flex-wrap\n  flex-flow\n  justify-content\n  align-items\n  align-content\n```\n\n#### 1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\n\n```\n  .container {\n    flex-direction: row | row-reverse | column | column-reverse;\n  }\n```\n- row(默认值)：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿。\n\n#### 2. flex-wrap属性，默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\n```\n.container{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n- nowrap（默认）：不换行。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n#### 3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n```\n.container{\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n#### 4.justify-content属性，定义了项目在 **主轴** 上的对齐方式\n```\n.container{\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍\n\n#### 5.align-items属性,定义项目在 **交叉轴** 上如何对齐\n```\n.container{\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n#### 6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n```\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n### 四、项目的属性\n以下6个属性设置在项目上。\n- order\n- flex-grow\n- flex-shrink\n- flex-basis\n- flex\n- align-self\n\n#### 1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n```\n.item {\n  order: <integer>;\n}\n```\n\n####  2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n```\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n#### 3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n```\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n#### 4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）\n浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n```\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n#### 5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n```\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'> <'flex-basis'> ]\n}\n```\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n#### 6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.\n可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch\n```\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n\nflex布局练习代码：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flexDemo.jpg)\nHTML:\n```\n<div class=\"container\">\n    <div class=\"item\">1</div>\n    <div class=\"item\">2</div>\n    <div class=\"item\">3</div>\n    <div class=\"item\">4</div>\n    <div class=\"item\">5</div>\n    <div class=\"item\">6</div>\n    <div class=\"item\">7</div>\n    <div class=\"item\">8</div>\n    <div class=\"item\">9</div>\n    <div class=\"item\">10</div>\n    <div class=\"item\">11</div>\n</div>\n```\nCSS:\n```\n.container {\n    width: 300px;\n    /* height: 400px; */\n    background-color: blanchedalmond;\n    display: flex;\n    flex-flow: row wrap;\n    /* 默认 */\n    justify-content: flex-start;\n    align-items: flex-start;\n    align-content: space-around;\n}\n.container .item {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 5px;\n    width: 50px;\n    height: 50px;\n    background-color: rgba(0, 0, 255, 0.315)\n}\n.container .item:nth-of-type(1) {\n    flex-grow: 7;\n    width: 100px;\n    height: 100px;\n}\n.container .item:nth-of-type(2) {\n    flex-shrink: 0;\n    /*flex-shrink为0时，即使空间不够，也不缩小*/\n    width: 100px;\n    height: 100px;\n}\n.container .item:nth-of-type(3) {\n    /* order: 1; */\n    flex-basis: 200px;\n    width: 200px;\n    height: 60px;\n}\n.container .item:nth-of-type(4) {\n    width: 30px;\n    height: 30px;\n}\n.container .item:nth-of-type(5) {\n    width: 70px;\n    height: 70px;\n}\n```\n\n### 五、flex运用实例\n1. 如何使用flex布局绘制筛子的6个面？\n\n\n2. 网格布局\n\n3. 圣杯布局\n\n4. 输入框组件的布局\n\n5. 悬挂式布局\n\n6. 固定的底栏\n\n7. 流式布局\n\n未完待续...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n原文：阮老师的博客\n- http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$\n- http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\n","slug":"flex布局从入门到运用","published":1,"updated":"2018-05-12T11:58:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3k000aka0tzje8ocis","content":"<figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"><br></figure>\n\n<p>本文包括了Flex布局的语法介绍，以及几种运用Flex布局实现的实例，涵盖了常见的使用场景。</p>\n<h3 id=\"一、Flex-布局是什么？\"><a href=\"#一、Flex-布局是什么？\" class=\"headerlink\" title=\"一、Flex 布局是什么？\"></a>一、Flex 布局是什么？</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>行内元素也可以使用 Flex 布局。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Webkit 内核的浏览器，必须加上-webkit前缀。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex; <span class=\"comment\">/* Safari */</span></span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：<strong>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</strong>。</p>\n<h3 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"><br>容器默认存在两根轴，水平的叫做 <strong>主轴</strong>(main axis),垂直的叫做 <strong>交叉轴</strong>(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<h3 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h3><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">1</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">2</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">3</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以下6个属性设置在容器上<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">flex-direction</span></span><br><span class=\"line\"><span class=\"attribute\">flex-wrap</span></span><br><span class=\"line\"><span class=\"attribute\">flex-flow</span></span><br><span class=\"line\"><span class=\"attribute\">justify-content</span></span><br><span class=\"line\"><span class=\"attribute\">align-items</span></span><br><span class=\"line\"><span class=\"attribute\">align-content</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\"><a href=\"#1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\" class=\"headerlink\" title=\"1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\"></a>1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>row(默认值)：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h4 id=\"2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\"><a href=\"#2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\" class=\"headerlink\" title=\"2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\"></a>2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>nowrap（默认）：不换行。</li>\n<li>wrap：换行，第一行在上方。</li>\n<li>wrap-reverse：换行，第一行在下方。</li>\n</ul>\n<h4 id=\"3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap\"><a href=\"#3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap\" class=\"headerlink\" title=\"3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\"></a>3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-justify-content属性，定义了项目在-主轴-上的对齐方式\"><a href=\"#4-justify-content属性，定义了项目在-主轴-上的对齐方式\" class=\"headerlink\" title=\"4.justify-content属性，定义了项目在 主轴 上的对齐方式\"></a>4.justify-content属性，定义了项目在 <strong>主轴</strong> 上的对齐方式</h4><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">  justify-content: flex-start | flex-<span class=\"keyword\">end</span> | center | <span class=\"literal\">space</span>-<span class=\"keyword\">between</span> | <span class=\"literal\">space</span>-<span class=\"keyword\">around</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>\n</ul>\n<h4 id=\"5-align-items属性-定义项目在-交叉轴-上如何对齐\"><a href=\"#5-align-items属性-定义项目在-交叉轴-上如何对齐\" class=\"headerlink\" title=\"5.align-items属性,定义项目在 交叉轴 上如何对齐\"></a>5.align-items属性,定义项目在 <strong>交叉轴</strong> 上如何对齐</h4><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">  align-items: flex-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">baseline</span> | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<h4 id=\"6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\"><a href=\"#6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\" class=\"headerlink\" title=\"6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\"></a>6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</h4><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  align-content: flex-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">space</span>-between | <span class=\"type\">space</span>-around | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h4 id=\"1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"><a href=\"#1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\" class=\"headerlink\" title=\"1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"></a>1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\"><a href=\"#2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\" class=\"headerlink\" title=\"2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\"></a>2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h4 id=\"3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\"><a href=\"#3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\" class=\"headerlink\" title=\"3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\"></a>3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<h4 id=\"4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）\"><a href=\"#4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）\" class=\"headerlink\" title=\"4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）\"></a>4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）</h4><p>浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-basis</span>: &lt;length&gt; | auto; <span class=\"comment\">/* default auto */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>\n<h4 id=\"5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。\"><a href=\"#5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。\" class=\"headerlink\" title=\"5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\"></a>5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt; &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h4 id=\"6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式\"><a href=\"#6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式\" class=\"headerlink\" title=\"6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.\"></a>6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.</h4><p>可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch<br><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  align-self: <span class=\"built_in\">auto</span> | <span class=\"type\">flex</span>-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">baseline</span> | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>\n<p>flex布局练习代码：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flexDemo.jpg\" alt=\"\"><br>HTML:<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">1</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">2</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">3</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">4</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">5</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">6</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">7</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">8</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">9</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">10</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">11</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* height: 400px; */</span></span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blanchedalmond;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-flow</span>: row wrap;</span><br><span class=\"line\">    <span class=\"comment\">/* 默认 */</span></span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: flex-start;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: flex-start;</span><br><span class=\"line\">    <span class=\"attribute\">align-content</span>: space-around;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgba</span>(0, 0, 255, 0.315)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(1)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex-grow</span>: <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(2)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex-shrink</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*flex-shrink为0时，即使空间不够，也不缩小*/</span></span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(3)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* order: 1; */</span></span><br><span class=\"line\">    <span class=\"attribute\">flex-basis</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(4)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(5)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、flex运用实例\"><a href=\"#五、flex运用实例\" class=\"headerlink\" title=\"五、flex运用实例\"></a>五、flex运用实例</h3><ol>\n<li>如何使用flex布局绘制筛子的6个面？</li>\n</ol>\n<ol start=\"2\">\n<li><p>网格布局</p>\n</li>\n<li><p>圣杯布局</p>\n</li>\n<li><p>输入框组件的布局</p>\n</li>\n<li><p>悬挂式布局</p>\n</li>\n<li><p>固定的底栏</p>\n</li>\n<li><p>流式布局</p>\n</li>\n</ol>\n<p>未完待续…</p>\n<p>原文：阮老师的博客</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"><br></figure>\n\n<p>本文包括了Flex布局的语法介绍，以及几种运用Flex布局实现的实例，涵盖了常见的使用场景。</p>\n<h3 id=\"一、Flex-布局是什么？\"><a href=\"#一、Flex-布局是什么？\" class=\"headerlink\" title=\"一、Flex 布局是什么？\"></a>一、Flex 布局是什么？</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>行内元素也可以使用 Flex 布局。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Webkit 内核的浏览器，必须加上-webkit前缀。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex; <span class=\"comment\">/* Safari */</span></span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：<strong>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</strong>。</p>\n<h3 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"><br>容器默认存在两根轴，水平的叫做 <strong>主轴</strong>(main axis),垂直的叫做 <strong>交叉轴</strong>(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<h3 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h3><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">1</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">2</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">3</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以下6个属性设置在容器上<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">flex-direction</span></span><br><span class=\"line\"><span class=\"attribute\">flex-wrap</span></span><br><span class=\"line\"><span class=\"attribute\">flex-flow</span></span><br><span class=\"line\"><span class=\"attribute\">justify-content</span></span><br><span class=\"line\"><span class=\"attribute\">align-items</span></span><br><span class=\"line\"><span class=\"attribute\">align-content</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\"><a href=\"#1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\" class=\"headerlink\" title=\"1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\"></a>1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>row(默认值)：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h4 id=\"2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\"><a href=\"#2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\" class=\"headerlink\" title=\"2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\"></a>2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>nowrap（默认）：不换行。</li>\n<li>wrap：换行，第一行在上方。</li>\n<li>wrap-reverse：换行，第一行在下方。</li>\n</ul>\n<h4 id=\"3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap\"><a href=\"#3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap\" class=\"headerlink\" title=\"3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\"></a>3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-justify-content属性，定义了项目在-主轴-上的对齐方式\"><a href=\"#4-justify-content属性，定义了项目在-主轴-上的对齐方式\" class=\"headerlink\" title=\"4.justify-content属性，定义了项目在 主轴 上的对齐方式\"></a>4.justify-content属性，定义了项目在 <strong>主轴</strong> 上的对齐方式</h4><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">  justify-content: flex-start | flex-<span class=\"keyword\">end</span> | center | <span class=\"literal\">space</span>-<span class=\"keyword\">between</span> | <span class=\"literal\">space</span>-<span class=\"keyword\">around</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>\n</ul>\n<h4 id=\"5-align-items属性-定义项目在-交叉轴-上如何对齐\"><a href=\"#5-align-items属性-定义项目在-交叉轴-上如何对齐\" class=\"headerlink\" title=\"5.align-items属性,定义项目在 交叉轴 上如何对齐\"></a>5.align-items属性,定义项目在 <strong>交叉轴</strong> 上如何对齐</h4><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">  align-items: flex-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">baseline</span> | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<h4 id=\"6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\"><a href=\"#6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\" class=\"headerlink\" title=\"6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\"></a>6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</h4><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  align-content: flex-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">space</span>-between | <span class=\"type\">space</span>-around | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h4 id=\"1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"><a href=\"#1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\" class=\"headerlink\" title=\"1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"></a>1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\"><a href=\"#2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\" class=\"headerlink\" title=\"2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\"></a>2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h4 id=\"3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\"><a href=\"#3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\" class=\"headerlink\" title=\"3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\"></a>3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<h4 id=\"4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）\"><a href=\"#4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）\" class=\"headerlink\" title=\"4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）\"></a>4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）</h4><p>浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-basis</span>: &lt;length&gt; | auto; <span class=\"comment\">/* default auto */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>\n<h4 id=\"5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。\"><a href=\"#5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。\" class=\"headerlink\" title=\"5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\"></a>5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt; &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h4 id=\"6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式\"><a href=\"#6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式\" class=\"headerlink\" title=\"6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.\"></a>6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.</h4><p>可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch<br><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  align-self: <span class=\"built_in\">auto</span> | <span class=\"type\">flex</span>-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">baseline</span> | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>\n<p>flex布局练习代码：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flexDemo.jpg\" alt=\"\"><br>HTML:<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">1</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">2</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">3</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">4</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">5</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">6</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">7</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">8</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">9</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">10</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">11</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* height: 400px; */</span></span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blanchedalmond;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-flow</span>: row wrap;</span><br><span class=\"line\">    <span class=\"comment\">/* 默认 */</span></span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: flex-start;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: flex-start;</span><br><span class=\"line\">    <span class=\"attribute\">align-content</span>: space-around;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgba</span>(0, 0, 255, 0.315)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(1)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex-grow</span>: <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(2)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex-shrink</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*flex-shrink为0时，即使空间不够，也不缩小*/</span></span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(3)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* order: 1; */</span></span><br><span class=\"line\">    <span class=\"attribute\">flex-basis</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(4)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(5)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、flex运用实例\"><a href=\"#五、flex运用实例\" class=\"headerlink\" title=\"五、flex运用实例\"></a>五、flex运用实例</h3><ol>\n<li>如何使用flex布局绘制筛子的6个面？</li>\n</ol>\n<ol start=\"2\">\n<li><p>网格布局</p>\n</li>\n<li><p>圣杯布局</p>\n</li>\n<li><p>输入框组件的布局</p>\n</li>\n<li><p>悬挂式布局</p>\n</li>\n<li><p>固定的底栏</p>\n</li>\n<li><p>流式布局</p>\n</li>\n</ol>\n<p>未完待续…</p>\n<p>原文：阮老师的博客</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li>\n</ul>\n"},{"title":"React进阶之 使用mobx进行状态管理","date":"2018-06-10T16:00:00.000Z","toc":true,"_content":"\n### 参考资料\n\n- [mobx中文文档](http://cn.mobx.js.org/)\n\n- [mobx todolist](https://codesandbox.io/s/2vmzpM0wK)\n\n- [mobx 在ReactJS项目中的运用](https://blog.csdn.net/u012125579/article/details/69400169)\n\n<!--more-->\n\n### 入门\n任何源自应用状态的东西都应该自动地获得。\n\n#### 与react的关系\nreact提供了优化UI渲染的机制，这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。mobx提供了优化应用状态与react组件同步的机制，这种机制就是使用响应式虚拟依赖状态图标，它只有在真正需要的时候才更新并且永远保持是最新的。\n\n#### 核心概念\n##### Observable state（可观察的状态）\n\n 通过使用@observable装饰器来给现有的数据结构（如对象、数组和类实例）添加可观察的功能。\n 注：@observable是es.next的写法，在es5中，使用extendObservable()来实现。\n\n##### Computed values（计算值）\n\n 定义在相关数据发生变化时自动更新的值，可通过@computed 装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用。\n\n##### Reactions（反应）\n- reactions在响应式编程和命令式编程之间建立沟通的桥梁。\n\n- reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新react组件数以修补dom等。\n\n- observer()会将组件转换为它们需要渲染的数据的衍生。\n  import {observer} from 'mobx-react'\n- 自定义reactions：\n  使用autorun、reaction、when函数即可简单的创建自定义reactions，用来满足具体场景。\n##### Actions(动作)\n- 状态应该以某种状态来更新。\n\n#### mobx会对什么作出响应？\n\n会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应。\n\n#### mobx的优点：（简单且可扩展）\n\nA.使用类和真正的引用 B.保证参照完整性 C.更简单的actions更便于维护 D.细粒度的可观测性是高效的 E.易操作性\n\n#### mobx要点 将一个应用变成响应式的步骤\n(1)定义状态并使其可观察\n```\nimport {observable} from 'mobx';\nvar appState = observable({ timer: 0 })\n```\n\n(2)创建视图以响应状态的变化\n```\nimport {observer} from 'mobx-react';\n\n @observer class TimerView extends React.Component{\n    render(){\n      return (\n        Seconds passed: {this.props.appState.timer}\n        )\n    }\n\n     onReset(){\n         this.props.appState.resetTimer();\n     }\n }\n\n ReactDOM.render(<TimerView appState={appState} />,document.body);\n ```\n(3)更新状态（mobx帮助你以一种简单直观的方式来完成工作） appState.resetTimer = action(function reset(){ appState.timer = 0; })\n```\n setInterval(action(function tick(){\n     appState.timer += 1;\n ),1000)\n ```\n#### 概念\n\n1. State(状态)\n\n 状态是驱动应用的数据。\n2. Dervations(衍生)\n\n- 任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。\n- 衍生的存在形式：用户界面、衍生数据、后端集成\n- mobx区分了两种类型的衍生：Computed values 和 Reactions\n- 黄金法则：如果想创建一个基于当前状态的值时，使用computed\n3. Actions(动作)\n\n 动作是任一一段可以改变状态的代码。\n#### 原则\n\n- mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。\n\n Action -> State -> Views\n- 当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。\n\n- 所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。\n\n- 计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么他会自动被垃圾回收。\n\n- 所有的计算值都应该是纯净的。它们不应该用来改变状态。\n\n### 实际开发中遇到的问题及解决过程\n\n1.  @observable 数组\n\n A.将数组变成可观察的对象时，map、forEach、indexOf、find等原生数组可用的方法，仍可以使用。\n\n B.在控制台打印这个数组时，已经变成了ObservableArray,并不是Array对象了。\n\n C.可以使用xxx.slice()将其变成原生数组。\n\n原文：\n1. [JS 装饰器（Decorator）场景实战](https://juejin.im/post/59f1c484f265da431c6f8940)\n2. [王老师的积累](https://github.com/wang-qingqing/accumulate/blob/f5779c2a734420200a34531d2ad7bdcfd91bd0ec/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EMobx.md)\n3. [MOBX中文文档](https://gismanli.github.io/MobX-ZH/intro/overview.html)\n","source":"_posts/React进阶之 使用mobx进行状态管理.md","raw":"title: React进阶之 使用mobx进行状态管理\ndate: 2018/06/11\ncategories: 库/框架\ntoc: true\ntags:\n  - React\n---\n\n### 参考资料\n\n- [mobx中文文档](http://cn.mobx.js.org/)\n\n- [mobx todolist](https://codesandbox.io/s/2vmzpM0wK)\n\n- [mobx 在ReactJS项目中的运用](https://blog.csdn.net/u012125579/article/details/69400169)\n\n<!--more-->\n\n### 入门\n任何源自应用状态的东西都应该自动地获得。\n\n#### 与react的关系\nreact提供了优化UI渲染的机制，这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。mobx提供了优化应用状态与react组件同步的机制，这种机制就是使用响应式虚拟依赖状态图标，它只有在真正需要的时候才更新并且永远保持是最新的。\n\n#### 核心概念\n##### Observable state（可观察的状态）\n\n 通过使用@observable装饰器来给现有的数据结构（如对象、数组和类实例）添加可观察的功能。\n 注：@observable是es.next的写法，在es5中，使用extendObservable()来实现。\n\n##### Computed values（计算值）\n\n 定义在相关数据发生变化时自动更新的值，可通过@computed 装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用。\n\n##### Reactions（反应）\n- reactions在响应式编程和命令式编程之间建立沟通的桥梁。\n\n- reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新react组件数以修补dom等。\n\n- observer()会将组件转换为它们需要渲染的数据的衍生。\n  import {observer} from 'mobx-react'\n- 自定义reactions：\n  使用autorun、reaction、when函数即可简单的创建自定义reactions，用来满足具体场景。\n##### Actions(动作)\n- 状态应该以某种状态来更新。\n\n#### mobx会对什么作出响应？\n\n会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应。\n\n#### mobx的优点：（简单且可扩展）\n\nA.使用类和真正的引用 B.保证参照完整性 C.更简单的actions更便于维护 D.细粒度的可观测性是高效的 E.易操作性\n\n#### mobx要点 将一个应用变成响应式的步骤\n(1)定义状态并使其可观察\n```\nimport {observable} from 'mobx';\nvar appState = observable({ timer: 0 })\n```\n\n(2)创建视图以响应状态的变化\n```\nimport {observer} from 'mobx-react';\n\n @observer class TimerView extends React.Component{\n    render(){\n      return (\n        Seconds passed: {this.props.appState.timer}\n        )\n    }\n\n     onReset(){\n         this.props.appState.resetTimer();\n     }\n }\n\n ReactDOM.render(<TimerView appState={appState} />,document.body);\n ```\n(3)更新状态（mobx帮助你以一种简单直观的方式来完成工作） appState.resetTimer = action(function reset(){ appState.timer = 0; })\n```\n setInterval(action(function tick(){\n     appState.timer += 1;\n ),1000)\n ```\n#### 概念\n\n1. State(状态)\n\n 状态是驱动应用的数据。\n2. Dervations(衍生)\n\n- 任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。\n- 衍生的存在形式：用户界面、衍生数据、后端集成\n- mobx区分了两种类型的衍生：Computed values 和 Reactions\n- 黄金法则：如果想创建一个基于当前状态的值时，使用computed\n3. Actions(动作)\n\n 动作是任一一段可以改变状态的代码。\n#### 原则\n\n- mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。\n\n Action -> State -> Views\n- 当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。\n\n- 所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。\n\n- 计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么他会自动被垃圾回收。\n\n- 所有的计算值都应该是纯净的。它们不应该用来改变状态。\n\n### 实际开发中遇到的问题及解决过程\n\n1.  @observable 数组\n\n A.将数组变成可观察的对象时，map、forEach、indexOf、find等原生数组可用的方法，仍可以使用。\n\n B.在控制台打印这个数组时，已经变成了ObservableArray,并不是Array对象了。\n\n C.可以使用xxx.slice()将其变成原生数组。\n\n原文：\n1. [JS 装饰器（Decorator）场景实战](https://juejin.im/post/59f1c484f265da431c6f8940)\n2. [王老师的积累](https://github.com/wang-qingqing/accumulate/blob/f5779c2a734420200a34531d2ad7bdcfd91bd0ec/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EMobx.md)\n3. [MOBX中文文档](https://gismanli.github.io/MobX-ZH/intro/overview.html)\n","slug":"React进阶之 使用mobx进行状态管理","published":1,"updated":"2018-06-15T02:12:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3m000bka0tg2xwquzo","content":"<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><p><a href=\"http://cn.mobx.js.org/\" target=\"_blank\" rel=\"noopener\">mobx中文文档</a></p>\n</li>\n<li><p><a href=\"https://codesandbox.io/s/2vmzpM0wK\" target=\"_blank\" rel=\"noopener\">mobx todolist</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u012125579/article/details/69400169\" target=\"_blank\" rel=\"noopener\">mobx 在ReactJS项目中的运用</a></p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h3><p>任何源自应用状态的东西都应该自动地获得。</p>\n<h4 id=\"与react的关系\"><a href=\"#与react的关系\" class=\"headerlink\" title=\"与react的关系\"></a>与react的关系</h4><p>react提供了优化UI渲染的机制，这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。mobx提供了优化应用状态与react组件同步的机制，这种机制就是使用响应式虚拟依赖状态图标，它只有在真正需要的时候才更新并且永远保持是最新的。</p>\n<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><h5 id=\"Observable-state（可观察的状态）\"><a href=\"#Observable-state（可观察的状态）\" class=\"headerlink\" title=\"Observable state（可观察的状态）\"></a>Observable state（可观察的状态）</h5><p> 通过使用@observable装饰器来给现有的数据结构（如对象、数组和类实例）添加可观察的功能。<br> 注：@observable是es.next的写法，在es5中，使用extendObservable()来实现。</p>\n<h5 id=\"Computed-values（计算值）\"><a href=\"#Computed-values（计算值）\" class=\"headerlink\" title=\"Computed values（计算值）\"></a>Computed values（计算值）</h5><p> 定义在相关数据发生变化时自动更新的值，可通过@computed 装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用。</p>\n<h5 id=\"Reactions（反应）\"><a href=\"#Reactions（反应）\" class=\"headerlink\" title=\"Reactions（反应）\"></a>Reactions（反应）</h5><ul>\n<li><p>reactions在响应式编程和命令式编程之间建立沟通的桥梁。</p>\n</li>\n<li><p>reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新react组件数以修补dom等。</p>\n</li>\n<li><p>observer()会将组件转换为它们需要渲染的数据的衍生。<br>import {observer} from ‘mobx-react’</p>\n</li>\n<li>自定义reactions：<br>使用autorun、reaction、when函数即可简单的创建自定义reactions，用来满足具体场景。<h5 id=\"Actions-动作\"><a href=\"#Actions-动作\" class=\"headerlink\" title=\"Actions(动作)\"></a>Actions(动作)</h5></li>\n<li>状态应该以某种状态来更新。</li>\n</ul>\n<h4 id=\"mobx会对什么作出响应？\"><a href=\"#mobx会对什么作出响应？\" class=\"headerlink\" title=\"mobx会对什么作出响应？\"></a>mobx会对什么作出响应？</h4><p>会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应。</p>\n<h4 id=\"mobx的优点：（简单且可扩展）\"><a href=\"#mobx的优点：（简单且可扩展）\" class=\"headerlink\" title=\"mobx的优点：（简单且可扩展）\"></a>mobx的优点：（简单且可扩展）</h4><p>A.使用类和真正的引用 B.保证参照完整性 C.更简单的actions更便于维护 D.细粒度的可观测性是高效的 E.易操作性</p>\n<h4 id=\"mobx要点-将一个应用变成响应式的步骤\"><a href=\"#mobx要点-将一个应用变成响应式的步骤\" class=\"headerlink\" title=\"mobx要点 将一个应用变成响应式的步骤\"></a>mobx要点 将一个应用变成响应式的步骤</h4><p>(1)定义状态并使其可观察<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'mobx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> appState = observable(&#123; <span class=\"attr\">timer</span>: <span class=\"number\">0</span> &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>(2)创建视图以响应状态的变化<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;observer&#125; from <span class=\"symbol\">'mobx</span>-react';</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@observer</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"type\">Seconds</span> passed: &#123;<span class=\"keyword\">this</span>.props.appState.timer&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     onReset()&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.props.appState.resetTimer();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">ReactDOM</span>.render(&lt;<span class=\"type\">TimerView</span> appState=&#123;appState&#125; /&gt;,document.body);</span><br></pre></td></tr></table></figure></p>\n<p>(3)更新状态（mobx帮助你以一种简单直观的方式来完成工作） appState.resetTimer = action(function reset(){ appState.timer = 0; })<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(<span class=\"name\">action</span>(<span class=\"name\">function</span> tick()&#123;</span><br><span class=\"line\">    appState.timer += <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">),<span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ol>\n<li><p>State(状态)</p>\n<p>状态是驱动应用的数据。</p>\n</li>\n<li>Dervations(衍生)</li>\n</ol>\n<ul>\n<li>任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。</li>\n<li>衍生的存在形式：用户界面、衍生数据、后端集成</li>\n<li>mobx区分了两种类型的衍生：Computed values 和 Reactions</li>\n<li>黄金法则：如果想创建一个基于当前状态的值时，使用computed</li>\n</ul>\n<ol start=\"3\">\n<li><p>Actions(动作)</p>\n<p>动作是任一一段可以改变状态的代码。</p>\n<h4 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h4></li>\n</ol>\n<ul>\n<li><p>mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。</p>\n<p>Action -&gt; State -&gt; Views</p>\n</li>\n<li><p>当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。</p>\n</li>\n<li><p>所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。</p>\n</li>\n<li><p>计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么他会自动被垃圾回收。</p>\n</li>\n<li><p>所有的计算值都应该是纯净的。它们不应该用来改变状态。</p>\n</li>\n</ul>\n<h3 id=\"实际开发中遇到的问题及解决过程\"><a href=\"#实际开发中遇到的问题及解决过程\" class=\"headerlink\" title=\"实际开发中遇到的问题及解决过程\"></a>实际开发中遇到的问题及解决过程</h3><ol>\n<li><p>@observable 数组</p>\n<p>A.将数组变成可观察的对象时，map、forEach、indexOf、find等原生数组可用的方法，仍可以使用。</p>\n<p>B.在控制台打印这个数组时，已经变成了ObservableArray,并不是Array对象了。</p>\n<p>C.可以使用xxx.slice()将其变成原生数组。</p>\n</li>\n</ol>\n<p>原文：</p>\n<ol>\n<li><a href=\"https://juejin.im/post/59f1c484f265da431c6f8940\" target=\"_blank\" rel=\"noopener\">JS 装饰器（Decorator）场景实战</a></li>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/f5779c2a734420200a34531d2ad7bdcfd91bd0ec/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EMobx.md\" target=\"_blank\" rel=\"noopener\">王老师的积累</a></li>\n<li><a href=\"https://gismanli.github.io/MobX-ZH/intro/overview.html\" target=\"_blank\" rel=\"noopener\">MOBX中文文档</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><p><a href=\"http://cn.mobx.js.org/\" target=\"_blank\" rel=\"noopener\">mobx中文文档</a></p>\n</li>\n<li><p><a href=\"https://codesandbox.io/s/2vmzpM0wK\" target=\"_blank\" rel=\"noopener\">mobx todolist</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u012125579/article/details/69400169\" target=\"_blank\" rel=\"noopener\">mobx 在ReactJS项目中的运用</a></p>\n</li>\n</ul>","more":"<h3 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h3><p>任何源自应用状态的东西都应该自动地获得。</p>\n<h4 id=\"与react的关系\"><a href=\"#与react的关系\" class=\"headerlink\" title=\"与react的关系\"></a>与react的关系</h4><p>react提供了优化UI渲染的机制，这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。mobx提供了优化应用状态与react组件同步的机制，这种机制就是使用响应式虚拟依赖状态图标，它只有在真正需要的时候才更新并且永远保持是最新的。</p>\n<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><h5 id=\"Observable-state（可观察的状态）\"><a href=\"#Observable-state（可观察的状态）\" class=\"headerlink\" title=\"Observable state（可观察的状态）\"></a>Observable state（可观察的状态）</h5><p> 通过使用@observable装饰器来给现有的数据结构（如对象、数组和类实例）添加可观察的功能。<br> 注：@observable是es.next的写法，在es5中，使用extendObservable()来实现。</p>\n<h5 id=\"Computed-values（计算值）\"><a href=\"#Computed-values（计算值）\" class=\"headerlink\" title=\"Computed values（计算值）\"></a>Computed values（计算值）</h5><p> 定义在相关数据发生变化时自动更新的值，可通过@computed 装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用。</p>\n<h5 id=\"Reactions（反应）\"><a href=\"#Reactions（反应）\" class=\"headerlink\" title=\"Reactions（反应）\"></a>Reactions（反应）</h5><ul>\n<li><p>reactions在响应式编程和命令式编程之间建立沟通的桥梁。</p>\n</li>\n<li><p>reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新react组件数以修补dom等。</p>\n</li>\n<li><p>observer()会将组件转换为它们需要渲染的数据的衍生。<br>import {observer} from ‘mobx-react’</p>\n</li>\n<li>自定义reactions：<br>使用autorun、reaction、when函数即可简单的创建自定义reactions，用来满足具体场景。<h5 id=\"Actions-动作\"><a href=\"#Actions-动作\" class=\"headerlink\" title=\"Actions(动作)\"></a>Actions(动作)</h5></li>\n<li>状态应该以某种状态来更新。</li>\n</ul>\n<h4 id=\"mobx会对什么作出响应？\"><a href=\"#mobx会对什么作出响应？\" class=\"headerlink\" title=\"mobx会对什么作出响应？\"></a>mobx会对什么作出响应？</h4><p>会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应。</p>\n<h4 id=\"mobx的优点：（简单且可扩展）\"><a href=\"#mobx的优点：（简单且可扩展）\" class=\"headerlink\" title=\"mobx的优点：（简单且可扩展）\"></a>mobx的优点：（简单且可扩展）</h4><p>A.使用类和真正的引用 B.保证参照完整性 C.更简单的actions更便于维护 D.细粒度的可观测性是高效的 E.易操作性</p>\n<h4 id=\"mobx要点-将一个应用变成响应式的步骤\"><a href=\"#mobx要点-将一个应用变成响应式的步骤\" class=\"headerlink\" title=\"mobx要点 将一个应用变成响应式的步骤\"></a>mobx要点 将一个应用变成响应式的步骤</h4><p>(1)定义状态并使其可观察<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'mobx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> appState = observable(&#123; <span class=\"attr\">timer</span>: <span class=\"number\">0</span> &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>(2)创建视图以响应状态的变化<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;observer&#125; from <span class=\"symbol\">'mobx</span>-react';</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@observer</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"type\">Seconds</span> passed: &#123;<span class=\"keyword\">this</span>.props.appState.timer&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     onReset()&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.props.appState.resetTimer();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">ReactDOM</span>.render(&lt;<span class=\"type\">TimerView</span> appState=&#123;appState&#125; /&gt;,document.body);</span><br></pre></td></tr></table></figure></p>\n<p>(3)更新状态（mobx帮助你以一种简单直观的方式来完成工作） appState.resetTimer = action(function reset(){ appState.timer = 0; })<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(<span class=\"name\">action</span>(<span class=\"name\">function</span> tick()&#123;</span><br><span class=\"line\">    appState.timer += <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">),<span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ol>\n<li><p>State(状态)</p>\n<p>状态是驱动应用的数据。</p>\n</li>\n<li>Dervations(衍生)</li>\n</ol>\n<ul>\n<li>任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。</li>\n<li>衍生的存在形式：用户界面、衍生数据、后端集成</li>\n<li>mobx区分了两种类型的衍生：Computed values 和 Reactions</li>\n<li>黄金法则：如果想创建一个基于当前状态的值时，使用computed</li>\n</ul>\n<ol start=\"3\">\n<li><p>Actions(动作)</p>\n<p>动作是任一一段可以改变状态的代码。</p>\n<h4 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h4></li>\n</ol>\n<ul>\n<li><p>mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。</p>\n<p>Action -&gt; State -&gt; Views</p>\n</li>\n<li><p>当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。</p>\n</li>\n<li><p>所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。</p>\n</li>\n<li><p>计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么他会自动被垃圾回收。</p>\n</li>\n<li><p>所有的计算值都应该是纯净的。它们不应该用来改变状态。</p>\n</li>\n</ul>\n<h3 id=\"实际开发中遇到的问题及解决过程\"><a href=\"#实际开发中遇到的问题及解决过程\" class=\"headerlink\" title=\"实际开发中遇到的问题及解决过程\"></a>实际开发中遇到的问题及解决过程</h3><ol>\n<li><p>@observable 数组</p>\n<p>A.将数组变成可观察的对象时，map、forEach、indexOf、find等原生数组可用的方法，仍可以使用。</p>\n<p>B.在控制台打印这个数组时，已经变成了ObservableArray,并不是Array对象了。</p>\n<p>C.可以使用xxx.slice()将其变成原生数组。</p>\n</li>\n</ol>\n<p>原文：</p>\n<ol>\n<li><a href=\"https://juejin.im/post/59f1c484f265da431c6f8940\" target=\"_blank\" rel=\"noopener\">JS 装饰器（Decorator）场景实战</a></li>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/f5779c2a734420200a34531d2ad7bdcfd91bd0ec/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EMobx.md\" target=\"_blank\" rel=\"noopener\">王老师的积累</a></li>\n<li><a href=\"https://gismanli.github.io/MobX-ZH/intro/overview.html\" target=\"_blank\" rel=\"noopener\">MOBX中文文档</a></li>\n</ol>"},{"title":"axios常用攻略","date":"2018-06-13T16:00:00.000Z","toc":true,"_content":"\n\n\n### 安装\nnpm install axios\n\n**axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。**\n\n<!--more-->\n\n### 常见用法\n\n1. 执行get请求\n\n```\n        // 向具有指定ID的用户发出请求\n        axios.get('/user?ID=12345')\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n\n\n\n        // 也可以通过 params 对象传递参数\n        axios.get('/user', {\n            params: {\n            ID: 12345\n            }\n        })\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n```\n\n2. 执行post请求\n\n```\n    axios.post('/user', {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    })\n    .then(function (response) {\n        console.log(response);\n    })\n    .catch(function (error) {\n        console.log(error);\n    });\n```\n\n3. 执行多个并发请求\n\n```\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    //两个请求现已完成\n  }));\n```\n\n\n更多可参考：\nhttps://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/\n","source":"_posts/axios常用攻略.md","raw":"title: axios常用攻略\ndate: 2018/06/14\ncategories: 库/框架\ntags:\n  - axios\ntoc: true\n---\n\n\n\n### 安装\nnpm install axios\n\n**axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。**\n\n<!--more-->\n\n### 常见用法\n\n1. 执行get请求\n\n```\n        // 向具有指定ID的用户发出请求\n        axios.get('/user?ID=12345')\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n\n\n\n        // 也可以通过 params 对象传递参数\n        axios.get('/user', {\n            params: {\n            ID: 12345\n            }\n        })\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n```\n\n2. 执行post请求\n\n```\n    axios.post('/user', {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    })\n    .then(function (response) {\n        console.log(response);\n    })\n    .catch(function (error) {\n        console.log(error);\n    });\n```\n\n3. 执行多个并发请求\n\n```\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    //两个请求现已完成\n  }));\n```\n\n\n更多可参考：\nhttps://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/\n","slug":"axios常用攻略","published":1,"updated":"2018-06-14T15:04:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3n000cka0t7qbgqva2","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>npm install axios</p>\n<p><strong>axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。</strong></p>\n<a id=\"more\"></a>\n<h3 id=\"常见用法\"><a href=\"#常见用法\" class=\"headerlink\" title=\"常见用法\"></a>常见用法</h3><ol>\n<li>执行get请求</li>\n</ol>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向具有指定ID的用户发出请求</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以通过 params 对象传递参数</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">    ID: <span class=\"number\">12345</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>执行post请求</li>\n</ol>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>执行多个并发请求</li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAccount</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">axios.get('/user/12345')</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">axios.get('/user/12345/permissions')</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.<span class=\"keyword\">all</span>([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(axios.spread(<span class=\"keyword\">function</span> <span class=\"title\"></span>(acct, perms) &#123;</span><br><span class=\"line\">    //两个请求现已完成</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure>\n<p>更多可参考：<br><a href=\"https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/\" target=\"_blank\" rel=\"noopener\">https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>npm install axios</p>\n<p><strong>axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。</strong></p>","more":"<h3 id=\"常见用法\"><a href=\"#常见用法\" class=\"headerlink\" title=\"常见用法\"></a>常见用法</h3><ol>\n<li>执行get请求</li>\n</ol>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向具有指定ID的用户发出请求</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以通过 params 对象传递参数</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">    ID: <span class=\"number\">12345</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>执行post请求</li>\n</ol>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>执行多个并发请求</li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAccount</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">axios.get('/user/12345')</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">axios.get('/user/12345/permissions')</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.<span class=\"keyword\">all</span>([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(axios.spread(<span class=\"keyword\">function</span> <span class=\"title\"></span>(acct, perms) &#123;</span><br><span class=\"line\">    //两个请求现已完成</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure>\n<p>更多可参考：<br><a href=\"https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/\" target=\"_blank\" rel=\"noopener\">https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/</a></p>"},{"title":"git常用基本命令","date":"2018-04-16T16:00:00.000Z","_content":"\n### 必须记住的六条命令\n1. cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。\n2. git status .：查看当前路径下的的状态。git下最最常用的一个命令。\n3. git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。\n4. git commit -m \"提交时说明信息\": 更进一步提交，并说明提交log。\n5. git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)\n6. git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)\n<!--more-->\n### 当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\n1. 建立git仓库\ncd到你的本地项目根目录下，执行git命令，此命令会在当前目录下创建一个.git文件夹。\ngit init\n\n2. 将项目的所有文件添加到仓库中\ngit add .\n这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可\n\n3. 将add的文件commit到仓库\ngit commit -m \"注释语句\"\n\n4. 去github上创建自己的Repository，点击NewRepository。\n点击Create repository，拿到创建的仓库的https地址\n\n5. 将本地的仓库关联到github上\ngit remote add origin https://自己的仓库url地址\n\n6. 上传代码到github远程仓库\ngit push -u origin master\n\n7. 执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了.\n\n### git如何全局设置用户名及邮箱：\ngit config user.name \"Your Name\"\ngit config user.email you@example.com\n\n### 当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:\n1. git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可）\n2. git commit -m \"提交时说明信息\"\n3. git push\n4. 当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull\n\n### 这三条命令建议记住\n1. git log:查看提交历史，与各次的提交说明。\n2. git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。\n3. git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。\n\n### 其他问题\n- 操作时 双击tab键的自动提示/补全功能。\n- q或者:q等命令代表退出(quit)。\n- ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页\n\n# 正文部分\n\n## 理解几个概念\n工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.\n\n*服务器*:概念已经清楚了。叫做 中央服务器/远程服务器都行。\n*工作区*:就是你电脑的工作目录\n*版本库*:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。\n\n## 为什么存在一个 版本库？\n我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。\n\n## .gitignore文件是干啥的?\n工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。\n\n## .gitignore文件的使用\n```\n1）/mtk/               过滤整个文件夹\n2）*.zip                过滤所有.zip文件\n3）/mtk/do.c         过滤某个具体文件\n```\n被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。\n需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：\n```\n1）!*.zip\n2）!/mtk/one.txt\n```\n唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。\n为什么要有两种规则呢？想象一个场景： **假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理** ，那么我们就需要使用：\n```\n1）/mtk/\n2）!/mtk/one.txt\n```\n假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！\n\n配置语法：\n以斜杠“/”开头表示目录；\n以星号通配多个字符；\n以问号“?”通配单个字符\n以方括号“[]”包含单个字符的匹配列表；\n以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；\n\n### 待补充\ngit config 文件配置项\n\n- 参考：\n- 小白教程：https://www.cnblogs.com/yaoxiaowen/p/8227873.html\n- 秒秒钟入门markdown语法：https://www.jianshu.com/p/q81RER\n- Git忽略规则.gitignore梳理:https://www.cnblogs.com/kevingrace/p/5690241.html\n- 王老师的博客 https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\n- git config https://blog.csdn.net/gaochenchen/article/details/76187480\n","source":"_posts/git常用基本命令.md","raw":"title: git常用基本命令\ndate: 2018/4/17\ncategories: 效率工具\ntags:\n  - git\n---\n\n### 必须记住的六条命令\n1. cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。\n2. git status .：查看当前路径下的的状态。git下最最常用的一个命令。\n3. git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。\n4. git commit -m \"提交时说明信息\": 更进一步提交，并说明提交log。\n5. git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)\n6. git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)\n<!--more-->\n### 当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\n1. 建立git仓库\ncd到你的本地项目根目录下，执行git命令，此命令会在当前目录下创建一个.git文件夹。\ngit init\n\n2. 将项目的所有文件添加到仓库中\ngit add .\n这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可\n\n3. 将add的文件commit到仓库\ngit commit -m \"注释语句\"\n\n4. 去github上创建自己的Repository，点击NewRepository。\n点击Create repository，拿到创建的仓库的https地址\n\n5. 将本地的仓库关联到github上\ngit remote add origin https://自己的仓库url地址\n\n6. 上传代码到github远程仓库\ngit push -u origin master\n\n7. 执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了.\n\n### git如何全局设置用户名及邮箱：\ngit config user.name \"Your Name\"\ngit config user.email you@example.com\n\n### 当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:\n1. git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可）\n2. git commit -m \"提交时说明信息\"\n3. git push\n4. 当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull\n\n### 这三条命令建议记住\n1. git log:查看提交历史，与各次的提交说明。\n2. git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。\n3. git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。\n\n### 其他问题\n- 操作时 双击tab键的自动提示/补全功能。\n- q或者:q等命令代表退出(quit)。\n- ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页\n\n# 正文部分\n\n## 理解几个概念\n工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.\n\n*服务器*:概念已经清楚了。叫做 中央服务器/远程服务器都行。\n*工作区*:就是你电脑的工作目录\n*版本库*:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。\n\n## 为什么存在一个 版本库？\n我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。\n\n## .gitignore文件是干啥的?\n工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。\n\n## .gitignore文件的使用\n```\n1）/mtk/               过滤整个文件夹\n2）*.zip                过滤所有.zip文件\n3）/mtk/do.c         过滤某个具体文件\n```\n被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。\n需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：\n```\n1）!*.zip\n2）!/mtk/one.txt\n```\n唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。\n为什么要有两种规则呢？想象一个场景： **假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理** ，那么我们就需要使用：\n```\n1）/mtk/\n2）!/mtk/one.txt\n```\n假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！\n\n配置语法：\n以斜杠“/”开头表示目录；\n以星号通配多个字符；\n以问号“?”通配单个字符\n以方括号“[]”包含单个字符的匹配列表；\n以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；\n\n### 待补充\ngit config 文件配置项\n\n- 参考：\n- 小白教程：https://www.cnblogs.com/yaoxiaowen/p/8227873.html\n- 秒秒钟入门markdown语法：https://www.jianshu.com/p/q81RER\n- Git忽略规则.gitignore梳理:https://www.cnblogs.com/kevingrace/p/5690241.html\n- 王老师的博客 https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\n- git config https://blog.csdn.net/gaochenchen/article/details/76187480\n","slug":"git常用基本命令","published":1,"updated":"2018-05-26T14:14:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3p000dka0tylv3eqef","content":"<h3 id=\"必须记住的六条命令\"><a href=\"#必须记住的六条命令\" class=\"headerlink\" title=\"必须记住的六条命令\"></a>必须记住的六条命令</h3><ol>\n<li>cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。</li>\n<li>git status .：查看当前路径下的的状态。git下最最常用的一个命令。</li>\n<li>git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。</li>\n<li>git commit -m “提交时说明信息”: 更进一步提交，并说明提交log。</li>\n<li>git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)</li>\n<li>git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)<a id=\"more\"></a>\n<h3 id=\"当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\"><a href=\"#当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\" class=\"headerlink\" title=\"当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\"></a>当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：</h3></li>\n<li><p>建立git仓库<br>cd到你的本地项目根目录下，执行git命令，此命令会在当前目录下创建一个.git文件夹。<br>git init</p>\n</li>\n<li><p>将项目的所有文件添加到仓库中<br>git add .<br>这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可</p>\n</li>\n<li><p>将add的文件commit到仓库<br>git commit -m “注释语句”</p>\n</li>\n<li><p>去github上创建自己的Repository，点击NewRepository。<br>点击Create repository，拿到创建的仓库的https地址</p>\n</li>\n<li><p>将本地的仓库关联到github上<br>git remote add origin https://自己的仓库url地址</p>\n</li>\n<li><p>上传代码到github远程仓库<br>git push -u origin master</p>\n</li>\n<li><p>执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了.</p>\n</li>\n</ol>\n<h3 id=\"git如何全局设置用户名及邮箱：\"><a href=\"#git如何全局设置用户名及邮箱：\" class=\"headerlink\" title=\"git如何全局设置用户名及邮箱：\"></a>git如何全局设置用户名及邮箱：</h3><p>git config user.name “Your Name”<br>git config user.email <a href=\"mailto:you@example.com\" target=\"_blank\" rel=\"noopener\">you@example.com</a></p>\n<h3 id=\"当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下\"><a href=\"#当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下\" class=\"headerlink\" title=\"当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:\"></a>当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:</h3><ol>\n<li>git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可）</li>\n<li>git commit -m “提交时说明信息”</li>\n<li>git push</li>\n<li>当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull</li>\n</ol>\n<h3 id=\"这三条命令建议记住\"><a href=\"#这三条命令建议记住\" class=\"headerlink\" title=\"这三条命令建议记住\"></a>这三条命令建议记住</h3><ol>\n<li>git log:查看提交历史，与各次的提交说明。</li>\n<li>git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。</li>\n<li>git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。</li>\n</ol>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><ul>\n<li>操作时 双击tab键的自动提示/补全功能。</li>\n<li>q或者:q等命令代表退出(quit)。</li>\n<li>ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页</li>\n</ul>\n<h1 id=\"正文部分\"><a href=\"#正文部分\" class=\"headerlink\" title=\"正文部分\"></a>正文部分</h1><h2 id=\"理解几个概念\"><a href=\"#理解几个概念\" class=\"headerlink\" title=\"理解几个概念\"></a>理解几个概念</h2><p>工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.</p>\n<p><em>服务器</em>:概念已经清楚了。叫做 中央服务器/远程服务器都行。<br><em>工作区</em>:就是你电脑的工作目录<br><em>版本库</em>:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。</p>\n<h2 id=\"为什么存在一个-版本库？\"><a href=\"#为什么存在一个-版本库？\" class=\"headerlink\" title=\"为什么存在一个 版本库？\"></a>为什么存在一个 版本库？</h2><p>我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。</p>\n<h2 id=\"gitignore文件是干啥的\"><a href=\"#gitignore文件是干啥的\" class=\"headerlink\" title=\".gitignore文件是干啥的?\"></a>.gitignore文件是干啥的?</h2><p>工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。</p>\n<h2 id=\"gitignore文件的使用\"><a href=\"#gitignore文件的使用\" class=\"headerlink\" title=\".gitignore文件的使用\"></a>.gitignore文件的使用</h2><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）<span class=\"string\">/mtk/</span>               过滤整个文件夹</span><br><span class=\"line\">2）*<span class=\"string\">.zip</span>                过滤所有<span class=\"string\">.zip</span>文件</span><br><span class=\"line\">3）<span class=\"string\">/mtk/do.c</span>         过滤某个具体文件</span><br></pre></td></tr></table></figure>\n<p>被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。<br>需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：<br><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）!*.zip</span><br><span class=\"line\"><span class=\"number\">2</span>）!/mtk/one.txt</span><br></pre></td></tr></table></figure></p>\n<p>唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。<br>为什么要有两种规则呢？想象一个场景： <strong>假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理</strong> ，那么我们就需要使用：<br><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）<span class=\"regexp\">/mtk/</span></span><br><span class=\"line\"><span class=\"number\">2</span>）!<span class=\"regexp\">/mtk/</span>one.txt</span><br></pre></td></tr></table></figure></p>\n<p>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</p>\n<p>配置语法：<br>以斜杠“/”开头表示目录；<br>以星号通配多个字符；<br>以问号“?”通配单个字符<br>以方括号“[]”包含单个字符的匹配列表；<br>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</p>\n<h3 id=\"待补充\"><a href=\"#待补充\" class=\"headerlink\" title=\"待补充\"></a>待补充</h3><p>git config 文件配置项</p>\n<ul>\n<li>参考：</li>\n<li>小白教程：<a href=\"https://www.cnblogs.com/yaoxiaowen/p/8227873.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yaoxiaowen/p/8227873.html</a></li>\n<li>秒秒钟入门markdown语法：<a href=\"https://www.jianshu.com/p/q81RER\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/q81RER</a></li>\n<li>Git忽略规则.gitignore梳理:<a href=\"https://www.cnblogs.com/kevingrace/p/5690241.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kevingrace/p/5690241.html</a></li>\n<li>王老师的博客 <a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\" target=\"_blank\" rel=\"noopener\">https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md</a></li>\n<li>git config <a href=\"https://blog.csdn.net/gaochenchen/article/details/76187480\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gaochenchen/article/details/76187480</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"必须记住的六条命令\"><a href=\"#必须记住的六条命令\" class=\"headerlink\" title=\"必须记住的六条命令\"></a>必须记住的六条命令</h3><ol>\n<li>cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。</li>\n<li>git status .：查看当前路径下的的状态。git下最最常用的一个命令。</li>\n<li>git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。</li>\n<li>git commit -m “提交时说明信息”: 更进一步提交，并说明提交log。</li>\n<li>git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)</li>\n<li>git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)","more":"<h3 id=\"当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\"><a href=\"#当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\" class=\"headerlink\" title=\"当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\"></a>当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：</h3></li>\n<li><p>建立git仓库<br>cd到你的本地项目根目录下，执行git命令，此命令会在当前目录下创建一个.git文件夹。<br>git init</p>\n</li>\n<li><p>将项目的所有文件添加到仓库中<br>git add .<br>这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可</p>\n</li>\n<li><p>将add的文件commit到仓库<br>git commit -m “注释语句”</p>\n</li>\n<li><p>去github上创建自己的Repository，点击NewRepository。<br>点击Create repository，拿到创建的仓库的https地址</p>\n</li>\n<li><p>将本地的仓库关联到github上<br>git remote add origin https://自己的仓库url地址</p>\n</li>\n<li><p>上传代码到github远程仓库<br>git push -u origin master</p>\n</li>\n<li><p>执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了.</p>\n</li>\n</ol>\n<h3 id=\"git如何全局设置用户名及邮箱：\"><a href=\"#git如何全局设置用户名及邮箱：\" class=\"headerlink\" title=\"git如何全局设置用户名及邮箱：\"></a>git如何全局设置用户名及邮箱：</h3><p>git config user.name “Your Name”<br>git config user.email <a href=\"mailto:you@example.com\" target=\"_blank\" rel=\"noopener\">you@example.com</a></p>\n<h3 id=\"当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下\"><a href=\"#当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下\" class=\"headerlink\" title=\"当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:\"></a>当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:</h3><ol>\n<li>git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可）</li>\n<li>git commit -m “提交时说明信息”</li>\n<li>git push</li>\n<li>当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull</li>\n</ol>\n<h3 id=\"这三条命令建议记住\"><a href=\"#这三条命令建议记住\" class=\"headerlink\" title=\"这三条命令建议记住\"></a>这三条命令建议记住</h3><ol>\n<li>git log:查看提交历史，与各次的提交说明。</li>\n<li>git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。</li>\n<li>git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。</li>\n</ol>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><ul>\n<li>操作时 双击tab键的自动提示/补全功能。</li>\n<li>q或者:q等命令代表退出(quit)。</li>\n<li>ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页</li>\n</ul>\n<h1 id=\"正文部分\"><a href=\"#正文部分\" class=\"headerlink\" title=\"正文部分\"></a>正文部分</h1><h2 id=\"理解几个概念\"><a href=\"#理解几个概念\" class=\"headerlink\" title=\"理解几个概念\"></a>理解几个概念</h2><p>工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.</p>\n<p><em>服务器</em>:概念已经清楚了。叫做 中央服务器/远程服务器都行。<br><em>工作区</em>:就是你电脑的工作目录<br><em>版本库</em>:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。</p>\n<h2 id=\"为什么存在一个-版本库？\"><a href=\"#为什么存在一个-版本库？\" class=\"headerlink\" title=\"为什么存在一个 版本库？\"></a>为什么存在一个 版本库？</h2><p>我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。</p>\n<h2 id=\"gitignore文件是干啥的\"><a href=\"#gitignore文件是干啥的\" class=\"headerlink\" title=\".gitignore文件是干啥的?\"></a>.gitignore文件是干啥的?</h2><p>工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。</p>\n<h2 id=\"gitignore文件的使用\"><a href=\"#gitignore文件的使用\" class=\"headerlink\" title=\".gitignore文件的使用\"></a>.gitignore文件的使用</h2><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）<span class=\"string\">/mtk/</span>               过滤整个文件夹</span><br><span class=\"line\">2）*<span class=\"string\">.zip</span>                过滤所有<span class=\"string\">.zip</span>文件</span><br><span class=\"line\">3）<span class=\"string\">/mtk/do.c</span>         过滤某个具体文件</span><br></pre></td></tr></table></figure>\n<p>被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。<br>需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：<br><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）!*.zip</span><br><span class=\"line\"><span class=\"number\">2</span>）!/mtk/one.txt</span><br></pre></td></tr></table></figure></p>\n<p>唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。<br>为什么要有两种规则呢？想象一个场景： <strong>假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理</strong> ，那么我们就需要使用：<br><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）<span class=\"regexp\">/mtk/</span></span><br><span class=\"line\"><span class=\"number\">2</span>）!<span class=\"regexp\">/mtk/</span>one.txt</span><br></pre></td></tr></table></figure></p>\n<p>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</p>\n<p>配置语法：<br>以斜杠“/”开头表示目录；<br>以星号通配多个字符；<br>以问号“?”通配单个字符<br>以方括号“[]”包含单个字符的匹配列表；<br>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</p>\n<h3 id=\"待补充\"><a href=\"#待补充\" class=\"headerlink\" title=\"待补充\"></a>待补充</h3><p>git config 文件配置项</p>\n<ul>\n<li>参考：</li>\n<li>小白教程：<a href=\"https://www.cnblogs.com/yaoxiaowen/p/8227873.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yaoxiaowen/p/8227873.html</a></li>\n<li>秒秒钟入门markdown语法：<a href=\"https://www.jianshu.com/p/q81RER\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/q81RER</a></li>\n<li>Git忽略规则.gitignore梳理:<a href=\"https://www.cnblogs.com/kevingrace/p/5690241.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kevingrace/p/5690241.html</a></li>\n<li>王老师的博客 <a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\" target=\"_blank\" rel=\"noopener\">https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md</a></li>\n<li>git config <a href=\"https://blog.csdn.net/gaochenchen/article/details/76187480\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gaochenchen/article/details/76187480</a></li>\n</ul>"},{"title":"git踩坑日常全记录","date":"2018-05-25T16:00:00.000Z","_content":"\n在工作中使用的代码管理工具之前一直是svn，最近接触了几个使用git管理代码的项目，拉个代码拉了半天，十分生气，记录下踩坑日常，避免重蹈覆辙~\n<!--more-->\n\n### 权限已经开好，但是git clone提示找不到该路径???\n1. 首先，确定权限已经是开好的，没问题\n2. 回忆了一下公司的代码仓库，猜测可能是用户名与自己本地默认的自己github的账号密码不一样\n3. 查看当前用户的配置\n```\ngit config --global  --list\n```\n4. 发现显示的用户名果然与公司的域账号用户名密码不一致，那么问题来了，每次拉代码也没让输用户名密码，怕不是默认记住密码了？？\n```\ngit config --system --list\n```\n- 查看系统config文件中，对是否记住密码的配置，果然\n```\ncredential helper== credential helper\n```\n5. 清除保存的用户名密码\n```\ngit credential-manager delete\n\n或者\n\ngit credential-manager remove [--path <installion_path>] [--passive] [--force]   //停止使用管理工具[中括号选填]\n```\n6. 重新拉取代码，提示输入用户名密码，切换账户后问题解决\n\n参考：\nhttps://segmentfault.com/q/1010000007962678\n","source":"_posts/git踩坑小记录.md","raw":"title: git踩坑日常全记录\ndate: 2018/05/26\ncategories: 效率工具\ntags:\n  - git\n---\n\n在工作中使用的代码管理工具之前一直是svn，最近接触了几个使用git管理代码的项目，拉个代码拉了半天，十分生气，记录下踩坑日常，避免重蹈覆辙~\n<!--more-->\n\n### 权限已经开好，但是git clone提示找不到该路径???\n1. 首先，确定权限已经是开好的，没问题\n2. 回忆了一下公司的代码仓库，猜测可能是用户名与自己本地默认的自己github的账号密码不一样\n3. 查看当前用户的配置\n```\ngit config --global  --list\n```\n4. 发现显示的用户名果然与公司的域账号用户名密码不一致，那么问题来了，每次拉代码也没让输用户名密码，怕不是默认记住密码了？？\n```\ngit config --system --list\n```\n- 查看系统config文件中，对是否记住密码的配置，果然\n```\ncredential helper== credential helper\n```\n5. 清除保存的用户名密码\n```\ngit credential-manager delete\n\n或者\n\ngit credential-manager remove [--path <installion_path>] [--passive] [--force]   //停止使用管理工具[中括号选填]\n```\n6. 重新拉取代码，提示输入用户名密码，切换账户后问题解决\n\n参考：\nhttps://segmentfault.com/q/1010000007962678\n","slug":"git踩坑小记录","published":1,"updated":"2018-05-26T14:24:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3t000eka0tipa7ng3n","content":"<p>在工作中使用的代码管理工具之前一直是svn，最近接触了几个使用git管理代码的项目，拉个代码拉了半天，十分生气，记录下踩坑日常，避免重蹈覆辙~<br><a id=\"more\"></a></p>\n<h3 id=\"权限已经开好，但是git-clone提示找不到该路径\"><a href=\"#权限已经开好，但是git-clone提示找不到该路径\" class=\"headerlink\" title=\"权限已经开好，但是git clone提示找不到该路径???\"></a>权限已经开好，但是git clone提示找不到该路径???</h3><ol>\n<li>首先，确定权限已经是开好的，没问题</li>\n<li>回忆了一下公司的代码仓库，猜测可能是用户名与自己本地默认的自己github的账号密码不一样</li>\n<li><p>查看当前用户的配置</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--global  --list</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发现显示的用户名果然与公司的域账号用户名密码不一致，那么问题来了，每次拉代码也没让输用户名密码，怕不是默认记住密码了？？</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--system --list</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>查看系统config文件中，对是否记住密码的配置，果然<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">credential <span class=\"keyword\">helper</span>== credential <span class=\"keyword\">helper</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>清除保存的用户名密码</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git credential-manager delete</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"></span><br><span class=\"line\">git credential-manager remove <span class=\"string\">[--path &lt;installion_path&gt;]</span> <span class=\"string\">[--passive]</span> <span class=\"string\">[--force]</span>   //停止使用管理工具<span class=\"string\">[中括号选填]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新拉取代码，提示输入用户名密码，切换账户后问题解决</p>\n</li>\n</ol>\n<p>参考：<br><a href=\"https://segmentfault.com/q/1010000007962678\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000007962678</a></p>\n","site":{"data":{}},"excerpt":"<p>在工作中使用的代码管理工具之前一直是svn，最近接触了几个使用git管理代码的项目，拉个代码拉了半天，十分生气，记录下踩坑日常，避免重蹈覆辙~<br>","more":"</p>\n<h3 id=\"权限已经开好，但是git-clone提示找不到该路径\"><a href=\"#权限已经开好，但是git-clone提示找不到该路径\" class=\"headerlink\" title=\"权限已经开好，但是git clone提示找不到该路径???\"></a>权限已经开好，但是git clone提示找不到该路径???</h3><ol>\n<li>首先，确定权限已经是开好的，没问题</li>\n<li>回忆了一下公司的代码仓库，猜测可能是用户名与自己本地默认的自己github的账号密码不一样</li>\n<li><p>查看当前用户的配置</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--global  --list</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发现显示的用户名果然与公司的域账号用户名密码不一致，那么问题来了，每次拉代码也没让输用户名密码，怕不是默认记住密码了？？</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--system --list</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>查看系统config文件中，对是否记住密码的配置，果然<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">credential <span class=\"keyword\">helper</span>== credential <span class=\"keyword\">helper</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>清除保存的用户名密码</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git credential-manager delete</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"></span><br><span class=\"line\">git credential-manager remove <span class=\"string\">[--path &lt;installion_path&gt;]</span> <span class=\"string\">[--passive]</span> <span class=\"string\">[--force]</span>   //停止使用管理工具<span class=\"string\">[中括号选填]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新拉取代码，提示输入用户名密码，切换账户后问题解决</p>\n</li>\n</ol>\n<p>参考：<br><a href=\"https://segmentfault.com/q/1010000007962678\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000007962678</a></p>"},{"title":"利用hexo在多台电脑上提交和更新github pages博客","date":"2018-06-15T16:00:00.000Z","toc":true,"_content":"\n\n#### 概述\nHexo部署到GitHub上的文件，是本地的.md文件编译生成的html文件（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，没有编译之前的母本文件，操作就很麻烦了。\n\n其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，操作简单，效率更高。\n\n但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，就会多出许多不必要的仓库（10个项目需要20个仓库）。所以，本文选择利用分支。\n\n简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。\n\n下面以我的博客作为例子详细地讲述。\n\n\n#### 搭建流程\n\n1 . 创建仓库，shengyur.github.io；\n\n2 . 创建两个分支：master 与 hexo；\n\n3 . 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n\n4 . 使用git clone xxx.github.io.git拷贝仓库；\n\n5 . 在本地xxx.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n\n6 . 修改_config.yml中的deploy参数，分支应为master；\n\n7 . 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；\n\n8 . 执行hexo generate -d生成网站并部署到GitHub上。\n\n这样一来，在GitHub上的xxx.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。多端登陆修改博客就可以实现了~\n\n\n参考：\n1. https://www.jianshu.com/p/0b1fccce74e0\n2. https://formulahendry.github.io/2016/12/04/hexo-ci/\n3. http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\n","source":"_posts/hexo博客的部署优化与管理.md","raw":"title: 利用hexo在多台电脑上提交和更新github pages博客\ndate: 2018/6/16\ncategories: 效率工具\ntoc: true\ntags:\n  - Hexo\n---\n\n\n#### 概述\nHexo部署到GitHub上的文件，是本地的.md文件编译生成的html文件（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，没有编译之前的母本文件，操作就很麻烦了。\n\n其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，操作简单，效率更高。\n\n但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，就会多出许多不必要的仓库（10个项目需要20个仓库）。所以，本文选择利用分支。\n\n简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。\n\n下面以我的博客作为例子详细地讲述。\n\n\n#### 搭建流程\n\n1 . 创建仓库，shengyur.github.io；\n\n2 . 创建两个分支：master 与 hexo；\n\n3 . 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n\n4 . 使用git clone xxx.github.io.git拷贝仓库；\n\n5 . 在本地xxx.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n\n6 . 修改_config.yml中的deploy参数，分支应为master；\n\n7 . 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；\n\n8 . 执行hexo generate -d生成网站并部署到GitHub上。\n\n这样一来，在GitHub上的xxx.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。多端登陆修改博客就可以实现了~\n\n\n参考：\n1. https://www.jianshu.com/p/0b1fccce74e0\n2. https://formulahendry.github.io/2016/12/04/hexo-ci/\n3. http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\n","slug":"hexo博客的部署优化与管理","published":1,"updated":"2018-06-16T15:29:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3w000fka0td41u2mp8","content":"<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Hexo部署到GitHub上的文件，是本地的.md文件编译生成的html文件（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，没有编译之前的母本文件，操作就很麻烦了。</p>\n<p>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，操作简单，效率更高。</p>\n<p>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，就会多出许多不必要的仓库（10个项目需要20个仓库）。所以，本文选择利用分支。</p>\n<p>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p>\n<p>下面以我的博客作为例子详细地讲述。</p>\n<h4 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h4><p>1 . 创建仓库，shengyur.github.io；</p>\n<p>2 . 创建两个分支：master 与 hexo；</p>\n<p>3 . 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</p>\n<p>4 . 使用git clone xxx.github.io.git拷贝仓库；</p>\n<p>5 . 在本地xxx.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</p>\n<p>6 . 修改_config.yml中的deploy参数，分支应为master；</p>\n<p>7 . 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</p>\n<p>8 . 执行hexo generate -d生成网站并部署到GitHub上。</p>\n<p>这样一来，在GitHub上的xxx.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。多端登陆修改博客就可以实现了~</p>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/0b1fccce74e0</a></li>\n<li><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">https://formulahendry.github.io/2016/12/04/hexo-ci/</a></li>\n<li><a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Hexo部署到GitHub上的文件，是本地的.md文件编译生成的html文件（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，没有编译之前的母本文件，操作就很麻烦了。</p>\n<p>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，操作简单，效率更高。</p>\n<p>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，就会多出许多不必要的仓库（10个项目需要20个仓库）。所以，本文选择利用分支。</p>\n<p>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p>\n<p>下面以我的博客作为例子详细地讲述。</p>\n<h4 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h4><p>1 . 创建仓库，shengyur.github.io；</p>\n<p>2 . 创建两个分支：master 与 hexo；</p>\n<p>3 . 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</p>\n<p>4 . 使用git clone xxx.github.io.git拷贝仓库；</p>\n<p>5 . 在本地xxx.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</p>\n<p>6 . 修改_config.yml中的deploy参数，分支应为master；</p>\n<p>7 . 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</p>\n<p>8 . 执行hexo generate -d生成网站并部署到GitHub上。</p>\n<p>这样一来，在GitHub上的xxx.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。多端登陆修改博客就可以实现了~</p>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/0b1fccce74e0</a></li>\n<li><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">https://formulahendry.github.io/2016/12/04/hexo-ci/</a></li>\n<li><a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more</a></li>\n</ol>\n"},{"title":"less配合vscode使用的配置","date":"2018-05-04T16:00:00.000Z","_content":"\n使用场景：写jquery老项目懒得配置css预编译的情况下，安装即用，提升效率。\n\n1. 安装 easy less\n\n2. 安装Preview on web server\n\n3. 在.less 文件最后一行敲下回车，就可以实现编译main.less到main.css了。\n\n如果不生效，就试试下面这个：\n\n1. 安装less转码器\n```\nnpm install -g node-sass less\n```\n2. 在css文件下建个less文件（后缀名为less）\n\n3. Ctrl + Shift + P（配置任务运行器）\n选择Others\n替换内容为：\n```\n  1. // Less configuration\n  2. {\n  3. \"version\": \"0.1.0\",\n  4. \"command\": \"lessc\",\n  5. \"isShellCommand\": true,\n  6. \"args\": [\"css/名字.less\", \"css/名字.css\"]\n  7. }\n  8. }\n```\n","source":"_posts/less配合vscode使用的配置.md","raw":"title: less配合vscode使用的配置\ndate: 2018/05/05\ncategories: 效率工具\ntags:\n  - Less\n  - vscode\n---\n\n使用场景：写jquery老项目懒得配置css预编译的情况下，安装即用，提升效率。\n\n1. 安装 easy less\n\n2. 安装Preview on web server\n\n3. 在.less 文件最后一行敲下回车，就可以实现编译main.less到main.css了。\n\n如果不生效，就试试下面这个：\n\n1. 安装less转码器\n```\nnpm install -g node-sass less\n```\n2. 在css文件下建个less文件（后缀名为less）\n\n3. Ctrl + Shift + P（配置任务运行器）\n选择Others\n替换内容为：\n```\n  1. // Less configuration\n  2. {\n  3. \"version\": \"0.1.0\",\n  4. \"command\": \"lessc\",\n  5. \"isShellCommand\": true,\n  6. \"args\": [\"css/名字.less\", \"css/名字.css\"]\n  7. }\n  8. }\n```\n","slug":"less配合vscode使用的配置","published":1,"updated":"2018-05-26T14:33:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv3z000gka0tyy9p7801","content":"<p>使用场景：写jquery老项目懒得配置css预编译的情况下，安装即用，提升效率。</p>\n<ol>\n<li><p>安装 easy less</p>\n</li>\n<li><p>安装Preview on web server</p>\n</li>\n<li><p>在.less 文件最后一行敲下回车，就可以实现编译main.less到main.css了。</p>\n</li>\n</ol>\n<p>如果不生效，就试试下面这个：</p>\n<ol>\n<li><p>安装less转码器</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g <span class=\"keyword\">node</span><span class=\"title\">-sass</span> less</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在css文件下建个less文件（后缀名为less）</p>\n</li>\n<li><p>Ctrl + Shift + P（配置任务运行器）<br>选择Others<br>替换内容为：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"comment\">// Less configuration</span></span><br><span class=\"line\"><span class=\"number\">2.</span> &#123;</span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.1.0\"</span>,</span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"string\">\"command\"</span>: <span class=\"string\">\"lessc\"</span>,</span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"string\">\"isShellCommand\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"number\">6.</span> <span class=\"string\">\"args\"</span>: [<span class=\"string\">\"css/名字.less\"</span>, <span class=\"string\">\"css/名字.css\"</span>]</span><br><span class=\"line\"><span class=\"number\">7.</span> &#125;</span><br><span class=\"line\"><span class=\"number\">8.</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>使用场景：写jquery老项目懒得配置css预编译的情况下，安装即用，提升效率。</p>\n<ol>\n<li><p>安装 easy less</p>\n</li>\n<li><p>安装Preview on web server</p>\n</li>\n<li><p>在.less 文件最后一行敲下回车，就可以实现编译main.less到main.css了。</p>\n</li>\n</ol>\n<p>如果不生效，就试试下面这个：</p>\n<ol>\n<li><p>安装less转码器</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g <span class=\"keyword\">node</span><span class=\"title\">-sass</span> less</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在css文件下建个less文件（后缀名为less）</p>\n</li>\n<li><p>Ctrl + Shift + P（配置任务运行器）<br>选择Others<br>替换内容为：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"comment\">// Less configuration</span></span><br><span class=\"line\"><span class=\"number\">2.</span> &#123;</span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.1.0\"</span>,</span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"string\">\"command\"</span>: <span class=\"string\">\"lessc\"</span>,</span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"string\">\"isShellCommand\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"number\">6.</span> <span class=\"string\">\"args\"</span>: [<span class=\"string\">\"css/名字.less\"</span>, <span class=\"string\">\"css/名字.css\"</span>]</span><br><span class=\"line\"><span class=\"number\">7.</span> &#125;</span><br><span class=\"line\"><span class=\"number\">8.</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"jquery源码解析01——总体架构","date":"2018-04-26T16:00:00.000Z","_content":"\n## jquery1.7.1源码的总体结构：\n```\n(function( window , undefined ){\n//构造jQuery对象\nvar  jQuery =  (function(){\nvar jQuery =  function (  selector,  context ){\nreturn new jQuery.fn.init(selector,context,rootjQuery);\n}\nreturn jQuery;\n})();\n//工具方法：Utilities\n//回调函数列表：Callbacks  Object\n//异步队列：Deferred  Object\n//浏览器功能测试：Support\n//数据缓存：DataS\n//队列：Queue\n//属性操作：Attributes\n//事件系统：Events\n//选择器：Sizzle\n//DOM遍历：Traversing\n//DOM操作：Manipulation\n//样式操作 css  (计算样式、内联样式)\n//异步请求：Ajax\n//动画： Effects\n//坐标：Offset、尺寸 Dimensions\nwindow.jQuery =  window.$  =  jQuery;\n})(window);\n```\n\n### 为什么要创建一个自调用匿名函数？\n因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突\n\n### 匿名函数自调有几种不同的写法？\n```\n1.（function(){\n//...\n})();\n```\n```\n2: (function(){\n//...\n}());\n```\n```\n3:\t!function(){\n//...\n}();\n```\n\n### 为什么匿名函数自调 要在在前面加！？\n匿名函数自调叫做**立即调用的函数表达式**更为贴切,直接执行,会报错(语法错误SyntaxError)\n语法错误的两种原因：\n- function (){ }()\n期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称\n-  function g(){ }()\n期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。\n所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。\n执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。\n<br>\n注意：\n圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数\n\n### 为什么要自调用匿名函数设置参数window，并传入window对象？\n- 通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，\n从而可以更快的访问window对象\n- 将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现\n(function(a,b){.......})(window)参数window被压缩成a,参数undefined被压缩成b\n\n### 为什么要自调用匿名函数并设置参数undefined？\n- undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链\n- 在压缩代码时可以进行优化\n- 重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值\n\n\n### 为什么匿名函数最后或者最开始要加分号？\n- 因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用\n","source":"_posts/jquery源码解读01-总体架构.md","raw":"title: jquery源码解析01——总体架构\ndate: 2018/4/27\ncategories: 源码浅析\ntags:\n  - jQuery源码\n---\n\n## jquery1.7.1源码的总体结构：\n```\n(function( window , undefined ){\n//构造jQuery对象\nvar  jQuery =  (function(){\nvar jQuery =  function (  selector,  context ){\nreturn new jQuery.fn.init(selector,context,rootjQuery);\n}\nreturn jQuery;\n})();\n//工具方法：Utilities\n//回调函数列表：Callbacks  Object\n//异步队列：Deferred  Object\n//浏览器功能测试：Support\n//数据缓存：DataS\n//队列：Queue\n//属性操作：Attributes\n//事件系统：Events\n//选择器：Sizzle\n//DOM遍历：Traversing\n//DOM操作：Manipulation\n//样式操作 css  (计算样式、内联样式)\n//异步请求：Ajax\n//动画： Effects\n//坐标：Offset、尺寸 Dimensions\nwindow.jQuery =  window.$  =  jQuery;\n})(window);\n```\n\n### 为什么要创建一个自调用匿名函数？\n因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突\n\n### 匿名函数自调有几种不同的写法？\n```\n1.（function(){\n//...\n})();\n```\n```\n2: (function(){\n//...\n}());\n```\n```\n3:\t!function(){\n//...\n}();\n```\n\n### 为什么匿名函数自调 要在在前面加！？\n匿名函数自调叫做**立即调用的函数表达式**更为贴切,直接执行,会报错(语法错误SyntaxError)\n语法错误的两种原因：\n- function (){ }()\n期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称\n-  function g(){ }()\n期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。\n所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。\n执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。\n<br>\n注意：\n圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数\n\n### 为什么要自调用匿名函数设置参数window，并传入window对象？\n- 通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，\n从而可以更快的访问window对象\n- 将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现\n(function(a,b){.......})(window)参数window被压缩成a,参数undefined被压缩成b\n\n### 为什么要自调用匿名函数并设置参数undefined？\n- undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链\n- 在压缩代码时可以进行优化\n- 重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值\n\n\n### 为什么匿名函数最后或者最开始要加分号？\n- 因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用\n","slug":"jquery源码解读01-总体架构","published":1,"updated":"2018-05-02T14:01:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv41000hka0taxpz568c","content":"<h2 id=\"jquery1-7-1源码的总体结构：\"><a href=\"#jquery1-7-1源码的总体结构：\" class=\"headerlink\" title=\"jquery1.7.1源码的总体结构：\"></a>jquery1.7.1源码的总体结构：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window , undefined </span>)</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//构造jQuery对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>  jQuery =  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jQuery =  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">  selector,  context </span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> jQuery.fn.init(selector,context,rootjQuery);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> jQuery;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">//工具方法：Utilities</span></span><br><span class=\"line\"><span class=\"comment\">//回调函数列表：Callbacks  Object</span></span><br><span class=\"line\"><span class=\"comment\">//异步队列：Deferred  Object</span></span><br><span class=\"line\"><span class=\"comment\">//浏览器功能测试：Support</span></span><br><span class=\"line\"><span class=\"comment\">//数据缓存：DataS</span></span><br><span class=\"line\"><span class=\"comment\">//队列：Queue</span></span><br><span class=\"line\"><span class=\"comment\">//属性操作：Attributes</span></span><br><span class=\"line\"><span class=\"comment\">//事件系统：Events</span></span><br><span class=\"line\"><span class=\"comment\">//选择器：Sizzle</span></span><br><span class=\"line\"><span class=\"comment\">//DOM遍历：Traversing</span></span><br><span class=\"line\"><span class=\"comment\">//DOM操作：Manipulation</span></span><br><span class=\"line\"><span class=\"comment\">//样式操作 css  (计算样式、内联样式)</span></span><br><span class=\"line\"><span class=\"comment\">//异步请求：Ajax</span></span><br><span class=\"line\"><span class=\"comment\">//动画： Effects</span></span><br><span class=\"line\"><span class=\"comment\">//坐标：Offset、尺寸 Dimensions</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.jQuery =  <span class=\"built_in\">window</span>.$  =  jQuery;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么要创建一个自调用匿名函数？\"><a href=\"#为什么要创建一个自调用匿名函数？\" class=\"headerlink\" title=\"为什么要创建一个自调用匿名函数？\"></a>为什么要创建一个自调用匿名函数？</h3><p>因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突</p>\n<h3 id=\"匿名函数自调有几种不同的写法？\"><a href=\"#匿名函数自调有几种不同的写法？\" class=\"headerlink\" title=\"匿名函数自调有几种不同的写法？\"></a>匿名函数自调有几种不同的写法？</h3><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>（<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>: (<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span>:\t!<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;();</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么匿名函数自调-要在在前面加！？\"><a href=\"#为什么匿名函数自调-要在在前面加！？\" class=\"headerlink\" title=\"为什么匿名函数自调 要在在前面加！？\"></a>为什么匿名函数自调 要在在前面加！？</h3><p>匿名函数自调叫做<strong>立即调用的函数表达式</strong>更为贴切,直接执行,会报错(语法错误SyntaxError)<br>语法错误的两种原因：</p>\n<ul>\n<li>function (){ }()<br>期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称</li>\n<li>function g(){ }()<br>期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。<br>所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。<br>执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。<br><br><br>注意：<br>圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数</li>\n</ul>\n<h3 id=\"为什么要自调用匿名函数设置参数window，并传入window对象？\"><a href=\"#为什么要自调用匿名函数设置参数window，并传入window对象？\" class=\"headerlink\" title=\"为什么要自调用匿名函数设置参数window，并传入window对象？\"></a>为什么要自调用匿名函数设置参数window，并传入window对象？</h3><ul>\n<li>通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，<br>从而可以更快的访问window对象</li>\n<li>将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现<br>(function(a,b){…….})(window)参数window被压缩成a,参数undefined被压缩成b</li>\n</ul>\n<h3 id=\"为什么要自调用匿名函数并设置参数undefined？\"><a href=\"#为什么要自调用匿名函数并设置参数undefined？\" class=\"headerlink\" title=\"为什么要自调用匿名函数并设置参数undefined？\"></a>为什么要自调用匿名函数并设置参数undefined？</h3><ul>\n<li>undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链</li>\n<li>在压缩代码时可以进行优化</li>\n<li>重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值</li>\n</ul>\n<h3 id=\"为什么匿名函数最后或者最开始要加分号？\"><a href=\"#为什么匿名函数最后或者最开始要加分号？\" class=\"headerlink\" title=\"为什么匿名函数最后或者最开始要加分号？\"></a>为什么匿名函数最后或者最开始要加分号？</h3><ul>\n<li>因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"jquery1-7-1源码的总体结构：\"><a href=\"#jquery1-7-1源码的总体结构：\" class=\"headerlink\" title=\"jquery1.7.1源码的总体结构：\"></a>jquery1.7.1源码的总体结构：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window , undefined </span>)</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//构造jQuery对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>  jQuery =  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jQuery =  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">  selector,  context </span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> jQuery.fn.init(selector,context,rootjQuery);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> jQuery;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">//工具方法：Utilities</span></span><br><span class=\"line\"><span class=\"comment\">//回调函数列表：Callbacks  Object</span></span><br><span class=\"line\"><span class=\"comment\">//异步队列：Deferred  Object</span></span><br><span class=\"line\"><span class=\"comment\">//浏览器功能测试：Support</span></span><br><span class=\"line\"><span class=\"comment\">//数据缓存：DataS</span></span><br><span class=\"line\"><span class=\"comment\">//队列：Queue</span></span><br><span class=\"line\"><span class=\"comment\">//属性操作：Attributes</span></span><br><span class=\"line\"><span class=\"comment\">//事件系统：Events</span></span><br><span class=\"line\"><span class=\"comment\">//选择器：Sizzle</span></span><br><span class=\"line\"><span class=\"comment\">//DOM遍历：Traversing</span></span><br><span class=\"line\"><span class=\"comment\">//DOM操作：Manipulation</span></span><br><span class=\"line\"><span class=\"comment\">//样式操作 css  (计算样式、内联样式)</span></span><br><span class=\"line\"><span class=\"comment\">//异步请求：Ajax</span></span><br><span class=\"line\"><span class=\"comment\">//动画： Effects</span></span><br><span class=\"line\"><span class=\"comment\">//坐标：Offset、尺寸 Dimensions</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.jQuery =  <span class=\"built_in\">window</span>.$  =  jQuery;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么要创建一个自调用匿名函数？\"><a href=\"#为什么要创建一个自调用匿名函数？\" class=\"headerlink\" title=\"为什么要创建一个自调用匿名函数？\"></a>为什么要创建一个自调用匿名函数？</h3><p>因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突</p>\n<h3 id=\"匿名函数自调有几种不同的写法？\"><a href=\"#匿名函数自调有几种不同的写法？\" class=\"headerlink\" title=\"匿名函数自调有几种不同的写法？\"></a>匿名函数自调有几种不同的写法？</h3><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>（<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>: (<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span>:\t!<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;();</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么匿名函数自调-要在在前面加！？\"><a href=\"#为什么匿名函数自调-要在在前面加！？\" class=\"headerlink\" title=\"为什么匿名函数自调 要在在前面加！？\"></a>为什么匿名函数自调 要在在前面加！？</h3><p>匿名函数自调叫做<strong>立即调用的函数表达式</strong>更为贴切,直接执行,会报错(语法错误SyntaxError)<br>语法错误的两种原因：</p>\n<ul>\n<li>function (){ }()<br>期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称</li>\n<li>function g(){ }()<br>期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。<br>所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。<br>执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。<br><br><br>注意：<br>圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数</li>\n</ul>\n<h3 id=\"为什么要自调用匿名函数设置参数window，并传入window对象？\"><a href=\"#为什么要自调用匿名函数设置参数window，并传入window对象？\" class=\"headerlink\" title=\"为什么要自调用匿名函数设置参数window，并传入window对象？\"></a>为什么要自调用匿名函数设置参数window，并传入window对象？</h3><ul>\n<li>通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，<br>从而可以更快的访问window对象</li>\n<li>将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现<br>(function(a,b){…….})(window)参数window被压缩成a,参数undefined被压缩成b</li>\n</ul>\n<h3 id=\"为什么要自调用匿名函数并设置参数undefined？\"><a href=\"#为什么要自调用匿名函数并设置参数undefined？\" class=\"headerlink\" title=\"为什么要自调用匿名函数并设置参数undefined？\"></a>为什么要自调用匿名函数并设置参数undefined？</h3><ul>\n<li>undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链</li>\n<li>在压缩代码时可以进行优化</li>\n<li>重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值</li>\n</ul>\n<h3 id=\"为什么匿名函数最后或者最开始要加分号？\"><a href=\"#为什么匿名函数最后或者最开始要加分号？\" class=\"headerlink\" title=\"为什么匿名函数最后或者最开始要加分号？\"></a>为什么匿名函数最后或者最开始要加分号？</h3><ul>\n<li>因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用</li>\n</ul>\n"},{"title":"Github+Hexo+Maupassant 搭建个人博客教程","date":"2018-04-17T16:00:00.000Z","toc":true,"_content":"\n![](http://7xqdjc.com1.z0.glb.clouddn.com/blog_c2a91a3b4a43d03bf967dda7c7425506.png)\n<!--more-->\n### 安装Node.js\n    用来生成静态页面。移步Node.js官网\n### 安装hexo\n    mac下输入以下命令安装:\n```\nsudo npm install -g hexo\n```\n#### *避坑指南*\n- 输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)\n- Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。\n\n\n### 初始化\n    终端cd到一个你选定的目录，执行hexo init命令：\n```\nhexo init blog\n```\n    blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：\n```\nnpm install\n```\n    执行如下命令,**开启hexo服务器**\n```\nhexo s\n```\n此时，浏览器中打开网址[http://localhost:4000](http://localhost:4000)，能看到如下页面：\n![HEXO初始化](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png)\n至此，跟新博客的本地环境就搭好了！\n\n### 关联Github\n- 创建仓库\n    登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg)\n\n    本地的blog文件夹下内容为：\n\n```\n_config.yml\ndb.json\nnode_modules\npackage.json\nscaffolds\nsource\nthemes\n```\n\n- 终端cd到blog文件夹下，打开_config.yml，命令如下：\n\n```\nopen _config.yml\n```\n\n- 查看文件最后，修改deploy为：\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/shengyur/shengyur.github.io.git\n  branch: master\n```\n- 然后将repo后面的地址中的 shengyur 换成你自己的用户名\n\n#### *避坑指南二*\n在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。\n在blog文件夹目录下执行**生成静态页面命令**：\n```\nhexo generate     简写：hexo g  \n```\n此时若出现如下报错：\n\n```\nERROR Local hexo not found in ~/blog\nERROR Try runing: 'npm install hexo --save'\n```\n\n则执行命令：\n\n```\nnpm install hexo --save\n```\n\n再执行**配置命令**：\n```\nhexo deploy       简写：hexo d\n```\n#### *避坑指南三*\n若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装[hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git)：\n\n\n```\nnpm install hexo-deployer-git --save      \n```\n\n再次执行hexo generate和hexo deploy命令。\n若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即\n\n```\nUsername for 'https://github.com':\nPassword for 'https://github.com':\n```\n\nhexo deploy命令执行成功后，浏览器中打开网址[http://shengyur.github.io](http://shengyur.github.io),\n将shengyur换成你的用户名,就能能看到和打开 [http://localhost:4000](http://localhost:4000) 时一样的页面了。\n\n### 添加ssh key到Github\n#### 检查SSH keys是否存在Github\n执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。\n\n```\nls -al ~/.ssh\n```\n\n#### 生成新的ssh key\n执行如下命令生成public/private rsa key pair，注意将your_email@example.com换成你自己注册Github的邮箱地址。\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。\n\n#### 将ssh key添加到Github中\n- Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。\n\n- 进入Github --> Settings --> SSH keys --> add SSH key:\n\n- Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。\n\n### 发布文章\n终端cd到blog文件夹下，执行如下命令**新建文章**：\n\n```\nhexo new \"postName\"\n```\n\n名为postName.md的文件会建在目录 /blog/source/\\_posts 下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。\n文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：\n\n```\nhexo generate                 //生成静态页面\n\nhexo deploy                   //将文章部署到Github\n```\n\n至此，Mac上搭建基于Github的Hexo博客就大功告成了！\n\n### 跟换博客主题\n如果不喜欢官网默认主题的话，以到[Hexo官网主题页](https://hexo.io/themes/)去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~\n\n\n\n参考：\n- https://blog.csdn.net/yanzi1225627/article/details/54566792\n- https://www.jianshu.com/p/13e64c9e2295\n","source":"_posts/hexo+github+Maupassant搭建博客.md","raw":"title: Github+Hexo+Maupassant 搭建个人博客教程\ndate: 2018/4/18\ncategories: 效率工具\ntoc: true\ntags:\n  - Hexo\n---\n\n![](http://7xqdjc.com1.z0.glb.clouddn.com/blog_c2a91a3b4a43d03bf967dda7c7425506.png)\n<!--more-->\n### 安装Node.js\n    用来生成静态页面。移步Node.js官网\n### 安装hexo\n    mac下输入以下命令安装:\n```\nsudo npm install -g hexo\n```\n#### *避坑指南*\n- 输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)\n- Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。\n\n\n### 初始化\n    终端cd到一个你选定的目录，执行hexo init命令：\n```\nhexo init blog\n```\n    blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：\n```\nnpm install\n```\n    执行如下命令,**开启hexo服务器**\n```\nhexo s\n```\n此时，浏览器中打开网址[http://localhost:4000](http://localhost:4000)，能看到如下页面：\n![HEXO初始化](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png)\n至此，跟新博客的本地环境就搭好了！\n\n### 关联Github\n- 创建仓库\n    登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg)\n\n    本地的blog文件夹下内容为：\n\n```\n_config.yml\ndb.json\nnode_modules\npackage.json\nscaffolds\nsource\nthemes\n```\n\n- 终端cd到blog文件夹下，打开_config.yml，命令如下：\n\n```\nopen _config.yml\n```\n\n- 查看文件最后，修改deploy为：\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/shengyur/shengyur.github.io.git\n  branch: master\n```\n- 然后将repo后面的地址中的 shengyur 换成你自己的用户名\n\n#### *避坑指南二*\n在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。\n在blog文件夹目录下执行**生成静态页面命令**：\n```\nhexo generate     简写：hexo g  \n```\n此时若出现如下报错：\n\n```\nERROR Local hexo not found in ~/blog\nERROR Try runing: 'npm install hexo --save'\n```\n\n则执行命令：\n\n```\nnpm install hexo --save\n```\n\n再执行**配置命令**：\n```\nhexo deploy       简写：hexo d\n```\n#### *避坑指南三*\n若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装[hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git)：\n\n\n```\nnpm install hexo-deployer-git --save      \n```\n\n再次执行hexo generate和hexo deploy命令。\n若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即\n\n```\nUsername for 'https://github.com':\nPassword for 'https://github.com':\n```\n\nhexo deploy命令执行成功后，浏览器中打开网址[http://shengyur.github.io](http://shengyur.github.io),\n将shengyur换成你的用户名,就能能看到和打开 [http://localhost:4000](http://localhost:4000) 时一样的页面了。\n\n### 添加ssh key到Github\n#### 检查SSH keys是否存在Github\n执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。\n\n```\nls -al ~/.ssh\n```\n\n#### 生成新的ssh key\n执行如下命令生成public/private rsa key pair，注意将your_email@example.com换成你自己注册Github的邮箱地址。\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。\n\n#### 将ssh key添加到Github中\n- Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。\n\n- 进入Github --> Settings --> SSH keys --> add SSH key:\n\n- Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。\n\n### 发布文章\n终端cd到blog文件夹下，执行如下命令**新建文章**：\n\n```\nhexo new \"postName\"\n```\n\n名为postName.md的文件会建在目录 /blog/source/\\_posts 下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。\n文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：\n\n```\nhexo generate                 //生成静态页面\n\nhexo deploy                   //将文章部署到Github\n```\n\n至此，Mac上搭建基于Github的Hexo博客就大功告成了！\n\n### 跟换博客主题\n如果不喜欢官网默认主题的话，以到[Hexo官网主题页](https://hexo.io/themes/)去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~\n\n\n\n参考：\n- https://blog.csdn.net/yanzi1225627/article/details/54566792\n- https://www.jianshu.com/p/13e64c9e2295\n","slug":"hexo+github+Maupassant搭建博客","published":1,"updated":"2018-06-16T12:14:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv43000ika0t2btab4ux","content":"<p><img src=\"http://7xqdjc.com1.z0.glb.clouddn.com/blog_c2a91a3b4a43d03bf967dda7c7425506.png\" alt=\"\"><br><a id=\"more\"></a></p>\n<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><pre><code>用来生成静态页面。移步Node.js官网\n</code></pre><h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><pre><code>mac下输入以下命令安装:\n</code></pre><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm <span class=\"keyword\">install</span> -g hexo</span><br></pre></td></tr></table></figure>\n<h4 id=\"避坑指南\"><a href=\"#避坑指南\" class=\"headerlink\" title=\"避坑指南\"></a><em>避坑指南</em></h4><ul>\n<li>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)</li>\n<li>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。</li>\n</ul>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><pre><code>终端cd到一个你选定的目录，执行hexo init命令：\n</code></pre><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo init blog</span></span><br></pre></td></tr></table></figure>\n<pre><code>blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：\n</code></pre><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span></span><br></pre></td></tr></table></figure>\n<pre><code>执行如下命令,**开启hexo服务器**\n</code></pre><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo s</span></span><br></pre></td></tr></table></figure>\n<p>此时，浏览器中打开网址<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a>，能看到如下页面：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png\" alt=\"HEXO初始化\"><br>至此，跟新博客的本地环境就搭好了！</p>\n<h3 id=\"关联Github\"><a href=\"#关联Github\" class=\"headerlink\" title=\"关联Github\"></a>关联Github</h3><ul>\n<li><p>创建仓库<br>  登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg\" alt=\"\"></p>\n<p>  本地的blog文件夹下内容为：</p>\n</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml</span><br><span class=\"line\">db.json</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">package.json</span><br><span class=\"line\">scaffolds</span><br><span class=\"line\">source</span><br><span class=\"line\">themes</span><br></pre></td></tr></table></figure>\n<ul>\n<li>终端cd到blog文件夹下，打开_config.yml，命令如下：</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">open</span> _config.yml</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看文件最后，修改deploy为：</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/shengyur/shengyur.github.io.git</span></span><br><span class=\"line\">  <span class=\"attribute\">branch</span>: master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>然后将repo后面的地址中的 shengyur 换成你自己的用户名</li>\n</ul>\n<h4 id=\"避坑指南二\"><a href=\"#避坑指南二\" class=\"headerlink\" title=\"避坑指南二\"></a><em>避坑指南二</em></h4><p>在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。<br>在blog文件夹目录下执行<strong>生成静态页面命令</strong>：<br><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">generate</span>     简写：hexo g</span><br></pre></td></tr></table></figure></p>\n<p>此时若出现如下报错：</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ERROR </span>Local hexo not found in ~/blog</span><br><span class=\"line\"><span class=\"keyword\">ERROR </span>Try runing: 'npm install hexo --save'</span><br></pre></td></tr></table></figure>\n<p>则执行命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> hexo <span class=\"comment\">--save</span></span><br></pre></td></tr></table></figure>\n<p>再执行<strong>配置命令</strong>：<br><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">deploy</span>       简写：hexo d</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"避坑指南三\"><a href=\"#避坑指南三\" class=\"headerlink\" title=\"避坑指南三\"></a><em>避坑指南三</em></h4><p>若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装<a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"noopener\">hexo-deployer-git</a>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> hexo-deployer-git <span class=\"comment\">--save</span></span><br></pre></td></tr></table></figure>\n<p>再次执行hexo generate和hexo deploy命令。<br>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Username <span class=\"keyword\">for</span> <span class=\"symbol\">'https</span>:<span class=\"comment\">//github.com':</span></span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"symbol\">'https</span>:<span class=\"comment\">//github.com':</span></span><br></pre></td></tr></table></figure>\n<p>hexo deploy命令执行成功后，浏览器中打开网址<a href=\"http://shengyur.github.io\" target=\"_blank\" rel=\"noopener\">http://shengyur.github.io</a>,<br>将shengyur换成你的用户名,就能能看到和打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 时一样的页面了。</p>\n<h3 id=\"添加ssh-key到Github\"><a href=\"#添加ssh-key到Github\" class=\"headerlink\" title=\"添加ssh key到Github\"></a>添加ssh key到Github</h3><h4 id=\"检查SSH-keys是否存在Github\"><a href=\"#检查SSH-keys是否存在Github\" class=\"headerlink\" title=\"检查SSH keys是否存在Github\"></a>检查SSH keys是否存在Github</h4><p>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ls</span> -al ~<span class=\"string\">/.ssh</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"生成新的ssh-key\"><a href=\"#生成新的ssh-key\" class=\"headerlink\" title=\"生成新的ssh key\"></a>生成新的ssh key</h4><p>执行如下命令生成public/private rsa key pair，注意将<a href=\"mailto:your_email@example.com\" target=\"_blank\" rel=\"noopener\">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ssh-keygen</span> <span class=\"selector-tag\">-t</span> <span class=\"selector-tag\">rsa</span> <span class=\"selector-tag\">-C</span> \"<span class=\"selector-tag\">your_email</span>@<span class=\"keyword\">example</span>.<span class=\"keyword\">com</span>\"</span><br></pre></td></tr></table></figure>\n<p>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。</p>\n<h4 id=\"将ssh-key添加到Github中\"><a href=\"#将ssh-key添加到Github中\" class=\"headerlink\" title=\"将ssh key添加到Github中\"></a>将ssh key添加到Github中</h4><ul>\n<li><p>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p>\n</li>\n<li><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p>\n</li>\n<li><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p>\n</li>\n</ul>\n<h3 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h3><p>终端cd到blog文件夹下，执行如下命令<strong>新建文章</strong>：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> <span class=\"string\">\"postName\"</span></span><br></pre></td></tr></table></figure>\n<p>名为postName.md的文件会建在目录 /blog/source/_posts 下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。<br>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">generate</span>                 <span class=\"comment\">//生成静态页面</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo deploy                   <span class=\"comment\">//将文章部署到Github</span></span><br></pre></td></tr></table></figure>\n<p>至此，Mac上搭建基于Github的Hexo博客就大功告成了！</p>\n<h3 id=\"跟换博客主题\"><a href=\"#跟换博客主题\" class=\"headerlink\" title=\"跟换博客主题\"></a>跟换博客主题</h3><p>如果不喜欢官网默认主题的话，以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo官网主题页</a>去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanzi1225627/article/details/54566792\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yanzi1225627/article/details/54566792</a></li>\n<li><a href=\"https://www.jianshu.com/p/13e64c9e2295\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/13e64c9e2295</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://7xqdjc.com1.z0.glb.clouddn.com/blog_c2a91a3b4a43d03bf967dda7c7425506.png\" alt=\"\"><br>","more":"</p>\n<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><pre><code>用来生成静态页面。移步Node.js官网\n</code></pre><h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><pre><code>mac下输入以下命令安装:\n</code></pre><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm <span class=\"keyword\">install</span> -g hexo</span><br></pre></td></tr></table></figure>\n<h4 id=\"避坑指南\"><a href=\"#避坑指南\" class=\"headerlink\" title=\"避坑指南\"></a><em>避坑指南</em></h4><ul>\n<li>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)</li>\n<li>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。</li>\n</ul>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><pre><code>终端cd到一个你选定的目录，执行hexo init命令：\n</code></pre><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo init blog</span></span><br></pre></td></tr></table></figure>\n<pre><code>blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：\n</code></pre><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span></span><br></pre></td></tr></table></figure>\n<pre><code>执行如下命令,**开启hexo服务器**\n</code></pre><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo s</span></span><br></pre></td></tr></table></figure>\n<p>此时，浏览器中打开网址<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a>，能看到如下页面：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png\" alt=\"HEXO初始化\"><br>至此，跟新博客的本地环境就搭好了！</p>\n<h3 id=\"关联Github\"><a href=\"#关联Github\" class=\"headerlink\" title=\"关联Github\"></a>关联Github</h3><ul>\n<li><p>创建仓库<br>  登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg\" alt=\"\"></p>\n<p>  本地的blog文件夹下内容为：</p>\n</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml</span><br><span class=\"line\">db.json</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">package.json</span><br><span class=\"line\">scaffolds</span><br><span class=\"line\">source</span><br><span class=\"line\">themes</span><br></pre></td></tr></table></figure>\n<ul>\n<li>终端cd到blog文件夹下，打开_config.yml，命令如下：</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">open</span> _config.yml</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看文件最后，修改deploy为：</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/shengyur/shengyur.github.io.git</span></span><br><span class=\"line\">  <span class=\"attribute\">branch</span>: master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>然后将repo后面的地址中的 shengyur 换成你自己的用户名</li>\n</ul>\n<h4 id=\"避坑指南二\"><a href=\"#避坑指南二\" class=\"headerlink\" title=\"避坑指南二\"></a><em>避坑指南二</em></h4><p>在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。<br>在blog文件夹目录下执行<strong>生成静态页面命令</strong>：<br><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">generate</span>     简写：hexo g</span><br></pre></td></tr></table></figure></p>\n<p>此时若出现如下报错：</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ERROR </span>Local hexo not found in ~/blog</span><br><span class=\"line\"><span class=\"keyword\">ERROR </span>Try runing: 'npm install hexo --save'</span><br></pre></td></tr></table></figure>\n<p>则执行命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> hexo <span class=\"comment\">--save</span></span><br></pre></td></tr></table></figure>\n<p>再执行<strong>配置命令</strong>：<br><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">deploy</span>       简写：hexo d</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"避坑指南三\"><a href=\"#避坑指南三\" class=\"headerlink\" title=\"避坑指南三\"></a><em>避坑指南三</em></h4><p>若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装<a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"noopener\">hexo-deployer-git</a>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> hexo-deployer-git <span class=\"comment\">--save</span></span><br></pre></td></tr></table></figure>\n<p>再次执行hexo generate和hexo deploy命令。<br>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Username <span class=\"keyword\">for</span> <span class=\"symbol\">'https</span>:<span class=\"comment\">//github.com':</span></span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"symbol\">'https</span>:<span class=\"comment\">//github.com':</span></span><br></pre></td></tr></table></figure>\n<p>hexo deploy命令执行成功后，浏览器中打开网址<a href=\"http://shengyur.github.io\" target=\"_blank\" rel=\"noopener\">http://shengyur.github.io</a>,<br>将shengyur换成你的用户名,就能能看到和打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 时一样的页面了。</p>\n<h3 id=\"添加ssh-key到Github\"><a href=\"#添加ssh-key到Github\" class=\"headerlink\" title=\"添加ssh key到Github\"></a>添加ssh key到Github</h3><h4 id=\"检查SSH-keys是否存在Github\"><a href=\"#检查SSH-keys是否存在Github\" class=\"headerlink\" title=\"检查SSH keys是否存在Github\"></a>检查SSH keys是否存在Github</h4><p>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ls</span> -al ~<span class=\"string\">/.ssh</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"生成新的ssh-key\"><a href=\"#生成新的ssh-key\" class=\"headerlink\" title=\"生成新的ssh key\"></a>生成新的ssh key</h4><p>执行如下命令生成public/private rsa key pair，注意将<a href=\"mailto:your_email@example.com\" target=\"_blank\" rel=\"noopener\">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ssh-keygen</span> <span class=\"selector-tag\">-t</span> <span class=\"selector-tag\">rsa</span> <span class=\"selector-tag\">-C</span> \"<span class=\"selector-tag\">your_email</span>@<span class=\"keyword\">example</span>.<span class=\"keyword\">com</span>\"</span><br></pre></td></tr></table></figure>\n<p>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。</p>\n<h4 id=\"将ssh-key添加到Github中\"><a href=\"#将ssh-key添加到Github中\" class=\"headerlink\" title=\"将ssh key添加到Github中\"></a>将ssh key添加到Github中</h4><ul>\n<li><p>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p>\n</li>\n<li><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p>\n</li>\n<li><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p>\n</li>\n</ul>\n<h3 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h3><p>终端cd到blog文件夹下，执行如下命令<strong>新建文章</strong>：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> <span class=\"string\">\"postName\"</span></span><br></pre></td></tr></table></figure>\n<p>名为postName.md的文件会建在目录 /blog/source/_posts 下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。<br>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">generate</span>                 <span class=\"comment\">//生成静态页面</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo deploy                   <span class=\"comment\">//将文章部署到Github</span></span><br></pre></td></tr></table></figure>\n<p>至此，Mac上搭建基于Github的Hexo博客就大功告成了！</p>\n<h3 id=\"跟换博客主题\"><a href=\"#跟换博客主题\" class=\"headerlink\" title=\"跟换博客主题\"></a>跟换博客主题</h3><p>如果不喜欢官网默认主题的话，以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo官网主题页</a>去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanzi1225627/article/details/54566792\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yanzi1225627/article/details/54566792</a></li>\n<li><a href=\"https://www.jianshu.com/p/13e64c9e2295\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/13e64c9e2295</a></li>\n</ul>"},{"title":"mock工具使用","date":"2018-06-13T16:00:00.000Z","toc":true,"_content":"\n\n## mock的基础解释\n### 目的\n  可以在不依赖后端环境的情况下，进行前端开发，帮助编写单元测试,减少联调成本，提高工作效率。\n\n### 实现功能\n  A.能渲染模板\n  B.实现请求路由映射\n  C.数据接口代理到生产或者测试环境\n\n<!--more-->\n### 常用方式\n  在开发过程中，模拟后台接口数据，快速地实现前端开发。\n\n## mock的用法\n### 安装\n```\n    npm install mockjs\n```\n### 使用mock\n```\n        var Mock = require('mockjs');\n        var mock = Mock.mock({\n            ......\n        })\n```\n### 语法\n\n mock的语法规范包含两层规范：数据模板（DTD）和数据占位符（DPD）。\n\n#### 数据模板DTD\n\n    A.模板规则：'name|rule':value\n```\n        其中，name:属性名； rule:属性规则；value：属性值。\n            属性名和规则之间用|隔开，规则是可以选的。\n```\n    B.7个rule\n    ```\n        'name|min-max':value\n        'name|count':value\n        'name|min-max.dmin-dmax':value\n        'name|min-max.dcount':value\n        'name|count.dmin-dmax':value\n        'name|count.dcount':value\n        'name|+step':value\n```\n\n**（1）生成规则需要根据属性值的类型才能确定（2）属性值可以含有@占位符（3）属性值可以指定最终值的初始值和类型**\n\n    C.属性值是String\n```\n        var data = Mock.mock({\n            'name1|1-3' : 'a', //重复生成1到3个a\n            'name2|2' : 'b' //生成bb\n        })\n```\n    D.属性值是Number\n```\n        var data = Mock.mock({\n            'name1|+1' : 4,  //生成4,如果循环每次加1\n            'name2|1-7' : 2, //生成一个数字，1到7之间\n            'name3|1-4.5-8' : 1  //生成一个小数，整数部分1到4，小数部分5到8位（！！！表示小数点之后的位数范围）\n        })\n```\n    E.属性值是Boolean\n```\n        var data = Mock.mock({\n            'name|1': true, //生成一个布尔值，各一半\n            'name1|1-3': true  // 1/4是true，3/4是false\n        })\n```\n    F.属性值是Object\n```\n        var obj = {\n            a:1,\n            b:2,\n            c:3,\n            d:4\n        }\n        var data = Mock.mock({\n            'name|1-3': obj,\n            'name|2': obj\n        })\n```\n\n    G.属性值是Array\n\n```\n        var arr = [1,2,3];\n        var data = Mock.mock({\n            'name1|1': arr, //从数组里随机取出1个值\n            'name2|2': arr, //数组重复count次，这里count为2\n            'name3|1-3': arr  //数组重复1到3次\n        })\n```\n    H.属性值是Function\n\n```\n        var fun = function(x){\n            return x+10;\n        }\n        var data = Mock.mock({\n            'name':fun(10)         //返回函数的返回值20\n        })\n```\n\n    I.属性值是RegExp\n        根据正则表达式反向生成对应的字符串，用于生成自定义格式的字符串\n```\n            var data = Mock.mock({\n                ‘name1':/[a-z][A-Z]/,\n                'name2':/\\d{1,3}/\n            })\n```\n        会根据各自的正则表达式进行适配，并且随机返回\n\n\n#### 数据占位符DPD\n\n关于占位符，占位符只是在属性值是字符串的时候，在字符串里占个位置，并不会出现在最终的属性值中。\n\n占位符的格式为：@占位符,关于占位符需要知道以下几点：\n\n- 用@标识符标识后面的字符串是占位符\n\n- 占位符的值是从Mock.Random方法中引用的\n\n- 可以通过Mock.Random.extend()来扩展自定义占位符\n\n- 占位符可以引用数据模板中的属性\n\n- 占位符优先引用数据模板中的属性\n\n- 占位符支持相对路径和决定路径\n```\n    var data = Mock.mock({\n        name:{\n            name1:'@FIRST',\n            name2:'@LAST'\n        }    \n    })\n```\n\n#### Mock.mock()\n\n- Mock.mock(rurl,rtype,template|function(opt))\n\n```\n    rurl: ajax请求的地址\n    rtype: ajax请求的类型，如’GET','POST'\n    template: 数据模板，就是之前那些个例子\n    function: 生成相应数据的函数\n```\n\n- 常用的方法\n\n```\n    A. Mock.mock(template)\n\n    B. Mock.mock(rurl,template)，模拟ajax,匹配接收到url的ajax请求，把template对应的数据返回返回\n\n    C. Mock.mock(rurl,function(opt)),模拟ajax,会把函数执行的结果作为ajax回调返回\n\n    D. Mock.mock(rurl,rtype,template) 同上，只是对ajax的类型有要求\n\n    E. Mock.mock(rurl,rtype,function) 同上\n```\n\n#### Mock.setup(setting)\n\n配置拦截ajax请求的行为，支持的配置项有timeout。\n\n```\n    Mock.setup({\n        timeout:200\n    })\n    Mock.setup({\n        timeout:'200-500\n    })\n```\n\n#### Mock.valid(template,data)\n\n这个函数用来判断，数据模板和数据是否一样。\n\n#### Mock.toJSONShema(template)\n\n```\n    var template = Mock.mock({\n        'name|1-3':5\n    })\n    var tjs = Mock.toJSONSchema(tempalte);\n```\n\n####  Mock.Random\n\n```\n    var Random = Mock.Random;\n    var em1 = Mock.email();\n    var em2 = Mock.mock('@email');\n    var em3 = Mock.mock({\n        email:'@email'\n    })\n```\n\n## mock的原理\n1. Mock主要是关于测被测体与外部的交互逻辑。一般是指在不同场景下多次的与外部交互。\n\n2. 当外部依赖是硬件，或者外部程序没有准备好的情况下，Mock就能帮助完成单元测试。\n\n3. Mock的作用就是能通过设置输入输出值，让被测代码的各种工作场景都可以被测试覆盖。\n\n4. 为方便测试，程序设计应该采用依赖倒置原则，让被测试类依赖于接口，Mock类实现该接口。\n\n**被测类通过调用接口最终调用到Mock类，完成测试。而被测试类可以不作任何修改就能在实际系统里工作。\n这就是使用TDD能很自然的使产品代码于外部依赖松耦合。**\n\n参考：\n- [王老师的总结](https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%85%B3%E4%BA%8Emock.md)\n- https://www.zhihu.com/question/35436669/answer/62753889\n- https://segmentfault.com/a/1190000010211622\n- [深入理解Mock工作原理](https://blog.csdn.net/ibelieve1974/article/details/55220015)\n","source":"_posts/mock工具使用.md","raw":"title: mock工具使用\ndate: 2018/06/14\ncategories: 效率工具\ntags:\n  - mock\ntoc: true\n---\n\n\n## mock的基础解释\n### 目的\n  可以在不依赖后端环境的情况下，进行前端开发，帮助编写单元测试,减少联调成本，提高工作效率。\n\n### 实现功能\n  A.能渲染模板\n  B.实现请求路由映射\n  C.数据接口代理到生产或者测试环境\n\n<!--more-->\n### 常用方式\n  在开发过程中，模拟后台接口数据，快速地实现前端开发。\n\n## mock的用法\n### 安装\n```\n    npm install mockjs\n```\n### 使用mock\n```\n        var Mock = require('mockjs');\n        var mock = Mock.mock({\n            ......\n        })\n```\n### 语法\n\n mock的语法规范包含两层规范：数据模板（DTD）和数据占位符（DPD）。\n\n#### 数据模板DTD\n\n    A.模板规则：'name|rule':value\n```\n        其中，name:属性名； rule:属性规则；value：属性值。\n            属性名和规则之间用|隔开，规则是可以选的。\n```\n    B.7个rule\n    ```\n        'name|min-max':value\n        'name|count':value\n        'name|min-max.dmin-dmax':value\n        'name|min-max.dcount':value\n        'name|count.dmin-dmax':value\n        'name|count.dcount':value\n        'name|+step':value\n```\n\n**（1）生成规则需要根据属性值的类型才能确定（2）属性值可以含有@占位符（3）属性值可以指定最终值的初始值和类型**\n\n    C.属性值是String\n```\n        var data = Mock.mock({\n            'name1|1-3' : 'a', //重复生成1到3个a\n            'name2|2' : 'b' //生成bb\n        })\n```\n    D.属性值是Number\n```\n        var data = Mock.mock({\n            'name1|+1' : 4,  //生成4,如果循环每次加1\n            'name2|1-7' : 2, //生成一个数字，1到7之间\n            'name3|1-4.5-8' : 1  //生成一个小数，整数部分1到4，小数部分5到8位（！！！表示小数点之后的位数范围）\n        })\n```\n    E.属性值是Boolean\n```\n        var data = Mock.mock({\n            'name|1': true, //生成一个布尔值，各一半\n            'name1|1-3': true  // 1/4是true，3/4是false\n        })\n```\n    F.属性值是Object\n```\n        var obj = {\n            a:1,\n            b:2,\n            c:3,\n            d:4\n        }\n        var data = Mock.mock({\n            'name|1-3': obj,\n            'name|2': obj\n        })\n```\n\n    G.属性值是Array\n\n```\n        var arr = [1,2,3];\n        var data = Mock.mock({\n            'name1|1': arr, //从数组里随机取出1个值\n            'name2|2': arr, //数组重复count次，这里count为2\n            'name3|1-3': arr  //数组重复1到3次\n        })\n```\n    H.属性值是Function\n\n```\n        var fun = function(x){\n            return x+10;\n        }\n        var data = Mock.mock({\n            'name':fun(10)         //返回函数的返回值20\n        })\n```\n\n    I.属性值是RegExp\n        根据正则表达式反向生成对应的字符串，用于生成自定义格式的字符串\n```\n            var data = Mock.mock({\n                ‘name1':/[a-z][A-Z]/,\n                'name2':/\\d{1,3}/\n            })\n```\n        会根据各自的正则表达式进行适配，并且随机返回\n\n\n#### 数据占位符DPD\n\n关于占位符，占位符只是在属性值是字符串的时候，在字符串里占个位置，并不会出现在最终的属性值中。\n\n占位符的格式为：@占位符,关于占位符需要知道以下几点：\n\n- 用@标识符标识后面的字符串是占位符\n\n- 占位符的值是从Mock.Random方法中引用的\n\n- 可以通过Mock.Random.extend()来扩展自定义占位符\n\n- 占位符可以引用数据模板中的属性\n\n- 占位符优先引用数据模板中的属性\n\n- 占位符支持相对路径和决定路径\n```\n    var data = Mock.mock({\n        name:{\n            name1:'@FIRST',\n            name2:'@LAST'\n        }    \n    })\n```\n\n#### Mock.mock()\n\n- Mock.mock(rurl,rtype,template|function(opt))\n\n```\n    rurl: ajax请求的地址\n    rtype: ajax请求的类型，如’GET','POST'\n    template: 数据模板，就是之前那些个例子\n    function: 生成相应数据的函数\n```\n\n- 常用的方法\n\n```\n    A. Mock.mock(template)\n\n    B. Mock.mock(rurl,template)，模拟ajax,匹配接收到url的ajax请求，把template对应的数据返回返回\n\n    C. Mock.mock(rurl,function(opt)),模拟ajax,会把函数执行的结果作为ajax回调返回\n\n    D. Mock.mock(rurl,rtype,template) 同上，只是对ajax的类型有要求\n\n    E. Mock.mock(rurl,rtype,function) 同上\n```\n\n#### Mock.setup(setting)\n\n配置拦截ajax请求的行为，支持的配置项有timeout。\n\n```\n    Mock.setup({\n        timeout:200\n    })\n    Mock.setup({\n        timeout:'200-500\n    })\n```\n\n#### Mock.valid(template,data)\n\n这个函数用来判断，数据模板和数据是否一样。\n\n#### Mock.toJSONShema(template)\n\n```\n    var template = Mock.mock({\n        'name|1-3':5\n    })\n    var tjs = Mock.toJSONSchema(tempalte);\n```\n\n####  Mock.Random\n\n```\n    var Random = Mock.Random;\n    var em1 = Mock.email();\n    var em2 = Mock.mock('@email');\n    var em3 = Mock.mock({\n        email:'@email'\n    })\n```\n\n## mock的原理\n1. Mock主要是关于测被测体与外部的交互逻辑。一般是指在不同场景下多次的与外部交互。\n\n2. 当外部依赖是硬件，或者外部程序没有准备好的情况下，Mock就能帮助完成单元测试。\n\n3. Mock的作用就是能通过设置输入输出值，让被测代码的各种工作场景都可以被测试覆盖。\n\n4. 为方便测试，程序设计应该采用依赖倒置原则，让被测试类依赖于接口，Mock类实现该接口。\n\n**被测类通过调用接口最终调用到Mock类，完成测试。而被测试类可以不作任何修改就能在实际系统里工作。\n这就是使用TDD能很自然的使产品代码于外部依赖松耦合。**\n\n参考：\n- [王老师的总结](https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%85%B3%E4%BA%8Emock.md)\n- https://www.zhihu.com/question/35436669/answer/62753889\n- https://segmentfault.com/a/1190000010211622\n- [深入理解Mock工作原理](https://blog.csdn.net/ibelieve1974/article/details/55220015)\n","slug":"mock工具使用","published":1,"updated":"2018-06-15T02:08:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv44000jka0tdbpzdpq5","content":"<h2 id=\"mock的基础解释\"><a href=\"#mock的基础解释\" class=\"headerlink\" title=\"mock的基础解释\"></a>mock的基础解释</h2><h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>  可以在不依赖后端环境的情况下，进行前端开发，帮助编写单元测试,减少联调成本，提高工作效率。</p>\n<h3 id=\"实现功能\"><a href=\"#实现功能\" class=\"headerlink\" title=\"实现功能\"></a>实现功能</h3><p>  A.能渲染模板<br>  B.实现请求路由映射<br>  C.数据接口代理到生产或者测试环境</p>\n<a id=\"more\"></a>\n<h3 id=\"常用方式\"><a href=\"#常用方式\" class=\"headerlink\" title=\"常用方式\"></a>常用方式</h3><p>  在开发过程中，模拟后台接口数据，快速地实现前端开发。</p>\n<h2 id=\"mock的用法\"><a href=\"#mock的用法\" class=\"headerlink\" title=\"mock的用法\"></a>mock的用法</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> mockjs</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用mock\"><a href=\"#使用mock\" class=\"headerlink\" title=\"使用mock\"></a>使用mock</h3><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> Mock = <span class=\"keyword\">require</span>(<span class=\"string\">'mockjs'</span>);</span><br><span class=\"line\"><span class=\"built_in\">var</span> mock = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"params\">...</span><span class=\"params\">...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p> mock的语法规范包含两层规范：数据模板（DTD）和数据占位符（DPD）。</p>\n<h4 id=\"数据模板DTD\"><a href=\"#数据模板DTD\" class=\"headerlink\" title=\"数据模板DTD\"></a>数据模板DTD</h4><pre><code>A.模板规则：&apos;name|rule&apos;:value\n</code></pre><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中，<span class=\"built_in\">na</span><span class=\"symbol\">me:</span>属性名； ru<span class=\"symbol\">le:</span>属性规则；<span class=\"built_in\">value</span>：属性值。</span><br><span class=\"line\">    属性名和规则之间用|隔开，规则是可以选的。</span><br></pre></td></tr></table></figure>\n<pre><code>B.7个rule\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>.dmin-dmax':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>.dcount':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>.dmin-dmax':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>.dcount':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|+step':<span class=\"built_in\">value</span></span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（1）生成规则需要根据属性值的类型才能确定（2）属性值可以含有@占位符（3）属性值可以指定最终值的初始值和类型</strong></p>\n<pre><code>C.属性值是String\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|1-3'</span> : <span class=\"string\">'a'</span>, <span class=\"comment\">//重复生成1到3个a</span></span><br><span class=\"line\">    <span class=\"string\">'name2|2'</span> : <span class=\"string\">'b'</span> <span class=\"comment\">//生成bb</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>D.属性值是Number\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|+1'</span> : <span class=\"number\">4</span>,  <span class=\"comment\">//生成4,如果循环每次加1</span></span><br><span class=\"line\">    <span class=\"string\">'name2|1-7'</span> : <span class=\"number\">2</span>, <span class=\"comment\">//生成一个数字，1到7之间</span></span><br><span class=\"line\">    <span class=\"string\">'name3|1-4.5-8'</span> : <span class=\"number\">1</span>  <span class=\"comment\">//生成一个小数，整数部分1到4，小数部分5到8位（！！！表示小数点之后的位数范围）</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>E.属性值是Boolean\n</code></pre><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1'</span>: <span class=\"keyword\">true</span>, <span class=\"regexp\">//</span>生成一个布尔值，各一半</span><br><span class=\"line\">    <span class=\"string\">'name1|1-3'</span>: <span class=\"keyword\">true</span>  /<span class=\"regexp\">/ 1/</span><span class=\"number\">4</span>是<span class=\"keyword\">true</span>，<span class=\"number\">3</span>/<span class=\"number\">4</span>是<span class=\"keyword\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>F.属性值是Object\n</code></pre><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">a</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">b</span>:<span class=\"number\">2</span>,</span><br><span class=\"line\">    c:<span class=\"number\">3</span>,</span><br><span class=\"line\">    d:<span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">var</span> data = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1-3'</span>: obj,</span><br><span class=\"line\">    <span class=\"string\">'name|2'</span>: obj</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>G.属性值是Array\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|1'</span>: arr, <span class=\"comment\">//从数组里随机取出1个值</span></span><br><span class=\"line\">    <span class=\"string\">'name2|2'</span>: arr, <span class=\"comment\">//数组重复count次，这里count为2</span></span><br><span class=\"line\">    <span class=\"string\">'name3|1-3'</span>: arr  <span class=\"comment\">//数组重复1到3次</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>H.属性值是Function\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"function\"><span class=\"keyword\">fun</span> = <span class=\"title\">function</span><span class=\"params\">(x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+<span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name'</span>:<span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>         <span class=\"comment\">//返回函数的返回值20</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>I.属性值是RegExp\n    根据正则表达式反向生成对应的字符串，用于生成自定义格式的字符串\n</code></pre><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> <span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"type\">Mock</span>.mock(&#123;</span></span><br><span class=\"line\"><span class=\"class\">    ‘<span class=\"title\">name1'</span>:/[<span class=\"title\">a</span>-<span class=\"title\">z</span>][<span class=\"type\">A</span>-<span class=\"type\">Z</span>]/,</span></span><br><span class=\"line\"><span class=\"class\">    '<span class=\"title\">name2'</span>:/\\<span class=\"title\">d</span>&#123;1,3&#125;/</span></span><br><span class=\"line\"><span class=\"class\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<pre><code>会根据各自的正则表达式进行适配，并且随机返回\n</code></pre><h4 id=\"数据占位符DPD\"><a href=\"#数据占位符DPD\" class=\"headerlink\" title=\"数据占位符DPD\"></a>数据占位符DPD</h4><p>关于占位符，占位符只是在属性值是字符串的时候，在字符串里占个位置，并不会出现在最终的属性值中。</p>\n<p>占位符的格式为：@占位符,关于占位符需要知道以下几点：</p>\n<ul>\n<li><p>用@标识符标识后面的字符串是占位符</p>\n</li>\n<li><p>占位符的值是从Mock.Random方法中引用的</p>\n</li>\n<li><p>可以通过Mock.Random.extend()来扩展自定义占位符</p>\n</li>\n<li><p>占位符可以引用数据模板中的属性</p>\n</li>\n<li><p>占位符优先引用数据模板中的属性</p>\n</li>\n<li><p>占位符支持相对路径和决定路径</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> <span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"type\">Mock</span>.mock(&#123;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">name</span>:&#123;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">name1</span>:'@<span class=\"type\">FIRST</span>',</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">name2</span>:'@<span class=\"type\">LAST</span>'</span></span><br><span class=\"line\"><span class=\"class\">    &#125;    </span></span><br><span class=\"line\"><span class=\"class\">&#125;)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Mock-mock\"><a href=\"#Mock-mock\" class=\"headerlink\" title=\"Mock.mock()\"></a>Mock.mock()</h4><ul>\n<li>Mock.mock(rurl,rtype,template|function(opt))</li>\n</ul>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">rurl:</span> ajax请求的地址</span><br><span class=\"line\"><span class=\"symbol\">rtype:</span> ajax请求的类型，如’GET<span class=\"string\">','</span>POST'</span><br><span class=\"line\"><span class=\"symbol\">template:</span> 数据模板，就是之前那些个例子</span><br><span class=\"line\"><span class=\"symbol\">function:</span> 生成相应数据的函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常用的方法</li>\n</ul>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A. Mock.mock(<span class=\"keyword\">template</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">B. Mock.mock(rurl,<span class=\"keyword\">template</span>)，模拟ajax,匹配接收到url的ajax请求，把<span class=\"keyword\">template</span>对应的数据返回返回</span><br><span class=\"line\"></span><br><span class=\"line\">C. Mock.mock(rurl,<span class=\"built_in\">function</span>(opt)),模拟ajax,会把函数执行的结果作为ajax回调返回</span><br><span class=\"line\"></span><br><span class=\"line\">D. Mock.mock(rurl,rtype,<span class=\"keyword\">template</span>) 同上，只是对ajax的类型有要求</span><br><span class=\"line\"></span><br><span class=\"line\">E. Mock.mock(rurl,rtype,<span class=\"built_in\">function</span>) 同上</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-setup-setting\"><a href=\"#Mock-setup-setting\" class=\"headerlink\" title=\"Mock.setup(setting)\"></a>Mock.setup(setting)</h4><p>配置拦截ajax请求的行为，支持的配置项有timeout。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mock.setup(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">timeout</span>:<span class=\"number\">200</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Mock.setup(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">timeout</span>:'<span class=\"number\">200</span><span class=\"number\">-500</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-valid-template-data\"><a href=\"#Mock-valid-template-data\" class=\"headerlink\" title=\"Mock.valid(template,data)\"></a>Mock.valid(template,data)</h4><p>这个函数用来判断，数据模板和数据是否一样。</p>\n<h4 id=\"Mock-toJSONShema-template\"><a href=\"#Mock-toJSONShema-template\" class=\"headerlink\" title=\"Mock.toJSONShema(template)\"></a>Mock.toJSONShema(template)</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> template = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1-3'</span>:<span class=\"number\">5</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tjs = Mock.toJSONSchema(tempalte);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-Random\"><a href=\"#Mock-Random\" class=\"headerlink\" title=\"Mock.Random\"></a>Mock.Random</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Random = Mock.Random;</span><br><span class=\"line\"><span class=\"keyword\">var</span> em1 = Mock.email();</span><br><span class=\"line\"><span class=\"keyword\">var</span> em2 = Mock.mock(<span class=\"string\">'@email'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> em3 = Mock.mock(&#123;</span><br><span class=\"line\">    email:<span class=\"string\">'@email'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"mock的原理\"><a href=\"#mock的原理\" class=\"headerlink\" title=\"mock的原理\"></a>mock的原理</h2><ol>\n<li><p>Mock主要是关于测被测体与外部的交互逻辑。一般是指在不同场景下多次的与外部交互。</p>\n</li>\n<li><p>当外部依赖是硬件，或者外部程序没有准备好的情况下，Mock就能帮助完成单元测试。</p>\n</li>\n<li><p>Mock的作用就是能通过设置输入输出值，让被测代码的各种工作场景都可以被测试覆盖。</p>\n</li>\n<li><p>为方便测试，程序设计应该采用依赖倒置原则，让被测试类依赖于接口，Mock类实现该接口。</p>\n</li>\n</ol>\n<p><strong>被测类通过调用接口最终调用到Mock类，完成测试。而被测试类可以不作任何修改就能在实际系统里工作。<br>这就是使用TDD能很自然的使产品代码于外部依赖松耦合。</strong></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%85%B3%E4%BA%8Emock.md\" target=\"_blank\" rel=\"noopener\">王老师的总结</a></li>\n<li><a href=\"https://www.zhihu.com/question/35436669/answer/62753889\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/35436669/answer/62753889</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010211622\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000010211622</a></li>\n<li><a href=\"https://blog.csdn.net/ibelieve1974/article/details/55220015\" target=\"_blank\" rel=\"noopener\">深入理解Mock工作原理</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"mock的基础解释\"><a href=\"#mock的基础解释\" class=\"headerlink\" title=\"mock的基础解释\"></a>mock的基础解释</h2><h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>  可以在不依赖后端环境的情况下，进行前端开发，帮助编写单元测试,减少联调成本，提高工作效率。</p>\n<h3 id=\"实现功能\"><a href=\"#实现功能\" class=\"headerlink\" title=\"实现功能\"></a>实现功能</h3><p>  A.能渲染模板<br>  B.实现请求路由映射<br>  C.数据接口代理到生产或者测试环境</p>","more":"<h3 id=\"常用方式\"><a href=\"#常用方式\" class=\"headerlink\" title=\"常用方式\"></a>常用方式</h3><p>  在开发过程中，模拟后台接口数据，快速地实现前端开发。</p>\n<h2 id=\"mock的用法\"><a href=\"#mock的用法\" class=\"headerlink\" title=\"mock的用法\"></a>mock的用法</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> mockjs</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用mock\"><a href=\"#使用mock\" class=\"headerlink\" title=\"使用mock\"></a>使用mock</h3><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> Mock = <span class=\"keyword\">require</span>(<span class=\"string\">'mockjs'</span>);</span><br><span class=\"line\"><span class=\"built_in\">var</span> mock = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"params\">...</span><span class=\"params\">...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p> mock的语法规范包含两层规范：数据模板（DTD）和数据占位符（DPD）。</p>\n<h4 id=\"数据模板DTD\"><a href=\"#数据模板DTD\" class=\"headerlink\" title=\"数据模板DTD\"></a>数据模板DTD</h4><pre><code>A.模板规则：&apos;name|rule&apos;:value\n</code></pre><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中，<span class=\"built_in\">na</span><span class=\"symbol\">me:</span>属性名； ru<span class=\"symbol\">le:</span>属性规则；<span class=\"built_in\">value</span>：属性值。</span><br><span class=\"line\">    属性名和规则之间用|隔开，规则是可以选的。</span><br></pre></td></tr></table></figure>\n<pre><code>B.7个rule\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>.dmin-dmax':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>.dcount':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>.dmin-dmax':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>.dcount':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|+step':<span class=\"built_in\">value</span></span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（1）生成规则需要根据属性值的类型才能确定（2）属性值可以含有@占位符（3）属性值可以指定最终值的初始值和类型</strong></p>\n<pre><code>C.属性值是String\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|1-3'</span> : <span class=\"string\">'a'</span>, <span class=\"comment\">//重复生成1到3个a</span></span><br><span class=\"line\">    <span class=\"string\">'name2|2'</span> : <span class=\"string\">'b'</span> <span class=\"comment\">//生成bb</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>D.属性值是Number\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|+1'</span> : <span class=\"number\">4</span>,  <span class=\"comment\">//生成4,如果循环每次加1</span></span><br><span class=\"line\">    <span class=\"string\">'name2|1-7'</span> : <span class=\"number\">2</span>, <span class=\"comment\">//生成一个数字，1到7之间</span></span><br><span class=\"line\">    <span class=\"string\">'name3|1-4.5-8'</span> : <span class=\"number\">1</span>  <span class=\"comment\">//生成一个小数，整数部分1到4，小数部分5到8位（！！！表示小数点之后的位数范围）</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>E.属性值是Boolean\n</code></pre><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1'</span>: <span class=\"keyword\">true</span>, <span class=\"regexp\">//</span>生成一个布尔值，各一半</span><br><span class=\"line\">    <span class=\"string\">'name1|1-3'</span>: <span class=\"keyword\">true</span>  /<span class=\"regexp\">/ 1/</span><span class=\"number\">4</span>是<span class=\"keyword\">true</span>，<span class=\"number\">3</span>/<span class=\"number\">4</span>是<span class=\"keyword\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>F.属性值是Object\n</code></pre><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">a</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">b</span>:<span class=\"number\">2</span>,</span><br><span class=\"line\">    c:<span class=\"number\">3</span>,</span><br><span class=\"line\">    d:<span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">var</span> data = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1-3'</span>: obj,</span><br><span class=\"line\">    <span class=\"string\">'name|2'</span>: obj</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>G.属性值是Array\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|1'</span>: arr, <span class=\"comment\">//从数组里随机取出1个值</span></span><br><span class=\"line\">    <span class=\"string\">'name2|2'</span>: arr, <span class=\"comment\">//数组重复count次，这里count为2</span></span><br><span class=\"line\">    <span class=\"string\">'name3|1-3'</span>: arr  <span class=\"comment\">//数组重复1到3次</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>H.属性值是Function\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"function\"><span class=\"keyword\">fun</span> = <span class=\"title\">function</span><span class=\"params\">(x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+<span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name'</span>:<span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>         <span class=\"comment\">//返回函数的返回值20</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>I.属性值是RegExp\n    根据正则表达式反向生成对应的字符串，用于生成自定义格式的字符串\n</code></pre><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> <span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"type\">Mock</span>.mock(&#123;</span></span><br><span class=\"line\"><span class=\"class\">    ‘<span class=\"title\">name1'</span>:/[<span class=\"title\">a</span>-<span class=\"title\">z</span>][<span class=\"type\">A</span>-<span class=\"type\">Z</span>]/,</span></span><br><span class=\"line\"><span class=\"class\">    '<span class=\"title\">name2'</span>:/\\<span class=\"title\">d</span>&#123;1,3&#125;/</span></span><br><span class=\"line\"><span class=\"class\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<pre><code>会根据各自的正则表达式进行适配，并且随机返回\n</code></pre><h4 id=\"数据占位符DPD\"><a href=\"#数据占位符DPD\" class=\"headerlink\" title=\"数据占位符DPD\"></a>数据占位符DPD</h4><p>关于占位符，占位符只是在属性值是字符串的时候，在字符串里占个位置，并不会出现在最终的属性值中。</p>\n<p>占位符的格式为：@占位符,关于占位符需要知道以下几点：</p>\n<ul>\n<li><p>用@标识符标识后面的字符串是占位符</p>\n</li>\n<li><p>占位符的值是从Mock.Random方法中引用的</p>\n</li>\n<li><p>可以通过Mock.Random.extend()来扩展自定义占位符</p>\n</li>\n<li><p>占位符可以引用数据模板中的属性</p>\n</li>\n<li><p>占位符优先引用数据模板中的属性</p>\n</li>\n<li><p>占位符支持相对路径和决定路径</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> <span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"type\">Mock</span>.mock(&#123;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">name</span>:&#123;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">name1</span>:'@<span class=\"type\">FIRST</span>',</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">name2</span>:'@<span class=\"type\">LAST</span>'</span></span><br><span class=\"line\"><span class=\"class\">    &#125;    </span></span><br><span class=\"line\"><span class=\"class\">&#125;)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Mock-mock\"><a href=\"#Mock-mock\" class=\"headerlink\" title=\"Mock.mock()\"></a>Mock.mock()</h4><ul>\n<li>Mock.mock(rurl,rtype,template|function(opt))</li>\n</ul>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">rurl:</span> ajax请求的地址</span><br><span class=\"line\"><span class=\"symbol\">rtype:</span> ajax请求的类型，如’GET<span class=\"string\">','</span>POST'</span><br><span class=\"line\"><span class=\"symbol\">template:</span> 数据模板，就是之前那些个例子</span><br><span class=\"line\"><span class=\"symbol\">function:</span> 生成相应数据的函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常用的方法</li>\n</ul>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A. Mock.mock(<span class=\"keyword\">template</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">B. Mock.mock(rurl,<span class=\"keyword\">template</span>)，模拟ajax,匹配接收到url的ajax请求，把<span class=\"keyword\">template</span>对应的数据返回返回</span><br><span class=\"line\"></span><br><span class=\"line\">C. Mock.mock(rurl,<span class=\"built_in\">function</span>(opt)),模拟ajax,会把函数执行的结果作为ajax回调返回</span><br><span class=\"line\"></span><br><span class=\"line\">D. Mock.mock(rurl,rtype,<span class=\"keyword\">template</span>) 同上，只是对ajax的类型有要求</span><br><span class=\"line\"></span><br><span class=\"line\">E. Mock.mock(rurl,rtype,<span class=\"built_in\">function</span>) 同上</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-setup-setting\"><a href=\"#Mock-setup-setting\" class=\"headerlink\" title=\"Mock.setup(setting)\"></a>Mock.setup(setting)</h4><p>配置拦截ajax请求的行为，支持的配置项有timeout。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mock.setup(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">timeout</span>:<span class=\"number\">200</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Mock.setup(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">timeout</span>:'<span class=\"number\">200</span><span class=\"number\">-500</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-valid-template-data\"><a href=\"#Mock-valid-template-data\" class=\"headerlink\" title=\"Mock.valid(template,data)\"></a>Mock.valid(template,data)</h4><p>这个函数用来判断，数据模板和数据是否一样。</p>\n<h4 id=\"Mock-toJSONShema-template\"><a href=\"#Mock-toJSONShema-template\" class=\"headerlink\" title=\"Mock.toJSONShema(template)\"></a>Mock.toJSONShema(template)</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> template = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1-3'</span>:<span class=\"number\">5</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tjs = Mock.toJSONSchema(tempalte);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-Random\"><a href=\"#Mock-Random\" class=\"headerlink\" title=\"Mock.Random\"></a>Mock.Random</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Random = Mock.Random;</span><br><span class=\"line\"><span class=\"keyword\">var</span> em1 = Mock.email();</span><br><span class=\"line\"><span class=\"keyword\">var</span> em2 = Mock.mock(<span class=\"string\">'@email'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> em3 = Mock.mock(&#123;</span><br><span class=\"line\">    email:<span class=\"string\">'@email'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"mock的原理\"><a href=\"#mock的原理\" class=\"headerlink\" title=\"mock的原理\"></a>mock的原理</h2><ol>\n<li><p>Mock主要是关于测被测体与外部的交互逻辑。一般是指在不同场景下多次的与外部交互。</p>\n</li>\n<li><p>当外部依赖是硬件，或者外部程序没有准备好的情况下，Mock就能帮助完成单元测试。</p>\n</li>\n<li><p>Mock的作用就是能通过设置输入输出值，让被测代码的各种工作场景都可以被测试覆盖。</p>\n</li>\n<li><p>为方便测试，程序设计应该采用依赖倒置原则，让被测试类依赖于接口，Mock类实现该接口。</p>\n</li>\n</ol>\n<p><strong>被测类通过调用接口最终调用到Mock类，完成测试。而被测试类可以不作任何修改就能在实际系统里工作。<br>这就是使用TDD能很自然的使产品代码于外部依赖松耦合。</strong></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%85%B3%E4%BA%8Emock.md\" target=\"_blank\" rel=\"noopener\">王老师的总结</a></li>\n<li><a href=\"https://www.zhihu.com/question/35436669/answer/62753889\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/35436669/answer/62753889</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010211622\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000010211622</a></li>\n<li><a href=\"https://blog.csdn.net/ibelieve1974/article/details/55220015\" target=\"_blank\" rel=\"noopener\">深入理解Mock工作原理</a></li>\n</ul>"},{"title":"node版本切换工具的常用命令","date":"2018-05-04T16:00:00.000Z","_content":"\n使用场景：同时处理几个项目时，依赖的node版本不同，使用nvm工具，可以实现快速切换。\n\n- nvm install <version>  ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4\n- nvm uninstall <version>  ## 删除已安装的指定版本，语法与install类似\n- nvm use <version>  ## 切换使用指定的版本node\n- nvm ls  ## 列出所有安装的版本\n- nvm ls-remote  ## 列出所以远程服务器的版本（官方node version list）\n- nvm current  ## 显示当前的版本\n- nvm alias <name> <version>  ## 给不同的版本号添加别名\n- nvm unalias <name>  ## 删除已定义的别名\n- nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包\n","source":"_posts/node版本切换工具nvm的常用命令.md","raw":"title: node版本切换工具的常用命令\ndate: 2018/05/05\ncategories: 效率工具\n---\n\n使用场景：同时处理几个项目时，依赖的node版本不同，使用nvm工具，可以实现快速切换。\n\n- nvm install <version>  ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4\n- nvm uninstall <version>  ## 删除已安装的指定版本，语法与install类似\n- nvm use <version>  ## 切换使用指定的版本node\n- nvm ls  ## 列出所有安装的版本\n- nvm ls-remote  ## 列出所以远程服务器的版本（官方node version list）\n- nvm current  ## 显示当前的版本\n- nvm alias <name> <version>  ## 给不同的版本号添加别名\n- nvm unalias <name>  ## 删除已定义的别名\n- nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包\n","slug":"node版本切换工具nvm的常用命令","published":1,"updated":"2018-05-05T12:51:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv49000kka0t5klej4tw","content":"<p>使用场景：同时处理几个项目时，依赖的node版本不同，使用nvm工具，可以实现快速切换。</p>\n<ul>\n<li>nvm install <version>  ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4</version></li>\n<li>nvm uninstall <version>  ## 删除已安装的指定版本，语法与install类似</version></li>\n<li>nvm use <version>  ## 切换使用指定的版本node</version></li>\n<li>nvm ls  ## 列出所有安装的版本</li>\n<li>nvm ls-remote  ## 列出所以远程服务器的版本（官方node version list）</li>\n<li>nvm current  ## 显示当前的版本</li>\n<li>nvm alias <name> <version>  ## 给不同的版本号添加别名</version></name></li>\n<li>nvm unalias <name>  ## 删除已定义的别名</name></li>\n<li>nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包</version></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>使用场景：同时处理几个项目时，依赖的node版本不同，使用nvm工具，可以实现快速切换。</p>\n<ul>\n<li>nvm install <version>  ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4</version></li>\n<li>nvm uninstall <version>  ## 删除已安装的指定版本，语法与install类似</version></li>\n<li>nvm use <version>  ## 切换使用指定的版本node</version></li>\n<li>nvm ls  ## 列出所有安装的版本</li>\n<li>nvm ls-remote  ## 列出所以远程服务器的版本（官方node version list）</li>\n<li>nvm current  ## 显示当前的版本</li>\n<li>nvm alias <name> <version>  ## 给不同的版本号添加别名</version></name></li>\n<li>nvm unalias <name>  ## 删除已定义的别名</name></li>\n<li>nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包</version></li>\n</ul>\n"},{"title":"vscode 之多设备配置同步","date":"2018-05-31T16:00:00.000Z","_content":"\n#### 背景：\n多台电脑同时使用的情况下，每次换电脑都重新配置一次就太麻烦了。得同步一把啊~\n\n#### 解决：\n实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。\n<!--more-->\n\n这个配置并不复杂，下面来简单介绍下它的使用：\n- 在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync；\n- 安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置；\n- 如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入；\n- 下载后等待安装，然后重启即可\n\n顺便纪念下2018儿童节的第一分钟，以及那些年我们吹过的牛逼\n![我们的征途，是星辰大海](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/lufi.jpg)\n原文：\nhttps://www.barretlee.com/blog/2017/04/21/something-about-vsc/\n","source":"_posts/vscode之多设备配置同步.md","raw":"title: vscode 之多设备配置同步\ndate: 2018/06/01\ncategories: 效率工具\ntags:\n  - vscode\n---\n\n#### 背景：\n多台电脑同时使用的情况下，每次换电脑都重新配置一次就太麻烦了。得同步一把啊~\n\n#### 解决：\n实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。\n<!--more-->\n\n这个配置并不复杂，下面来简单介绍下它的使用：\n- 在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync；\n- 安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置；\n- 如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入；\n- 下载后等待安装，然后重启即可\n\n顺便纪念下2018儿童节的第一分钟，以及那些年我们吹过的牛逼\n![我们的征途，是星辰大海](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/lufi.jpg)\n原文：\nhttps://www.barretlee.com/blog/2017/04/21/something-about-vsc/\n","slug":"vscode之多设备配置同步","published":1,"updated":"2018-05-31T16:21:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv4b000lka0t9wm33axn","content":"<h4 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h4><p>多台电脑同时使用的情况下，每次换电脑都重新配置一次就太麻烦了。得同步一把啊~</p>\n<h4 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h4><p>实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。<br><a id=\"more\"></a></p>\n<p>这个配置并不复杂，下面来简单介绍下它的使用：</p>\n<ul>\n<li>在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync；</li>\n<li>安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置；</li>\n<li>如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入；</li>\n<li>下载后等待安装，然后重启即可</li>\n</ul>\n<p>顺便纪念下2018儿童节的第一分钟，以及那些年我们吹过的牛逼<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/lufi.jpg\" alt=\"我们的征途，是星辰大海\"><br>原文：<br><a href=\"https://www.barretlee.com/blog/2017/04/21/something-about-vsc/\" target=\"_blank\" rel=\"noopener\">https://www.barretlee.com/blog/2017/04/21/something-about-vsc/</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h4><p>多台电脑同时使用的情况下，每次换电脑都重新配置一次就太麻烦了。得同步一把啊~</p>\n<h4 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h4><p>实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。<br>","more":"</p>\n<p>这个配置并不复杂，下面来简单介绍下它的使用：</p>\n<ul>\n<li>在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync；</li>\n<li>安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置；</li>\n<li>如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入；</li>\n<li>下载后等待安装，然后重启即可</li>\n</ul>\n<p>顺便纪念下2018儿童节的第一分钟，以及那些年我们吹过的牛逼<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/lufi.jpg\" alt=\"我们的征途，是星辰大海\"><br>原文：<br><a href=\"https://www.barretlee.com/blog/2017/04/21/something-about-vsc/\" target=\"_blank\" rel=\"noopener\">https://www.barretlee.com/blog/2017/04/21/something-about-vsc/</a></p>"},{"title":"从面试的角度夯实前端基础","date":"2018-05-01T16:00:00.000Z","toc":true,"_content":"### CSS基础\n  1. 如何实现一个三栏布局，要求两边固定宽度，中间宽度自适应？\n  2. 圣杯布局 双飞翼布局 flex布局分别是什么？\n  3. css的几种垂直居中的方法\n\n<!--more-->\n\n### Javascript基础\n  1. js中的变量提升是什么原理？\n  2. 标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？\n    - 先冒泡还是先捕获？\n    - 各浏览器监听函数的写法是否一致？\n    - 冒泡和捕获的区别是什么？\n  3. 闭包的原理是什么？为什么会造成内存泄露？\n\n\n###  HTTP协议 & 缓存\n  1. 下面的状态码代表的是什么意思？200、204、301、302、304、404？\n  2. HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?\n  3. 对运营商劫持有什么好的处理办法？\n\n###  安全问题\n  1. 富文本编辑器如何解决XSS问题？\n  2. 为什么Restfal API不应当使用'Access-Cross-Origin:* '来实现跨域？\n\n### Node\n  1. Express 和 Koa有什么差别？\n  2. 怎么在Node做CI测试？\n\n### 性能优化\n  1. Yslow 和 PageSpeed用过吗?记得其中多少规则？\n  2. CDN是什么?为什么能资源加速?\n  3. 前端怎么样拿到DNS的查询时间？\n\n### 设计&交互&体验\n  1. PNG 和 JPG 的区别是什么？\n\n### 前端工程化\n  1. 你使用过构建工具来编译前端代码吗?使用过 Grunt、Gulp、webpack、FIS中的一些吗？\n\n### 经验考察\n  1. 你遇到过兼容性问题吗?最令你影响深刻的兼容问题什么?\n\n### 框架类\n1. [React 常用面试题目与分析](https://segmentfault.com/a/1190000008102870)\n### 持续更新中······欢迎补充\n","source":"_posts/从面试的角度夯实前端基础.md","raw":"title: 从面试的角度夯实前端基础\ndate: 2018/05/02\ncategories: 前端基础\ntoc: true\ntags:\n  - Javascript\n  - HTTP\n  - 安全\n  - Node\n---\n### CSS基础\n  1. 如何实现一个三栏布局，要求两边固定宽度，中间宽度自适应？\n  2. 圣杯布局 双飞翼布局 flex布局分别是什么？\n  3. css的几种垂直居中的方法\n\n<!--more-->\n\n### Javascript基础\n  1. js中的变量提升是什么原理？\n  2. 标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？\n    - 先冒泡还是先捕获？\n    - 各浏览器监听函数的写法是否一致？\n    - 冒泡和捕获的区别是什么？\n  3. 闭包的原理是什么？为什么会造成内存泄露？\n\n\n###  HTTP协议 & 缓存\n  1. 下面的状态码代表的是什么意思？200、204、301、302、304、404？\n  2. HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?\n  3. 对运营商劫持有什么好的处理办法？\n\n###  安全问题\n  1. 富文本编辑器如何解决XSS问题？\n  2. 为什么Restfal API不应当使用'Access-Cross-Origin:* '来实现跨域？\n\n### Node\n  1. Express 和 Koa有什么差别？\n  2. 怎么在Node做CI测试？\n\n### 性能优化\n  1. Yslow 和 PageSpeed用过吗?记得其中多少规则？\n  2. CDN是什么?为什么能资源加速?\n  3. 前端怎么样拿到DNS的查询时间？\n\n### 设计&交互&体验\n  1. PNG 和 JPG 的区别是什么？\n\n### 前端工程化\n  1. 你使用过构建工具来编译前端代码吗?使用过 Grunt、Gulp、webpack、FIS中的一些吗？\n\n### 经验考察\n  1. 你遇到过兼容性问题吗?最令你影响深刻的兼容问题什么?\n\n### 框架类\n1. [React 常用面试题目与分析](https://segmentfault.com/a/1190000008102870)\n### 持续更新中······欢迎补充\n","slug":"从面试的角度夯实前端基础","published":1,"updated":"2018-06-04T15:10:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv4e000mka0t7cp91iu4","content":"<h3 id=\"CSS基础\"><a href=\"#CSS基础\" class=\"headerlink\" title=\"CSS基础\"></a>CSS基础</h3><ol>\n<li>如何实现一个三栏布局，要求两边固定宽度，中间宽度自适应？</li>\n<li>圣杯布局 双飞翼布局 flex布局分别是什么？</li>\n<li>css的几种垂直居中的方法</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"Javascript基础\"><a href=\"#Javascript基础\" class=\"headerlink\" title=\"Javascript基础\"></a>Javascript基础</h3><ol>\n<li>js中的变量提升是什么原理？</li>\n<li>标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？<ul>\n<li>先冒泡还是先捕获？</li>\n<li>各浏览器监听函数的写法是否一致？</li>\n<li>冒泡和捕获的区别是什么？</li>\n</ul>\n</li>\n<li>闭包的原理是什么？为什么会造成内存泄露？</li>\n</ol>\n<h3 id=\"HTTP协议-amp-缓存\"><a href=\"#HTTP协议-amp-缓存\" class=\"headerlink\" title=\"HTTP协议 &amp; 缓存\"></a>HTTP协议 &amp; 缓存</h3><ol>\n<li>下面的状态码代表的是什么意思？200、204、301、302、304、404？</li>\n<li>HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?</li>\n<li>对运营商劫持有什么好的处理办法？</li>\n</ol>\n<h3 id=\"安全问题\"><a href=\"#安全问题\" class=\"headerlink\" title=\"安全问题\"></a>安全问题</h3><ol>\n<li>富文本编辑器如何解决XSS问题？</li>\n<li>为什么Restfal API不应当使用’Access-Cross-Origin:* ‘来实现跨域？</li>\n</ol>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><ol>\n<li>Express 和 Koa有什么差别？</li>\n<li>怎么在Node做CI测试？</li>\n</ol>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><ol>\n<li>Yslow 和 PageSpeed用过吗?记得其中多少规则？</li>\n<li>CDN是什么?为什么能资源加速?</li>\n<li>前端怎么样拿到DNS的查询时间？</li>\n</ol>\n<h3 id=\"设计-amp-交互-amp-体验\"><a href=\"#设计-amp-交互-amp-体验\" class=\"headerlink\" title=\"设计&amp;交互&amp;体验\"></a>设计&amp;交互&amp;体验</h3><ol>\n<li>PNG 和 JPG 的区别是什么？</li>\n</ol>\n<h3 id=\"前端工程化\"><a href=\"#前端工程化\" class=\"headerlink\" title=\"前端工程化\"></a>前端工程化</h3><ol>\n<li>你使用过构建工具来编译前端代码吗?使用过 Grunt、Gulp、webpack、FIS中的一些吗？</li>\n</ol>\n<h3 id=\"经验考察\"><a href=\"#经验考察\" class=\"headerlink\" title=\"经验考察\"></a>经验考察</h3><ol>\n<li>你遇到过兼容性问题吗?最令你影响深刻的兼容问题什么?</li>\n</ol>\n<h3 id=\"框架类\"><a href=\"#框架类\" class=\"headerlink\" title=\"框架类\"></a>框架类</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008102870\" target=\"_blank\" rel=\"noopener\">React 常用面试题目与分析</a><h3 id=\"持续更新中······欢迎补充\"><a href=\"#持续更新中······欢迎补充\" class=\"headerlink\" title=\"持续更新中······欢迎补充\"></a>持续更新中······欢迎补充</h3></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"CSS基础\"><a href=\"#CSS基础\" class=\"headerlink\" title=\"CSS基础\"></a>CSS基础</h3><ol>\n<li>如何实现一个三栏布局，要求两边固定宽度，中间宽度自适应？</li>\n<li>圣杯布局 双飞翼布局 flex布局分别是什么？</li>\n<li>css的几种垂直居中的方法</li>\n</ol>","more":"<h3 id=\"Javascript基础\"><a href=\"#Javascript基础\" class=\"headerlink\" title=\"Javascript基础\"></a>Javascript基础</h3><ol>\n<li>js中的变量提升是什么原理？</li>\n<li>标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？<ul>\n<li>先冒泡还是先捕获？</li>\n<li>各浏览器监听函数的写法是否一致？</li>\n<li>冒泡和捕获的区别是什么？</li>\n</ul>\n</li>\n<li>闭包的原理是什么？为什么会造成内存泄露？</li>\n</ol>\n<h3 id=\"HTTP协议-amp-缓存\"><a href=\"#HTTP协议-amp-缓存\" class=\"headerlink\" title=\"HTTP协议 &amp; 缓存\"></a>HTTP协议 &amp; 缓存</h3><ol>\n<li>下面的状态码代表的是什么意思？200、204、301、302、304、404？</li>\n<li>HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?</li>\n<li>对运营商劫持有什么好的处理办法？</li>\n</ol>\n<h3 id=\"安全问题\"><a href=\"#安全问题\" class=\"headerlink\" title=\"安全问题\"></a>安全问题</h3><ol>\n<li>富文本编辑器如何解决XSS问题？</li>\n<li>为什么Restfal API不应当使用’Access-Cross-Origin:* ‘来实现跨域？</li>\n</ol>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><ol>\n<li>Express 和 Koa有什么差别？</li>\n<li>怎么在Node做CI测试？</li>\n</ol>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><ol>\n<li>Yslow 和 PageSpeed用过吗?记得其中多少规则？</li>\n<li>CDN是什么?为什么能资源加速?</li>\n<li>前端怎么样拿到DNS的查询时间？</li>\n</ol>\n<h3 id=\"设计-amp-交互-amp-体验\"><a href=\"#设计-amp-交互-amp-体验\" class=\"headerlink\" title=\"设计&amp;交互&amp;体验\"></a>设计&amp;交互&amp;体验</h3><ol>\n<li>PNG 和 JPG 的区别是什么？</li>\n</ol>\n<h3 id=\"前端工程化\"><a href=\"#前端工程化\" class=\"headerlink\" title=\"前端工程化\"></a>前端工程化</h3><ol>\n<li>你使用过构建工具来编译前端代码吗?使用过 Grunt、Gulp、webpack、FIS中的一些吗？</li>\n</ol>\n<h3 id=\"经验考察\"><a href=\"#经验考察\" class=\"headerlink\" title=\"经验考察\"></a>经验考察</h3><ol>\n<li>你遇到过兼容性问题吗?最令你影响深刻的兼容问题什么?</li>\n</ol>\n<h3 id=\"框架类\"><a href=\"#框架类\" class=\"headerlink\" title=\"框架类\"></a>框架类</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008102870\" target=\"_blank\" rel=\"noopener\">React 常用面试题目与分析</a><h3 id=\"持续更新中······欢迎补充\"><a href=\"#持续更新中······欢迎补充\" class=\"headerlink\" title=\"持续更新中······欢迎补充\"></a>持续更新中······欢迎补充</h3></li>\n</ol>"},{"title":"函数式编程入门","date":"2018-06-08T16:00:00.000Z","toc":true,"_content":"\n### 什么是函数式编程？\n- 与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。\n- 最主要的特征是，函数是第一等公民。\n- 强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。\n- 只有纯的、没有副作用的函数，才是合格的函数。\n<figure>\n![Gardenia jasminoides](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/fl.jpeg)\n</figure>\n<!--more-->\n\n### 范畴论与函数式编程\n- 在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。\n- 所以，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。\n- **本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。**\n\n### 函数的合成与柯里化\n函数式编程有两个最基本的运算：合成和柯里化。\n#### 函数的合成\n如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做\"函数的合成\"（compose）。\n合成两个函数的简单代码如下。\n```\nconst compose = function (f, g) {\n  return function (x) {\n    return f(g(x));\n  };\n}\n```\n函数的合成还必须满足结合律。\n```\ncompose(f, compose(g, h))\n// 等同于\ncompose(compose(f, g), h)\n// 等同于\ncompose(f, g, h)\n```\n**合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？**\n前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。\n\n#### 柯里化\nf(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。\n**这时就需要函数柯里化了。所谓\"柯里化\"，就是把一个多参数的函数，转化为单参数函数。**\n```\n// 柯里化之前\nfunction add(x, y) {\n  return x + y;\n}\n\nadd(1, 2) // 3\n\n// 柯里化之后\nfunction addX(y) {\n  return function (x) {\n    return x + y;\n  };\n}\n\naddX(2)(1) // 3\n```\n\n看困了== 未完待续。。。\n\n\n\n参考：\n- [函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)\n","source":"_posts/函数式编程入门.md","raw":"title: 函数式编程入门\ndate: 2018/06/09\ncategories: 技术思想\ntoc: true\ntags:\n  - 函数式编程\n---\n\n### 什么是函数式编程？\n- 与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。\n- 最主要的特征是，函数是第一等公民。\n- 强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。\n- 只有纯的、没有副作用的函数，才是合格的函数。\n<figure>\n![Gardenia jasminoides](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/fl.jpeg)\n</figure>\n<!--more-->\n\n### 范畴论与函数式编程\n- 在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。\n- 所以，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。\n- **本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。**\n\n### 函数的合成与柯里化\n函数式编程有两个最基本的运算：合成和柯里化。\n#### 函数的合成\n如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做\"函数的合成\"（compose）。\n合成两个函数的简单代码如下。\n```\nconst compose = function (f, g) {\n  return function (x) {\n    return f(g(x));\n  };\n}\n```\n函数的合成还必须满足结合律。\n```\ncompose(f, compose(g, h))\n// 等同于\ncompose(compose(f, g), h)\n// 等同于\ncompose(f, g, h)\n```\n**合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？**\n前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。\n\n#### 柯里化\nf(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。\n**这时就需要函数柯里化了。所谓\"柯里化\"，就是把一个多参数的函数，转化为单参数函数。**\n```\n// 柯里化之前\nfunction add(x, y) {\n  return x + y;\n}\n\nadd(1, 2) // 3\n\n// 柯里化之后\nfunction addX(y) {\n  return function (x) {\n    return x + y;\n  };\n}\n\naddX(2)(1) // 3\n```\n\n看困了== 未完待续。。。\n\n\n\n参考：\n- [函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)\n","slug":"函数式编程入门","published":1,"updated":"2018-06-10T02:16:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv4f000nka0tvarnri2w","content":"<h3 id=\"什么是函数式编程？\"><a href=\"#什么是函数式编程？\" class=\"headerlink\" title=\"什么是函数式编程？\"></a>什么是函数式编程？</h3><ul>\n<li>与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。</li>\n<li>最主要的特征是，函数是第一等公民。</li>\n<li>强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。</li>\n<li>只有纯的、没有副作用的函数，才是合格的函数。<br><figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/fl.jpeg\" alt=\"Gardenia jasminoides\"><br></figure><a id=\"more\"></a>\n</li>\n</ul>\n<h3 id=\"范畴论与函数式编程\"><a href=\"#范畴论与函数式编程\" class=\"headerlink\" title=\"范畴论与函数式编程\"></a>范畴论与函数式编程</h3><ul>\n<li>在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。</li>\n<li>所以，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</li>\n<li><strong>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。</strong></li>\n</ul>\n<h3 id=\"函数的合成与柯里化\"><a href=\"#函数的合成与柯里化\" class=\"headerlink\" title=\"函数的合成与柯里化\"></a>函数的合成与柯里化</h3><p>函数式编程有两个最基本的运算：合成和柯里化。</p>\n<h4 id=\"函数的合成\"><a href=\"#函数的合成\" class=\"headerlink\" title=\"函数的合成\"></a>函数的合成</h4><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。<br>合成两个函数的简单代码如下。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(f, g)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数的合成还必须满足结合律。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(f, compose(g, h)</span></span>)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(compose(f, g)</span></span>, h)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(f, g, h)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？</strong><br>前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。</p>\n<h4 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h4><p>f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。<br><strong>这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</strong><br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 柯里化之前</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 柯里化之后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addX</span><span class=\"params\">(y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addX(<span class=\"number\">2</span>)(<span class=\"number\">1</span>) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>看困了== 未完待续。。。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\" target=\"_blank\" rel=\"noopener\">函数式编程入门教程</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是函数式编程？\"><a href=\"#什么是函数式编程？\" class=\"headerlink\" title=\"什么是函数式编程？\"></a>什么是函数式编程？</h3><ul>\n<li>与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。</li>\n<li>最主要的特征是，函数是第一等公民。</li>\n<li>强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。</li>\n<li>只有纯的、没有副作用的函数，才是合格的函数。<br><figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/fl.jpeg\" alt=\"Gardenia jasminoides\"><br></figure>","more":"</li>\n</ul>\n<h3 id=\"范畴论与函数式编程\"><a href=\"#范畴论与函数式编程\" class=\"headerlink\" title=\"范畴论与函数式编程\"></a>范畴论与函数式编程</h3><ul>\n<li>在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。</li>\n<li>所以，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</li>\n<li><strong>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。</strong></li>\n</ul>\n<h3 id=\"函数的合成与柯里化\"><a href=\"#函数的合成与柯里化\" class=\"headerlink\" title=\"函数的合成与柯里化\"></a>函数的合成与柯里化</h3><p>函数式编程有两个最基本的运算：合成和柯里化。</p>\n<h4 id=\"函数的合成\"><a href=\"#函数的合成\" class=\"headerlink\" title=\"函数的合成\"></a>函数的合成</h4><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。<br>合成两个函数的简单代码如下。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(f, g)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数的合成还必须满足结合律。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(f, compose(g, h)</span></span>)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(compose(f, g)</span></span>, h)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(f, g, h)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？</strong><br>前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。</p>\n<h4 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h4><p>f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。<br><strong>这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</strong><br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 柯里化之前</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 柯里化之后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addX</span><span class=\"params\">(y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addX(<span class=\"number\">2</span>)(<span class=\"number\">1</span>) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>看困了== 未完待续。。。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\" target=\"_blank\" rel=\"noopener\">函数式编程入门教程</a></li>\n</ul>"},{"title":"复制知乎/简书的文本内容，为什么会自带版权声明？","date":"2018-04-30T16:00:00.000Z","_content":"\n实现思路：\n1. 答案区域监听copy事件，并阻止这个事件的默认行为。\n2. 获取选中的内容**window.getSelection()**后加上版权信息，然后设置到剪切板**clipboardData.setData()**。\n\n```\n<div id=\"copyText\">我是一段即将被复制的话<b>test</b></div>\n<script>\n    function setClipboardText(e){\n        e.preventDefault();\n        var node = document.getElementById('#copyText');\n        var htmlData = '<div>著作权归作者所有。<br />'\n                        + '商业转载请联系作者获得授权，非商业转载请注明出处。<br />'\n                        + '作者：shengyu <br/>链接：https://shengyur.github.io/<br />'\n                        + node.innerHTML\n                        + '</div>';\n        var textData = '著作权归作者所有。\\n'\n                        + '商业转载请联系作者获得授权，非商业转载请注明出处。\\n'\n                        + '作者：shengyu \\n链接：https://shengyur.github.io/ \\n'\n                        + window.getSelection().getRangeAt(0);\n        if(e.clipboardData){  \n            e.clipboardData.setData(\"text/html\", htmlData);\n            e.clipboardData.setData(\"text/plain\",textData);\n        }\n        else if(window.clipboardData){  \n            return window.clipboardData.setData(\"text\", textData);  \n        }  \n    };  \n    var answer = document.getElementById(\"answer\");\n    answer.addEventListener('copy',function(e){\n        setClipboardText(e);\n    });\n</script>\n```\n\n\n备注：\n- 如果是复制到纯文本编辑器，就使用clipboardData.setData(\"text/plain\",textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(\"text/html\", htmlData);)，比如word,就有必要保留标签了。\n- oncopy 事件在用户拷贝元素上的内容时触发。\n- 有三种方式可以拷贝元素和内容：\n    1. 按下 CTRL + C\n    2. 在你的浏览器的 Edit(编辑) 菜单中选择 \"Copy（复制）\"\n    3. 右键鼠标按钮，在上下文菜单中选择 \"Copy（复制）\" 命令。\n\n\n参考：https://blog.csdn.net/sinat_23880167/article/details/79418505\n","source":"_posts/复制知乎简书的文本内容，为什么会自带版权声明？.md","raw":"title: 复制知乎/简书的文本内容，为什么会自带版权声明？\ndate: 2018/05/01\ncategories: 十万个为什么\n\n---\n\n实现思路：\n1. 答案区域监听copy事件，并阻止这个事件的默认行为。\n2. 获取选中的内容**window.getSelection()**后加上版权信息，然后设置到剪切板**clipboardData.setData()**。\n\n```\n<div id=\"copyText\">我是一段即将被复制的话<b>test</b></div>\n<script>\n    function setClipboardText(e){\n        e.preventDefault();\n        var node = document.getElementById('#copyText');\n        var htmlData = '<div>著作权归作者所有。<br />'\n                        + '商业转载请联系作者获得授权，非商业转载请注明出处。<br />'\n                        + '作者：shengyu <br/>链接：https://shengyur.github.io/<br />'\n                        + node.innerHTML\n                        + '</div>';\n        var textData = '著作权归作者所有。\\n'\n                        + '商业转载请联系作者获得授权，非商业转载请注明出处。\\n'\n                        + '作者：shengyu \\n链接：https://shengyur.github.io/ \\n'\n                        + window.getSelection().getRangeAt(0);\n        if(e.clipboardData){  \n            e.clipboardData.setData(\"text/html\", htmlData);\n            e.clipboardData.setData(\"text/plain\",textData);\n        }\n        else if(window.clipboardData){  \n            return window.clipboardData.setData(\"text\", textData);  \n        }  \n    };  \n    var answer = document.getElementById(\"answer\");\n    answer.addEventListener('copy',function(e){\n        setClipboardText(e);\n    });\n</script>\n```\n\n\n备注：\n- 如果是复制到纯文本编辑器，就使用clipboardData.setData(\"text/plain\",textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(\"text/html\", htmlData);)，比如word,就有必要保留标签了。\n- oncopy 事件在用户拷贝元素上的内容时触发。\n- 有三种方式可以拷贝元素和内容：\n    1. 按下 CTRL + C\n    2. 在你的浏览器的 Edit(编辑) 菜单中选择 \"Copy（复制）\"\n    3. 右键鼠标按钮，在上下文菜单中选择 \"Copy（复制）\" 命令。\n\n\n参考：https://blog.csdn.net/sinat_23880167/article/details/79418505\n","slug":"复制知乎简书的文本内容，为什么会自带版权声明？","published":1,"updated":"2018-05-02T14:02:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv4g000oka0tl8hevego","content":"<p>实现思路：</p>\n<ol>\n<li>答案区域监听copy事件，并阻止这个事件的默认行为。</li>\n<li>获取选中的内容<strong>window.getSelection()</strong>后加上版权信息，然后设置到剪切板<strong>clipboardData.setData()</strong>。</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"copyText\"</span>&gt;</span>我是一段即将被复制的话<span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setClipboardText</span><span class=\"params\">(e)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        e.preventDefault();</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'#copyText'</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> htmlData = <span class=\"string\">'&lt;div&gt;著作权归作者所有。&lt;br /&gt;'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'商业转载请联系作者获得授权，非商业转载请注明出处。&lt;br /&gt;'</span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">                        + '作者：shengyu <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span>链接：https://shengyur.github.io/<span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span>'</span></span></span><br><span class=\"line\"><span class=\"undefined\">                        + node.innerHTML</span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'&lt;/div&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> textData = <span class=\"string\">'著作权归作者所有。\\n'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'商业转载请联系作者获得授权，非商业转载请注明出处。\\n'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'作者：shengyu \\n链接：https://shengyur.github.io/ \\n'</span></span></span><br><span class=\"line\"><span class=\"javascript\">                        + <span class=\"built_in\">window</span>.getSelection().getRangeAt(<span class=\"number\">0</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">if</span>(e.clipboardData)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\">            e.clipboardData.setData(<span class=\"string\">\"text/html\"</span>, htmlData);</span></span><br><span class=\"line\"><span class=\"actionscript\">            e.clipboardData.setData(<span class=\"string\">\"text/plain\"</span>,textData);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.clipboardData)&#123;  </span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.clipboardData.setData(<span class=\"string\">\"text\"</span>, textData);  </span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;  </span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;  </span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> answer = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"answer\"</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    answer.addEventListener(<span class=\"string\">'copy'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(e)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        setClipboardText(e);</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>备注：</p>\n<ul>\n<li>如果是复制到纯文本编辑器，就使用clipboardData.setData(“text/plain”,textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(“text/html”, htmlData);)，比如word,就有必要保留标签了。</li>\n<li>oncopy 事件在用户拷贝元素上的内容时触发。</li>\n<li>有三种方式可以拷贝元素和内容：<ol>\n<li>按下 CTRL + C</li>\n<li>在你的浏览器的 Edit(编辑) 菜单中选择 “Copy（复制）”</li>\n<li>右键鼠标按钮，在上下文菜单中选择 “Copy（复制）” 命令。</li>\n</ol>\n</li>\n</ul>\n<p>参考：<a href=\"https://blog.csdn.net/sinat_23880167/article/details/79418505\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_23880167/article/details/79418505</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>实现思路：</p>\n<ol>\n<li>答案区域监听copy事件，并阻止这个事件的默认行为。</li>\n<li>获取选中的内容<strong>window.getSelection()</strong>后加上版权信息，然后设置到剪切板<strong>clipboardData.setData()</strong>。</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"copyText\"</span>&gt;</span>我是一段即将被复制的话<span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setClipboardText</span><span class=\"params\">(e)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        e.preventDefault();</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'#copyText'</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> htmlData = <span class=\"string\">'&lt;div&gt;著作权归作者所有。&lt;br /&gt;'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'商业转载请联系作者获得授权，非商业转载请注明出处。&lt;br /&gt;'</span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">                        + '作者：shengyu <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span>链接：https://shengyur.github.io/<span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span>'</span></span></span><br><span class=\"line\"><span class=\"undefined\">                        + node.innerHTML</span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'&lt;/div&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> textData = <span class=\"string\">'著作权归作者所有。\\n'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'商业转载请联系作者获得授权，非商业转载请注明出处。\\n'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'作者：shengyu \\n链接：https://shengyur.github.io/ \\n'</span></span></span><br><span class=\"line\"><span class=\"javascript\">                        + <span class=\"built_in\">window</span>.getSelection().getRangeAt(<span class=\"number\">0</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">if</span>(e.clipboardData)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\">            e.clipboardData.setData(<span class=\"string\">\"text/html\"</span>, htmlData);</span></span><br><span class=\"line\"><span class=\"actionscript\">            e.clipboardData.setData(<span class=\"string\">\"text/plain\"</span>,textData);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.clipboardData)&#123;  </span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.clipboardData.setData(<span class=\"string\">\"text\"</span>, textData);  </span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;  </span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;  </span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> answer = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"answer\"</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    answer.addEventListener(<span class=\"string\">'copy'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(e)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        setClipboardText(e);</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>备注：</p>\n<ul>\n<li>如果是复制到纯文本编辑器，就使用clipboardData.setData(“text/plain”,textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(“text/html”, htmlData);)，比如word,就有必要保留标签了。</li>\n<li>oncopy 事件在用户拷贝元素上的内容时触发。</li>\n<li>有三种方式可以拷贝元素和内容：<ol>\n<li>按下 CTRL + C</li>\n<li>在你的浏览器的 Edit(编辑) 菜单中选择 “Copy（复制）”</li>\n<li>右键鼠标按钮，在上下文菜单中选择 “Copy（复制）” 命令。</li>\n</ol>\n</li>\n</ul>\n<p>参考：<a href=\"https://blog.csdn.net/sinat_23880167/article/details/79418505\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_23880167/article/details/79418505</a></p>\n"},{"title":"对象与数组的深浅拷贝","date":"2018-06-12T16:00:00.000Z","toc":true,"_content":"<img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\" style=\"width:56%\"></img>\n\n\n使用场景：\n\n引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。\n\n当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作\n<!--more-->\n\n## Javascript中的深拷贝与浅拷贝为什么会有区别？\n对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。\n\n首先了解一些javascript的基本知识。\n### 1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。\n**基本类型** 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：\n\nnumber、string、boolean、null、undefined、symbol\n\n**引用类型** 值指那些可能由多个值构成的对象，只有一种如下：\n\nobject（Array也属于对象）\n\n在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。\n引用类型的值是保存在内存中的对象。与其他语言不同，**JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。**\n### 2.javascript的变量的存储方式--栈（stack）和堆（heap）\n**栈** ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址\n**堆** ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。\n<img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\"></img>\n### 3.javascript值传递与址传递\n基本类型与引用类型最大的区别实际就是 **传值与传址的区别**\n值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。\n址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。\n\n所以当\n```\nvar obj={};\nvar newObj=obj;\nnewObj={\"name\":\"shengyu\"}\n```\n时候，打印出obj的值，会发现obj的值与newObj一起被修改了\n\n那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。\n\n## 什么是深拷贝/浅拷贝？\n浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，**彼此之间的操作会互相影响**。\n深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 **是完全隔离的**。\n由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 **保证复制的对象与源对象完全隔离** 。然而，*还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深*。\n\n\n## 如何对常见引用类型进行深/浅拷贝？\n*本文认为，浅复制就是简单的引用复制，这种情况较很简单，通过如下代码简单理解一下*\n```\nvar src = {\n       name:\"src\"\n   }\n   //复制一份src对象的应用\n   var target = src;\n   target.name = \"target\";\n   console.log(src.name);   //输出 \"target\"\n```\ntarget对象只是src对象的引用值的复制，因此target的改变也会影响src。\n\n### 数组\n#### 数组的浅拷贝\n- 拷贝原数组的引用，这是最简单的浅拷贝。\n\n#### 数组的深拷贝\n- Array的slice和concat方法\n\nArray的slice和concat方法都会返回一个新的数组实例，但是这两个方法 **对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制**，通过以下代码进行理解：\nconcat和slice返回的不同的数组实例，这与直接的引用复制是不同的。\n\n```\nvar o1 = ['darko', {age: 22}];\nvar o2 = o1.slice(); // 根据Array.prototype.slice()的特性，这里会返回一个o1的深拷贝对象\n\nconsole.log(o1 === o2); // => false，说明o2拷贝的是o1的一个实例\n\no2[0] = 'lee';\nconsole.log(o1[0]); // => \"darko\" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响\n\no2[1].age = 23;\nconsole.log(o1[1].age); // =>23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响，属于浅拷贝\n```\n\n通过代码的输出可以看出concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。\n\n\n### 对象\n#### 对象的浅拷贝\n- 拷贝原对象的引用，这是最简单的浅拷贝。\n\n#### 对象的深拷贝\n- (1) JSON对象的parse和stringify\nJSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深复制\n\n```\nvar source = {\n    name:\"source\",\n    child:{\n        name:\"child\"\n    }\n}\nvar target = JSON.parse(JSON.stringify(source));\n//改变target的name属性\ntarget.name = \"target\";\nconsole.log(source.name);   //source\nconsole.log(target.name);   //target\n//改变target的child\ntarget.child.name = \"target child\";\nconsole.log(source.child.name);  //child\nconsole.log(target.child.name);  //target child\n```\n从代码的输出可以看出，复制后的target与source是完全隔离的，二者不会相互影响。\n*这个方法使用较为简单，可以满足基本的深复制需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深复制(而且会直接丢失相应的值)，同时如果对象中存在循环引用的情况也无法正确处理*\n\n- jQuery中的extend方法可以用来扩展对象，这个方法可以传入一个参数:deep(true or false)，表示是否执行深复制(如果是深复制则会执行递归复制)，我们首先看一下jquery中的源码(1.9.1)\n```\njQuery.extend = jQuery.fn.extend = function() {\n    var options, name, src, copy, copyIsArray, clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n    // Handle a deep copy situation\n    if ( typeof target === \"boolean\" ) {\n        deep = target;\n        target = arguments[1] || {};\n        // skip the boolean and the target\n        i = 2;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n        target = {};\n    }\n\n    // extend jQuery itself if only one argument is passed\n    if ( length === i ) {\n        target = this;\n        --i;\n    }\n\n    for ( ; i < length; i++ ) {\n        // Only deal with non-null/undefined values\n        if ( (options = arguments[ i ]) != null ) {\n            // Extend the base object\n            for ( name in options ) {\n                src = target[ name ];\n                copy = options[ name ];\n\n                // Prevent never-ending loop\n                if ( target === copy ) {\n                    continue;\n                }\n\n                // Recurse if we're merging plain objects or arrays\n                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n                    if ( copyIsArray ) {\n                        copyIsArray = false;\n                        clone = src && jQuery.isArray(src) ? src : [];\n\n                    } else {\n                        clone = src && jQuery.isPlainObject(src) ? src : {};\n                    }\n\n                    // Never move original objects, clone them\n                    target[ name ] = jQuery.extend( deep, clone, copy );\n\n                // Don't bring in undefined values\n                } else if ( copy !== undefined ) {\n                    target[ name ] = copy;\n                }\n            }\n        }\n    }\n\n    // Return the modified object\n    return target;\n};\n```\n这个方法是jQuery中重要的基础方法之一，可以用来扩展jQuery对象及其原型，也是我们编写jQuery插件的关键方法，事实上这个方法基本的思路就是如果碰到array或者object的属性，那么就执行递归复制，这也导致对于Date,Function等引用类型，jQuery的extend也无法支持。下面我们大致分析一下这个方法：\n\n（1）第1-6行定义了一些局部变量，这些局部变量将在以后用到，这种将函数中可能用到的局部变量先统一定义好的方式也就是“单var”模式\n\n（2）第9-13行用来修正deep参数，jQuery的这个方法是将deep作为第一个参数传递的，因此这里就判断了第一个参数是不是boolean类型，如果是，那么就调整target和i值，i值表示第一个source对象的索引\n\n（3）第17-19行修正了target对象，如果target的typeof操作符返回的不是对象，也不是函数，那么说明target传入的是一个基本类型，因此需要修正为一个空的对象字面量{}\n\n（4）第22-25行来处理只传入了一个参数的情况，这个方法在传入一个参数的情况下为扩展jQuery对象或者其原型对象\n\n（5）从27行开始使用for in去遍历source对象列表，因为extend方法是可以传入多个source对象，取出每一个source对象，然后再嵌套一个for in循环，去遍历某个source对象的属性\n\n（6）第32行分别取出了target的当前属性和source的当前属性，35-38行的主要作用在于防止深度遍历时的死循环。然而如果source对象本身存在循环引用的话，extend方法依然会报堆栈溢出的错误\n\n（7）第41行的if用来处理深复制的情况，如果传入的deep参数为true，并且当前的source属性值是plainObject(使用对象字面量创建的对象或new Object()创建的对象)或数组，则需要进行递归深复制\n\n（8）第42-48根据copy的类型是plainObject还是Array，对src进行处理：如果copy是数组，那么src如果不是数组，就改写为一个空数组；如果copy是chainObject，那么src如果不是chainObject，就改写为{}\n\n（9）如果41行的if条件不成立，那么直接把target的src属性用copy覆盖\n\njQuery的extend方法使用基本的递归思路实现了深度复制，但是这个方法也无法处理source对象内部循环引用的问题，同时对于Date、Function等类型的值也没有实现真正的深度复制，但是这些类型的值在重新定义时一般都是直接覆盖，所以也不会对源对象造成影响，因此一定程度上也符合深复制的条件\n\n- (2) 自己实现一个copy方法\n```\n//util作为判断变量具体类型的辅助模块\n   var util = (function(){\n       var class2type = {};\n       [\"Null\",\"Undefined\",\"Number\",\"Boolean\",\"String\",\"Object\",\"Function\",\"Array\",\"RegExp\",\"Date\"].forEach(function(item){\n           class2type[\"[object \"+ item + \"]\"] = item.toLowerCase();\n       })\n\n       function isType(obj, type){\n           return getType(obj) === type;\n       }\n       function getType(obj){\n           return class2type[Object.prototype.toString.call(obj)] || \"object\";\n       }\n       return {\n           isType:isType,\n           getType:getType\n       }\n   })();\n\n   function copy(obj,deep){\n        //如果obj不是对象，那么直接返回值就可以了\n       if(obj === null || typeof obj !== \"object\"){\n           return obj;\n       }\n　　　　//定义需要的局部变脸，根据obj的类型来调整target的类型\n       var i, target = util.isType(obj,\"array\") ? [] : {},value,valueType;\n       for(i in obj){ value = obj[i];\n           valueType = util.getType(value);\n　　　　　　　//只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制\n           if(deep && (valueType === \"array\" || valueType === \"object\")){\n               target[i] = copy(value);\n           }else{\n               target[i] = value;\n           }\n       }\n       return target;\n   }\n```\n\n原文：\n1. [快速浅拷贝一个数组](https://blog.csdn.net/yiifaa/article/details/73438088)\n2. https://www.zhihu.com/question/23031215\n3. [推荐！](https://www.cnblogs.com/tracylin/p/5346314.html)\n4. [JavaScript复制（合并）对象](https://segmentfault.com/a/1190000011492291)\n","source":"_posts/数组与对象的深浅拷贝.md","raw":"title: 对象与数组的深浅拷贝\ndate: 2018/06/13\ncategories: 前端基础\ntoc: true\ntags:\n  - Javascript\n---\n<img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\" style=\"width:56%\"></img>\n\n\n使用场景：\n\n引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。\n\n当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作\n<!--more-->\n\n## Javascript中的深拷贝与浅拷贝为什么会有区别？\n对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。\n\n首先了解一些javascript的基本知识。\n### 1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。\n**基本类型** 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：\n\nnumber、string、boolean、null、undefined、symbol\n\n**引用类型** 值指那些可能由多个值构成的对象，只有一种如下：\n\nobject（Array也属于对象）\n\n在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。\n引用类型的值是保存在内存中的对象。与其他语言不同，**JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。**\n### 2.javascript的变量的存储方式--栈（stack）和堆（heap）\n**栈** ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址\n**堆** ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。\n<img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\"></img>\n### 3.javascript值传递与址传递\n基本类型与引用类型最大的区别实际就是 **传值与传址的区别**\n值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。\n址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。\n\n所以当\n```\nvar obj={};\nvar newObj=obj;\nnewObj={\"name\":\"shengyu\"}\n```\n时候，打印出obj的值，会发现obj的值与newObj一起被修改了\n\n那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。\n\n## 什么是深拷贝/浅拷贝？\n浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，**彼此之间的操作会互相影响**。\n深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 **是完全隔离的**。\n由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 **保证复制的对象与源对象完全隔离** 。然而，*还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深*。\n\n\n## 如何对常见引用类型进行深/浅拷贝？\n*本文认为，浅复制就是简单的引用复制，这种情况较很简单，通过如下代码简单理解一下*\n```\nvar src = {\n       name:\"src\"\n   }\n   //复制一份src对象的应用\n   var target = src;\n   target.name = \"target\";\n   console.log(src.name);   //输出 \"target\"\n```\ntarget对象只是src对象的引用值的复制，因此target的改变也会影响src。\n\n### 数组\n#### 数组的浅拷贝\n- 拷贝原数组的引用，这是最简单的浅拷贝。\n\n#### 数组的深拷贝\n- Array的slice和concat方法\n\nArray的slice和concat方法都会返回一个新的数组实例，但是这两个方法 **对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制**，通过以下代码进行理解：\nconcat和slice返回的不同的数组实例，这与直接的引用复制是不同的。\n\n```\nvar o1 = ['darko', {age: 22}];\nvar o2 = o1.slice(); // 根据Array.prototype.slice()的特性，这里会返回一个o1的深拷贝对象\n\nconsole.log(o1 === o2); // => false，说明o2拷贝的是o1的一个实例\n\no2[0] = 'lee';\nconsole.log(o1[0]); // => \"darko\" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响\n\no2[1].age = 23;\nconsole.log(o1[1].age); // =>23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响，属于浅拷贝\n```\n\n通过代码的输出可以看出concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。\n\n\n### 对象\n#### 对象的浅拷贝\n- 拷贝原对象的引用，这是最简单的浅拷贝。\n\n#### 对象的深拷贝\n- (1) JSON对象的parse和stringify\nJSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深复制\n\n```\nvar source = {\n    name:\"source\",\n    child:{\n        name:\"child\"\n    }\n}\nvar target = JSON.parse(JSON.stringify(source));\n//改变target的name属性\ntarget.name = \"target\";\nconsole.log(source.name);   //source\nconsole.log(target.name);   //target\n//改变target的child\ntarget.child.name = \"target child\";\nconsole.log(source.child.name);  //child\nconsole.log(target.child.name);  //target child\n```\n从代码的输出可以看出，复制后的target与source是完全隔离的，二者不会相互影响。\n*这个方法使用较为简单，可以满足基本的深复制需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深复制(而且会直接丢失相应的值)，同时如果对象中存在循环引用的情况也无法正确处理*\n\n- jQuery中的extend方法可以用来扩展对象，这个方法可以传入一个参数:deep(true or false)，表示是否执行深复制(如果是深复制则会执行递归复制)，我们首先看一下jquery中的源码(1.9.1)\n```\njQuery.extend = jQuery.fn.extend = function() {\n    var options, name, src, copy, copyIsArray, clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n    // Handle a deep copy situation\n    if ( typeof target === \"boolean\" ) {\n        deep = target;\n        target = arguments[1] || {};\n        // skip the boolean and the target\n        i = 2;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n        target = {};\n    }\n\n    // extend jQuery itself if only one argument is passed\n    if ( length === i ) {\n        target = this;\n        --i;\n    }\n\n    for ( ; i < length; i++ ) {\n        // Only deal with non-null/undefined values\n        if ( (options = arguments[ i ]) != null ) {\n            // Extend the base object\n            for ( name in options ) {\n                src = target[ name ];\n                copy = options[ name ];\n\n                // Prevent never-ending loop\n                if ( target === copy ) {\n                    continue;\n                }\n\n                // Recurse if we're merging plain objects or arrays\n                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n                    if ( copyIsArray ) {\n                        copyIsArray = false;\n                        clone = src && jQuery.isArray(src) ? src : [];\n\n                    } else {\n                        clone = src && jQuery.isPlainObject(src) ? src : {};\n                    }\n\n                    // Never move original objects, clone them\n                    target[ name ] = jQuery.extend( deep, clone, copy );\n\n                // Don't bring in undefined values\n                } else if ( copy !== undefined ) {\n                    target[ name ] = copy;\n                }\n            }\n        }\n    }\n\n    // Return the modified object\n    return target;\n};\n```\n这个方法是jQuery中重要的基础方法之一，可以用来扩展jQuery对象及其原型，也是我们编写jQuery插件的关键方法，事实上这个方法基本的思路就是如果碰到array或者object的属性，那么就执行递归复制，这也导致对于Date,Function等引用类型，jQuery的extend也无法支持。下面我们大致分析一下这个方法：\n\n（1）第1-6行定义了一些局部变量，这些局部变量将在以后用到，这种将函数中可能用到的局部变量先统一定义好的方式也就是“单var”模式\n\n（2）第9-13行用来修正deep参数，jQuery的这个方法是将deep作为第一个参数传递的，因此这里就判断了第一个参数是不是boolean类型，如果是，那么就调整target和i值，i值表示第一个source对象的索引\n\n（3）第17-19行修正了target对象，如果target的typeof操作符返回的不是对象，也不是函数，那么说明target传入的是一个基本类型，因此需要修正为一个空的对象字面量{}\n\n（4）第22-25行来处理只传入了一个参数的情况，这个方法在传入一个参数的情况下为扩展jQuery对象或者其原型对象\n\n（5）从27行开始使用for in去遍历source对象列表，因为extend方法是可以传入多个source对象，取出每一个source对象，然后再嵌套一个for in循环，去遍历某个source对象的属性\n\n（6）第32行分别取出了target的当前属性和source的当前属性，35-38行的主要作用在于防止深度遍历时的死循环。然而如果source对象本身存在循环引用的话，extend方法依然会报堆栈溢出的错误\n\n（7）第41行的if用来处理深复制的情况，如果传入的deep参数为true，并且当前的source属性值是plainObject(使用对象字面量创建的对象或new Object()创建的对象)或数组，则需要进行递归深复制\n\n（8）第42-48根据copy的类型是plainObject还是Array，对src进行处理：如果copy是数组，那么src如果不是数组，就改写为一个空数组；如果copy是chainObject，那么src如果不是chainObject，就改写为{}\n\n（9）如果41行的if条件不成立，那么直接把target的src属性用copy覆盖\n\njQuery的extend方法使用基本的递归思路实现了深度复制，但是这个方法也无法处理source对象内部循环引用的问题，同时对于Date、Function等类型的值也没有实现真正的深度复制，但是这些类型的值在重新定义时一般都是直接覆盖，所以也不会对源对象造成影响，因此一定程度上也符合深复制的条件\n\n- (2) 自己实现一个copy方法\n```\n//util作为判断变量具体类型的辅助模块\n   var util = (function(){\n       var class2type = {};\n       [\"Null\",\"Undefined\",\"Number\",\"Boolean\",\"String\",\"Object\",\"Function\",\"Array\",\"RegExp\",\"Date\"].forEach(function(item){\n           class2type[\"[object \"+ item + \"]\"] = item.toLowerCase();\n       })\n\n       function isType(obj, type){\n           return getType(obj) === type;\n       }\n       function getType(obj){\n           return class2type[Object.prototype.toString.call(obj)] || \"object\";\n       }\n       return {\n           isType:isType,\n           getType:getType\n       }\n   })();\n\n   function copy(obj,deep){\n        //如果obj不是对象，那么直接返回值就可以了\n       if(obj === null || typeof obj !== \"object\"){\n           return obj;\n       }\n　　　　//定义需要的局部变脸，根据obj的类型来调整target的类型\n       var i, target = util.isType(obj,\"array\") ? [] : {},value,valueType;\n       for(i in obj){ value = obj[i];\n           valueType = util.getType(value);\n　　　　　　　//只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制\n           if(deep && (valueType === \"array\" || valueType === \"object\")){\n               target[i] = copy(value);\n           }else{\n               target[i] = value;\n           }\n       }\n       return target;\n   }\n```\n\n原文：\n1. [快速浅拷贝一个数组](https://blog.csdn.net/yiifaa/article/details/73438088)\n2. https://www.zhihu.com/question/23031215\n3. [推荐！](https://www.cnblogs.com/tracylin/p/5346314.html)\n4. [JavaScript复制（合并）对象](https://segmentfault.com/a/1190000011492291)\n","slug":"数组与对象的深浅拷贝","published":1,"updated":"2018-06-13T12:22:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjihkbv4h000pka0tr7sgyok5","content":"<p><img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\" style=\"width:56%\"></p>\n<p>使用场景：</p>\n<p>引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。</p>\n<p>当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作<br><a id=\"more\"></a></p>\n<h2 id=\"Javascript中的深拷贝与浅拷贝为什么会有区别？\"><a href=\"#Javascript中的深拷贝与浅拷贝为什么会有区别？\" class=\"headerlink\" title=\"Javascript中的深拷贝与浅拷贝为什么会有区别？\"></a>Javascript中的深拷贝与浅拷贝为什么会有区别？</h2><p>对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。</p>\n<p>首先了解一些javascript的基本知识。</p>\n<h3 id=\"1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。\"><a href=\"#1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。\" class=\"headerlink\" title=\"1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。\"></a>1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。</h3><p><strong>基本类型</strong> 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：</p>\n<p>number、string、boolean、null、undefined、symbol</p>\n<p><strong>引用类型</strong> 值指那些可能由多个值构成的对象，只有一种如下：</p>\n<p>object（Array也属于对象）</p>\n<p>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br>引用类型的值是保存在内存中的对象。与其他语言不同，<strong>JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。</strong></p>\n<h3 id=\"2-javascript的变量的存储方式–栈（stack）和堆（heap）\"><a href=\"#2-javascript的变量的存储方式–栈（stack）和堆（heap）\" class=\"headerlink\" title=\"2.javascript的变量的存储方式–栈（stack）和堆（heap）\"></a>2.javascript的变量的存储方式–栈（stack）和堆（heap）</h3><p><strong>栈</strong> ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址<br><strong>堆</strong> ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。<br><img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\"></p>\n<h3 id=\"3-javascript值传递与址传递\"><a href=\"#3-javascript值传递与址传递\" class=\"headerlink\" title=\"3.javascript值传递与址传递\"></a>3.javascript值传递与址传递</h3><p>基本类型与引用类型最大的区别实际就是 <strong>传值与传址的区别</strong><br>值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。<br>址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。</p>\n<p>所以当<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var obj</span>=&#123;&#125;;</span><br><span class=\"line\"><span class=\"attribute\">var newObj</span>=obj;</span><br><span class=\"line\"><span class=\"attribute\">newObj</span>=&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"shengyu\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时候，打印出obj的值，会发现obj的值与newObj一起被修改了</p>\n<p>那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。</p>\n<h2 id=\"什么是深拷贝-浅拷贝？\"><a href=\"#什么是深拷贝-浅拷贝？\" class=\"headerlink\" title=\"什么是深拷贝/浅拷贝？\"></a>什么是深拷贝/浅拷贝？</h2><p>浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，<strong>彼此之间的操作会互相影响</strong>。<br>深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 <strong>是完全隔离的</strong>。<br>由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 <strong>保证复制的对象与源对象完全隔离</strong> 。然而，<em>还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深</em>。</p>\n<h2 id=\"如何对常见引用类型进行深-浅拷贝？\"><a href=\"#如何对常见引用类型进行深-浅拷贝？\" class=\"headerlink\" title=\"如何对常见引用类型进行深/浅拷贝？\"></a>如何对常见引用类型进行深/浅拷贝？</h2><p><em>本文认为，浅复制就是简单的引用复制，这种情况较很简单，通过如下代码简单理解一下</em><br><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var src = &#123;</span><br><span class=\"line\">       <span class=\"built_in\">name</span>:<span class=\"string\">\"src\"</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//复制一份src对象的应用</span></span><br><span class=\"line\">   var target = src;</span><br><span class=\"line\">   target.<span class=\"built_in\">name</span> = <span class=\"string\">\"target\"</span>;</span><br><span class=\"line\">   console.<span class=\"built_in\">log</span>(src.<span class=\"built_in\">name</span>);   <span class=\"comment\">//输出 \"target\"</span></span><br></pre></td></tr></table></figure></p>\n<p>target对象只是src对象的引用值的复制，因此target的改变也会影响src。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h4 id=\"数组的浅拷贝\"><a href=\"#数组的浅拷贝\" class=\"headerlink\" title=\"数组的浅拷贝\"></a>数组的浅拷贝</h4><ul>\n<li>拷贝原数组的引用，这是最简单的浅拷贝。</li>\n</ul>\n<h4 id=\"数组的深拷贝\"><a href=\"#数组的深拷贝\" class=\"headerlink\" title=\"数组的深拷贝\"></a>数组的深拷贝</h4><ul>\n<li>Array的slice和concat方法</li>\n</ul>\n<p>Array的slice和concat方法都会返回一个新的数组实例，但是这两个方法 <strong>对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制</strong>，通过以下代码进行理解：<br>concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o1 = [<span class=\"string\">'darko'</span>, &#123;<span class=\"attr\">age</span>: <span class=\"number\">22</span>&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = o1.slice(); <span class=\"comment\">// 根据Array.prototype.slice()的特性，这里会返回一个o1的深拷贝对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1 === o2); <span class=\"comment\">// =&gt; false，说明o2拷贝的是o1的一个实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">o2[<span class=\"number\">0</span>] = <span class=\"string\">'lee'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1[<span class=\"number\">0</span>]); <span class=\"comment\">// =&gt; \"darko\" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响</span></span><br><span class=\"line\"></span><br><span class=\"line\">o2[<span class=\"number\">1</span>].age = <span class=\"number\">23</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1[<span class=\"number\">1</span>].age); <span class=\"comment\">// =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响，属于浅拷贝</span></span><br></pre></td></tr></table></figure>\n<p>通过代码的输出可以看出concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><h4 id=\"对象的浅拷贝\"><a href=\"#对象的浅拷贝\" class=\"headerlink\" title=\"对象的浅拷贝\"></a>对象的浅拷贝</h4><ul>\n<li>拷贝原对象的引用，这是最简单的浅拷贝。</li>\n</ul>\n<h4 id=\"对象的深拷贝\"><a href=\"#对象的深拷贝\" class=\"headerlink\" title=\"对象的深拷贝\"></a>对象的深拷贝</h4><ul>\n<li>(1) JSON对象的parse和stringify<br>JSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深复制</li>\n</ul>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var source = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">name</span>:<span class=\"string\">\"source\"</span>,</span><br><span class=\"line\">    child:&#123;</span><br><span class=\"line\">        <span class=\"keyword\">name</span>:<span class=\"string\">\"child\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"keyword\">target</span> = JSON.parse(JSON.stringify(source));</span><br><span class=\"line\">//改变<span class=\"keyword\">target</span>的<span class=\"keyword\">name</span>属性</span><br><span class=\"line\"><span class=\"keyword\">target</span>.<span class=\"keyword\">name</span> = <span class=\"string\">\"target\"</span>;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(source.<span class=\"keyword\">name</span>);   //source</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">target</span>.<span class=\"keyword\">name</span>);   //<span class=\"keyword\">target</span></span><br><span class=\"line\">//改变<span class=\"keyword\">target</span>的child</span><br><span class=\"line\"><span class=\"keyword\">target</span>.child.<span class=\"keyword\">name</span> = <span class=\"string\">\"target child\"</span>;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(source.child.<span class=\"keyword\">name</span>);  //child</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">target</span>.child.<span class=\"keyword\">name</span>);  //<span class=\"keyword\">target</span> child</span><br></pre></td></tr></table></figure>\n<p>从代码的输出可以看出，复制后的target与source是完全隔离的，二者不会相互影响。<br><em>这个方法使用较为简单，可以满足基本的深复制需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深复制(而且会直接丢失相应的值)，同时如果对象中存在循环引用的情况也无法正确处理</em></p>\n<ul>\n<li>jQuery中的extend方法可以用来扩展对象，这个方法可以传入一个参数:deep(true or false)，表示是否执行深复制(如果是深复制则会执行递归复制)，我们首先看一下jquery中的源码(1.9.1)<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.extend = jQuery.fn.extend = function() &#123;</span><br><span class=\"line\">    var <span class=\"keyword\">options</span>, name, src, <span class=\"keyword\">copy</span>, copyIsArray, clone,</span><br><span class=\"line\">        target = arguments[<span class=\"number\">0</span>] || &#123;&#125;,</span><br><span class=\"line\">        i = <span class=\"number\">1</span>,</span><br><span class=\"line\">        length = arguments.length,</span><br><span class=\"line\">        deep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Handle a deep copy situation</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( typeof target === <span class=\"string\">\"boolean\"</span> ) &#123;</span><br><span class=\"line\">        deep = target;</span><br><span class=\"line\">        target = arguments[<span class=\"number\">1</span>] || &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">// skip the boolean and the target</span></span><br><span class=\"line\">        i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Handle case when target is a string or something (possible in deep copy)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( typeof target !== <span class=\"string\">\"object\"</span> &amp;&amp; !jQuery.isFunction(target) ) &#123;</span><br><span class=\"line\">        target = &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// extend jQuery itself if only one argument is passed</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( length === i ) &#123;</span><br><span class=\"line\">        target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        --i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; i &lt; length; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Only deal with non-null/undefined values</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (<span class=\"keyword\">options</span> = arguments[ i ]) != <span class=\"keyword\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Extend the base object</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( name in <span class=\"keyword\">options</span> ) &#123;</span><br><span class=\"line\">                src = target[ name ];</span><br><span class=\"line\">                <span class=\"keyword\">copy</span> = <span class=\"keyword\">options</span>[ name ];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Prevent never-ending loop</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( target === <span class=\"keyword\">copy</span> ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Recurse if we're merging plain objects or arrays</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( deep &amp;&amp; <span class=\"keyword\">copy</span> &amp;&amp; ( jQuery.isPlainObject(<span class=\"keyword\">copy</span>) || (copyIsArray = jQuery.isArray(<span class=\"keyword\">copy</span>)) ) ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( copyIsArray ) &#123;</span><br><span class=\"line\">                        copyIsArray = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Never move original objects, clone them</span></span><br><span class=\"line\">                    target[ name ] = jQuery.extend( deep, clone, <span class=\"keyword\">copy</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Don't bring in undefined values</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( <span class=\"keyword\">copy</span> !== undefined ) &#123;</span><br><span class=\"line\">                    target[ name ] = <span class=\"keyword\">copy</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Return the modified object</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个方法是jQuery中重要的基础方法之一，可以用来扩展jQuery对象及其原型，也是我们编写jQuery插件的关键方法，事实上这个方法基本的思路就是如果碰到array或者object的属性，那么就执行递归复制，这也导致对于Date,Function等引用类型，jQuery的extend也无法支持。下面我们大致分析一下这个方法：</p>\n<p>（1）第1-6行定义了一些局部变量，这些局部变量将在以后用到，这种将函数中可能用到的局部变量先统一定义好的方式也就是“单var”模式</p>\n<p>（2）第9-13行用来修正deep参数，jQuery的这个方法是将deep作为第一个参数传递的，因此这里就判断了第一个参数是不是boolean类型，如果是，那么就调整target和i值，i值表示第一个source对象的索引</p>\n<p>（3）第17-19行修正了target对象，如果target的typeof操作符返回的不是对象，也不是函数，那么说明target传入的是一个基本类型，因此需要修正为一个空的对象字面量{}</p>\n<p>（4）第22-25行来处理只传入了一个参数的情况，这个方法在传入一个参数的情况下为扩展jQuery对象或者其原型对象</p>\n<p>（5）从27行开始使用for in去遍历source对象列表，因为extend方法是可以传入多个source对象，取出每一个source对象，然后再嵌套一个for in循环，去遍历某个source对象的属性</p>\n<p>（6）第32行分别取出了target的当前属性和source的当前属性，35-38行的主要作用在于防止深度遍历时的死循环。然而如果source对象本身存在循环引用的话，extend方法依然会报堆栈溢出的错误</p>\n<p>（7）第41行的if用来处理深复制的情况，如果传入的deep参数为true，并且当前的source属性值是plainObject(使用对象字面量创建的对象或new Object()创建的对象)或数组，则需要进行递归深复制</p>\n<p>（8）第42-48根据copy的类型是plainObject还是Array，对src进行处理：如果copy是数组，那么src如果不是数组，就改写为一个空数组；如果copy是chainObject，那么src如果不是chainObject，就改写为{}</p>\n<p>（9）如果41行的if条件不成立，那么直接把target的src属性用copy覆盖</p>\n<p>jQuery的extend方法使用基本的递归思路实现了深度复制，但是这个方法也无法处理source对象内部循环引用的问题，同时对于Date、Function等类型的值也没有实现真正的深度复制，但是这些类型的值在重新定义时一般都是直接覆盖，所以也不会对源对象造成影响，因此一定程度上也符合深复制的条件</p>\n<ul>\n<li>(2) 自己实现一个copy方法<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//util作为判断变量具体类型的辅助模块</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> util = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">var</span> class2type = &#123;&#125;;</span><br><span class=\"line\">       [<span class=\"string\">\"Null\"</span>,<span class=\"string\">\"Undefined\"</span>,<span class=\"string\">\"Number\"</span>,<span class=\"string\">\"Boolean\"</span>,<span class=\"string\">\"String\"</span>,<span class=\"string\">\"Object\"</span>,<span class=\"string\">\"Function\"</span>,<span class=\"string\">\"Array\"</span>,<span class=\"string\">\"RegExp\"</span>,<span class=\"string\">\"Date\"</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">           class2type[<span class=\"string\">\"[object \"</span>+ item + <span class=\"string\">\"]\"</span>] = item.toLowerCase();</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isType</span>(<span class=\"params\">obj, type</span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> getType(obj) === type;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getType</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> class2type[<span class=\"built_in\">Object</span>.prototype.toString.call(obj)] || <span class=\"string\">\"object\"</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">           isType:isType,</span><br><span class=\"line\">           getType:getType</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\">obj,deep</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果obj不是对象，那么直接返回值就可以了</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(obj === <span class=\"literal\">null</span> || <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">\"object\"</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">　　　　<span class=\"comment\">//定义需要的局部变脸，根据obj的类型来调整target的类型</span></span><br><span class=\"line\">       <span class=\"keyword\">var</span> i, target = util.isType(obj,<span class=\"string\">\"array\"</span>) ? [] : &#123;&#125;,value,valueType;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(i <span class=\"keyword\">in</span> obj)&#123; value = obj[i];</span><br><span class=\"line\">           valueType = util.getType(value);</span><br><span class=\"line\">　　　　　　　<span class=\"comment\">//只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(deep &amp;&amp; (valueType === <span class=\"string\">\"array\"</span> || valueType === <span class=\"string\">\"object\"</span>))&#123;</span><br><span class=\"line\">               target[i] = copy(value);</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               target[i] = value;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>原文：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/yiifaa/article/details/73438088\" target=\"_blank\" rel=\"noopener\">快速浅拷贝一个数组</a></li>\n<li><a href=\"https://www.zhihu.com/question/23031215\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/23031215</a></li>\n<li><a href=\"https://www.cnblogs.com/tracylin/p/5346314.html\" target=\"_blank\" rel=\"noopener\">推荐！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011492291\" target=\"_blank\" rel=\"noopener\">JavaScript复制（合并）对象</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\" style=\"width:56%\"></p>\n<p>使用场景：</p>\n<p>引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。</p>\n<p>当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作<br>","more":"</p>\n<h2 id=\"Javascript中的深拷贝与浅拷贝为什么会有区别？\"><a href=\"#Javascript中的深拷贝与浅拷贝为什么会有区别？\" class=\"headerlink\" title=\"Javascript中的深拷贝与浅拷贝为什么会有区别？\"></a>Javascript中的深拷贝与浅拷贝为什么会有区别？</h2><p>对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。</p>\n<p>首先了解一些javascript的基本知识。</p>\n<h3 id=\"1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。\"><a href=\"#1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。\" class=\"headerlink\" title=\"1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。\"></a>1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。</h3><p><strong>基本类型</strong> 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：</p>\n<p>number、string、boolean、null、undefined、symbol</p>\n<p><strong>引用类型</strong> 值指那些可能由多个值构成的对象，只有一种如下：</p>\n<p>object（Array也属于对象）</p>\n<p>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br>引用类型的值是保存在内存中的对象。与其他语言不同，<strong>JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。</strong></p>\n<h3 id=\"2-javascript的变量的存储方式–栈（stack）和堆（heap）\"><a href=\"#2-javascript的变量的存储方式–栈（stack）和堆（heap）\" class=\"headerlink\" title=\"2.javascript的变量的存储方式–栈（stack）和堆（heap）\"></a>2.javascript的变量的存储方式–栈（stack）和堆（heap）</h3><p><strong>栈</strong> ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址<br><strong>堆</strong> ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。<br><img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\"></p>\n<h3 id=\"3-javascript值传递与址传递\"><a href=\"#3-javascript值传递与址传递\" class=\"headerlink\" title=\"3.javascript值传递与址传递\"></a>3.javascript值传递与址传递</h3><p>基本类型与引用类型最大的区别实际就是 <strong>传值与传址的区别</strong><br>值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。<br>址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。</p>\n<p>所以当<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var obj</span>=&#123;&#125;;</span><br><span class=\"line\"><span class=\"attribute\">var newObj</span>=obj;</span><br><span class=\"line\"><span class=\"attribute\">newObj</span>=&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"shengyu\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时候，打印出obj的值，会发现obj的值与newObj一起被修改了</p>\n<p>那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。</p>\n<h2 id=\"什么是深拷贝-浅拷贝？\"><a href=\"#什么是深拷贝-浅拷贝？\" class=\"headerlink\" title=\"什么是深拷贝/浅拷贝？\"></a>什么是深拷贝/浅拷贝？</h2><p>浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，<strong>彼此之间的操作会互相影响</strong>。<br>深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 <strong>是完全隔离的</strong>。<br>由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 <strong>保证复制的对象与源对象完全隔离</strong> 。然而，<em>还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深</em>。</p>\n<h2 id=\"如何对常见引用类型进行深-浅拷贝？\"><a href=\"#如何对常见引用类型进行深-浅拷贝？\" class=\"headerlink\" title=\"如何对常见引用类型进行深/浅拷贝？\"></a>如何对常见引用类型进行深/浅拷贝？</h2><p><em>本文认为，浅复制就是简单的引用复制，这种情况较很简单，通过如下代码简单理解一下</em><br><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var src = &#123;</span><br><span class=\"line\">       <span class=\"built_in\">name</span>:<span class=\"string\">\"src\"</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//复制一份src对象的应用</span></span><br><span class=\"line\">   var target = src;</span><br><span class=\"line\">   target.<span class=\"built_in\">name</span> = <span class=\"string\">\"target\"</span>;</span><br><span class=\"line\">   console.<span class=\"built_in\">log</span>(src.<span class=\"built_in\">name</span>);   <span class=\"comment\">//输出 \"target\"</span></span><br></pre></td></tr></table></figure></p>\n<p>target对象只是src对象的引用值的复制，因此target的改变也会影响src。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h4 id=\"数组的浅拷贝\"><a href=\"#数组的浅拷贝\" class=\"headerlink\" title=\"数组的浅拷贝\"></a>数组的浅拷贝</h4><ul>\n<li>拷贝原数组的引用，这是最简单的浅拷贝。</li>\n</ul>\n<h4 id=\"数组的深拷贝\"><a href=\"#数组的深拷贝\" class=\"headerlink\" title=\"数组的深拷贝\"></a>数组的深拷贝</h4><ul>\n<li>Array的slice和concat方法</li>\n</ul>\n<p>Array的slice和concat方法都会返回一个新的数组实例，但是这两个方法 <strong>对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制</strong>，通过以下代码进行理解：<br>concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o1 = [<span class=\"string\">'darko'</span>, &#123;<span class=\"attr\">age</span>: <span class=\"number\">22</span>&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = o1.slice(); <span class=\"comment\">// 根据Array.prototype.slice()的特性，这里会返回一个o1的深拷贝对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1 === o2); <span class=\"comment\">// =&gt; false，说明o2拷贝的是o1的一个实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">o2[<span class=\"number\">0</span>] = <span class=\"string\">'lee'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1[<span class=\"number\">0</span>]); <span class=\"comment\">// =&gt; \"darko\" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响</span></span><br><span class=\"line\"></span><br><span class=\"line\">o2[<span class=\"number\">1</span>].age = <span class=\"number\">23</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1[<span class=\"number\">1</span>].age); <span class=\"comment\">// =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响，属于浅拷贝</span></span><br></pre></td></tr></table></figure>\n<p>通过代码的输出可以看出concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><h4 id=\"对象的浅拷贝\"><a href=\"#对象的浅拷贝\" class=\"headerlink\" title=\"对象的浅拷贝\"></a>对象的浅拷贝</h4><ul>\n<li>拷贝原对象的引用，这是最简单的浅拷贝。</li>\n</ul>\n<h4 id=\"对象的深拷贝\"><a href=\"#对象的深拷贝\" class=\"headerlink\" title=\"对象的深拷贝\"></a>对象的深拷贝</h4><ul>\n<li>(1) JSON对象的parse和stringify<br>JSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深复制</li>\n</ul>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var source = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">name</span>:<span class=\"string\">\"source\"</span>,</span><br><span class=\"line\">    child:&#123;</span><br><span class=\"line\">        <span class=\"keyword\">name</span>:<span class=\"string\">\"child\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var <span class=\"keyword\">target</span> = JSON.parse(JSON.stringify(source));</span><br><span class=\"line\">//改变<span class=\"keyword\">target</span>的<span class=\"keyword\">name</span>属性</span><br><span class=\"line\"><span class=\"keyword\">target</span>.<span class=\"keyword\">name</span> = <span class=\"string\">\"target\"</span>;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(source.<span class=\"keyword\">name</span>);   //source</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">target</span>.<span class=\"keyword\">name</span>);   //<span class=\"keyword\">target</span></span><br><span class=\"line\">//改变<span class=\"keyword\">target</span>的child</span><br><span class=\"line\"><span class=\"keyword\">target</span>.child.<span class=\"keyword\">name</span> = <span class=\"string\">\"target child\"</span>;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(source.child.<span class=\"keyword\">name</span>);  //child</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">target</span>.child.<span class=\"keyword\">name</span>);  //<span class=\"keyword\">target</span> child</span><br></pre></td></tr></table></figure>\n<p>从代码的输出可以看出，复制后的target与source是完全隔离的，二者不会相互影响。<br><em>这个方法使用较为简单，可以满足基本的深复制需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深复制(而且会直接丢失相应的值)，同时如果对象中存在循环引用的情况也无法正确处理</em></p>\n<ul>\n<li>jQuery中的extend方法可以用来扩展对象，这个方法可以传入一个参数:deep(true or false)，表示是否执行深复制(如果是深复制则会执行递归复制)，我们首先看一下jquery中的源码(1.9.1)<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.extend = jQuery.fn.extend = function() &#123;</span><br><span class=\"line\">    var <span class=\"keyword\">options</span>, name, src, <span class=\"keyword\">copy</span>, copyIsArray, clone,</span><br><span class=\"line\">        target = arguments[<span class=\"number\">0</span>] || &#123;&#125;,</span><br><span class=\"line\">        i = <span class=\"number\">1</span>,</span><br><span class=\"line\">        length = arguments.length,</span><br><span class=\"line\">        deep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Handle a deep copy situation</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( typeof target === <span class=\"string\">\"boolean\"</span> ) &#123;</span><br><span class=\"line\">        deep = target;</span><br><span class=\"line\">        target = arguments[<span class=\"number\">1</span>] || &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">// skip the boolean and the target</span></span><br><span class=\"line\">        i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Handle case when target is a string or something (possible in deep copy)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( typeof target !== <span class=\"string\">\"object\"</span> &amp;&amp; !jQuery.isFunction(target) ) &#123;</span><br><span class=\"line\">        target = &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// extend jQuery itself if only one argument is passed</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( length === i ) &#123;</span><br><span class=\"line\">        target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        --i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; i &lt; length; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Only deal with non-null/undefined values</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (<span class=\"keyword\">options</span> = arguments[ i ]) != <span class=\"keyword\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Extend the base object</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( name in <span class=\"keyword\">options</span> ) &#123;</span><br><span class=\"line\">                src = target[ name ];</span><br><span class=\"line\">                <span class=\"keyword\">copy</span> = <span class=\"keyword\">options</span>[ name ];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Prevent never-ending loop</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( target === <span class=\"keyword\">copy</span> ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Recurse if we're merging plain objects or arrays</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( deep &amp;&amp; <span class=\"keyword\">copy</span> &amp;&amp; ( jQuery.isPlainObject(<span class=\"keyword\">copy</span>) || (copyIsArray = jQuery.isArray(<span class=\"keyword\">copy</span>)) ) ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( copyIsArray ) &#123;</span><br><span class=\"line\">                        copyIsArray = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Never move original objects, clone them</span></span><br><span class=\"line\">                    target[ name ] = jQuery.extend( deep, clone, <span class=\"keyword\">copy</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Don't bring in undefined values</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( <span class=\"keyword\">copy</span> !== undefined ) &#123;</span><br><span class=\"line\">                    target[ name ] = <span class=\"keyword\">copy</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Return the modified object</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个方法是jQuery中重要的基础方法之一，可以用来扩展jQuery对象及其原型，也是我们编写jQuery插件的关键方法，事实上这个方法基本的思路就是如果碰到array或者object的属性，那么就执行递归复制，这也导致对于Date,Function等引用类型，jQuery的extend也无法支持。下面我们大致分析一下这个方法：</p>\n<p>（1）第1-6行定义了一些局部变量，这些局部变量将在以后用到，这种将函数中可能用到的局部变量先统一定义好的方式也就是“单var”模式</p>\n<p>（2）第9-13行用来修正deep参数，jQuery的这个方法是将deep作为第一个参数传递的，因此这里就判断了第一个参数是不是boolean类型，如果是，那么就调整target和i值，i值表示第一个source对象的索引</p>\n<p>（3）第17-19行修正了target对象，如果target的typeof操作符返回的不是对象，也不是函数，那么说明target传入的是一个基本类型，因此需要修正为一个空的对象字面量{}</p>\n<p>（4）第22-25行来处理只传入了一个参数的情况，这个方法在传入一个参数的情况下为扩展jQuery对象或者其原型对象</p>\n<p>（5）从27行开始使用for in去遍历source对象列表，因为extend方法是可以传入多个source对象，取出每一个source对象，然后再嵌套一个for in循环，去遍历某个source对象的属性</p>\n<p>（6）第32行分别取出了target的当前属性和source的当前属性，35-38行的主要作用在于防止深度遍历时的死循环。然而如果source对象本身存在循环引用的话，extend方法依然会报堆栈溢出的错误</p>\n<p>（7）第41行的if用来处理深复制的情况，如果传入的deep参数为true，并且当前的source属性值是plainObject(使用对象字面量创建的对象或new Object()创建的对象)或数组，则需要进行递归深复制</p>\n<p>（8）第42-48根据copy的类型是plainObject还是Array，对src进行处理：如果copy是数组，那么src如果不是数组，就改写为一个空数组；如果copy是chainObject，那么src如果不是chainObject，就改写为{}</p>\n<p>（9）如果41行的if条件不成立，那么直接把target的src属性用copy覆盖</p>\n<p>jQuery的extend方法使用基本的递归思路实现了深度复制，但是这个方法也无法处理source对象内部循环引用的问题，同时对于Date、Function等类型的值也没有实现真正的深度复制，但是这些类型的值在重新定义时一般都是直接覆盖，所以也不会对源对象造成影响，因此一定程度上也符合深复制的条件</p>\n<ul>\n<li>(2) 自己实现一个copy方法<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//util作为判断变量具体类型的辅助模块</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> util = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">var</span> class2type = &#123;&#125;;</span><br><span class=\"line\">       [<span class=\"string\">\"Null\"</span>,<span class=\"string\">\"Undefined\"</span>,<span class=\"string\">\"Number\"</span>,<span class=\"string\">\"Boolean\"</span>,<span class=\"string\">\"String\"</span>,<span class=\"string\">\"Object\"</span>,<span class=\"string\">\"Function\"</span>,<span class=\"string\">\"Array\"</span>,<span class=\"string\">\"RegExp\"</span>,<span class=\"string\">\"Date\"</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">           class2type[<span class=\"string\">\"[object \"</span>+ item + <span class=\"string\">\"]\"</span>] = item.toLowerCase();</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isType</span>(<span class=\"params\">obj, type</span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> getType(obj) === type;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getType</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> class2type[<span class=\"built_in\">Object</span>.prototype.toString.call(obj)] || <span class=\"string\">\"object\"</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">           isType:isType,</span><br><span class=\"line\">           getType:getType</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\">obj,deep</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果obj不是对象，那么直接返回值就可以了</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(obj === <span class=\"literal\">null</span> || <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">\"object\"</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">　　　　<span class=\"comment\">//定义需要的局部变脸，根据obj的类型来调整target的类型</span></span><br><span class=\"line\">       <span class=\"keyword\">var</span> i, target = util.isType(obj,<span class=\"string\">\"array\"</span>) ? [] : &#123;&#125;,value,valueType;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(i <span class=\"keyword\">in</span> obj)&#123; value = obj[i];</span><br><span class=\"line\">           valueType = util.getType(value);</span><br><span class=\"line\">　　　　　　　<span class=\"comment\">//只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(deep &amp;&amp; (valueType === <span class=\"string\">\"array\"</span> || valueType === <span class=\"string\">\"object\"</span>))&#123;</span><br><span class=\"line\">               target[i] = copy(value);</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               target[i] = value;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>原文：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/yiifaa/article/details/73438088\" target=\"_blank\" rel=\"noopener\">快速浅拷贝一个数组</a></li>\n<li><a href=\"https://www.zhihu.com/question/23031215\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/23031215</a></li>\n<li><a href=\"https://www.cnblogs.com/tracylin/p/5346314.html\" target=\"_blank\" rel=\"noopener\">推荐！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011492291\" target=\"_blank\" rel=\"noopener\">JavaScript复制（合并）对象</a></li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjihkbv2d0001ka0tfk3b2h0d","category_id":"cjihkbv4u000qka0t42zxb62o","_id":"cjihkbv6j0028ka0tjaguk5sm"},{"post_id":"cjihkbv2r0002ka0t7m8vsbjw","category_id":"cjihkbv5e000ska0tgdaw0g3u","_id":"cjihkbv6j002aka0tmbqvoi3q"},{"post_id":"cjihkbv2u0003ka0tyb5km0eh","category_id":"cjihkbv5f000uka0t24vv401j","_id":"cjihkbv6j002cka0teq1bzpb4"},{"post_id":"cjihkbv350005ka0tyvlm6n2j","category_id":"cjihkbv5g000yka0tcgkbb3xo","_id":"cjihkbv6j002eka0tk9fev8pk"},{"post_id":"cjihkbv390006ka0t60f41hfm","category_id":"cjihkbv5g000wka0t64j8yvhv","_id":"cjihkbv6k002gka0txyfcxo13"},{"post_id":"cjihkbv3a0007ka0tw72nbvsc","category_id":"cjihkbv5g000wka0t64j8yvhv","_id":"cjihkbv6k002ika0t76fczlth"},{"post_id":"cjihkbv3e0008ka0txvmcz347","category_id":"cjihkbv5m0014ka0tokg7mko7","_id":"cjihkbv6l002kka0tlrwh8v26"},{"post_id":"cjihkbv3i0009ka0t5qzclws9","category_id":"cjihkbv5g000wka0t64j8yvhv","_id":"cjihkbv6l002mka0tvxegaemh"},{"post_id":"cjihkbv3k000aka0tzje8ocis","category_id":"cjihkbv5e000ska0tgdaw0g3u","_id":"cjihkbv6n002oka0tef2bhr8z"},{"post_id":"cjihkbv3m000bka0tg2xwquzo","category_id":"cjihkbv5g000wka0t64j8yvhv","_id":"cjihkbv6o002qka0th7sjqgyj"},{"post_id":"cjihkbv3n000cka0t7qbgqva2","category_id":"cjihkbv5g000wka0t64j8yvhv","_id":"cjihkbv6o002ska0tenqcddf0"},{"post_id":"cjihkbv3p000dka0tylv3eqef","category_id":"cjihkbv4u000qka0t42zxb62o","_id":"cjihkbv6o002uka0tnp17t52v"},{"post_id":"cjihkbv3t000eka0tipa7ng3n","category_id":"cjihkbv4u000qka0t42zxb62o","_id":"cjihkbv6o002wka0tuhng42wa"},{"post_id":"cjihkbv3w000fka0td41u2mp8","category_id":"cjihkbv4u000qka0t42zxb62o","_id":"cjihkbv6o002yka0tq3vvlt70"},{"post_id":"cjihkbv3z000gka0tyy9p7801","category_id":"cjihkbv4u000qka0t42zxb62o","_id":"cjihkbv6o0030ka0t0paurhjq"},{"post_id":"cjihkbv41000hka0taxpz568c","category_id":"cjihkbv61001mka0t41r85cwe","_id":"cjihkbv6o0032ka0t9fevxpgp"},{"post_id":"cjihkbv43000ika0t2btab4ux","category_id":"cjihkbv4u000qka0t42zxb62o","_id":"cjihkbv6o0034ka0t6vcif2b6"},{"post_id":"cjihkbv44000jka0tdbpzdpq5","category_id":"cjihkbv4u000qka0t42zxb62o","_id":"cjihkbv6p0036ka0tl0x8xtw5"},{"post_id":"cjihkbv49000kka0t5klej4tw","category_id":"cjihkbv4u000qka0t42zxb62o","_id":"cjihkbv6p0038ka0tmkqhndtw"},{"post_id":"cjihkbv4b000lka0t9wm33axn","category_id":"cjihkbv4u000qka0t42zxb62o","_id":"cjihkbv6p003aka0thxcqsp7d"},{"post_id":"cjihkbv4e000mka0t7cp91iu4","category_id":"cjihkbv5e000ska0tgdaw0g3u","_id":"cjihkbv6p003cka0te6da8ql1"},{"post_id":"cjihkbv4f000nka0tvarnri2w","category_id":"cjihkbv69001yka0tc4rnmbkw","_id":"cjihkbv6p003eka0thqa58n23"},{"post_id":"cjihkbv4g000oka0tl8hevego","category_id":"cjihkbv5m0014ka0tokg7mko7","_id":"cjihkbv6p003gka0ta5k6y1b7"},{"post_id":"cjihkbv4h000pka0tr7sgyok5","category_id":"cjihkbv5e000ska0tgdaw0g3u","_id":"cjihkbv6p003ika0t4sh8pz8w"},{"post_id":"cjihkbv300004ka0t05u1vb2h","category_id":"cjihkbv5g000wka0t64j8yvhv","_id":"cjihkbv6x003mka0t8iasinpq"},{"post_id":"cjihkbv300004ka0t05u1vb2h","category_id":"cjihkbv6i0027ka0t3iso0eak","_id":"cjihkbv6y003nka0t3otip6iy"}],"PostTag":[{"post_id":"cjihkbv2d0001ka0tfk3b2h0d","tag_id":"cjihkbv5c000rka0t0hxfpiob","_id":"cjihkbv6i0026ka0tes0u0kq4"},{"post_id":"cjihkbv2r0002ka0t7m8vsbjw","tag_id":"cjihkbv5e000tka0txw4z62b9","_id":"cjihkbv6j0029ka0ted8t949i"},{"post_id":"cjihkbv2u0003ka0tyb5km0eh","tag_id":"cjihkbv5f000vka0thcbbfzd4","_id":"cjihkbv6j002bka0t9sjbpu26"},{"post_id":"cjihkbv300004ka0t05u1vb2h","tag_id":"cjihkbv5g000xka0t2jmrhhar","_id":"cjihkbv6j002dka0temoe119l"},{"post_id":"cjihkbv350005ka0tyvlm6n2j","tag_id":"cjihkbv5h000zka0t17awtdlm","_id":"cjihkbv6k002fka0tzo5hdb29"},{"post_id":"cjihkbv390006ka0t60f41hfm","tag_id":"cjihkbv5i0011ka0t8tj75txj","_id":"cjihkbv6k002hka0teh8ibk3d"},{"post_id":"cjihkbv3a0007ka0tw72nbvsc","tag_id":"cjihkbv5i0011ka0t8tj75txj","_id":"cjihkbv6l002jka0t3d4ol618"},{"post_id":"cjihkbv3e0008ka0txvmcz347","tag_id":"cjihkbv5m0015ka0thmix1wy4","_id":"cjihkbv6l002lka0t1p1ukrue"},{"post_id":"cjihkbv3e0008ka0txvmcz347","tag_id":"cjihkbv5i0011ka0t8tj75txj","_id":"cjihkbv6l002nka0tmu53l6sb"},{"post_id":"cjihkbv3i0009ka0t5qzclws9","tag_id":"cjihkbv5i0011ka0t8tj75txj","_id":"cjihkbv6o002pka0taof746h3"},{"post_id":"cjihkbv3m000bka0tg2xwquzo","tag_id":"cjihkbv5i0011ka0t8tj75txj","_id":"cjihkbv6o002rka0tg2vylig6"},{"post_id":"cjihkbv3n000cka0t7qbgqva2","tag_id":"cjihkbv5s001dka0tbzcfe2sm","_id":"cjihkbv6o002tka0ty08wensp"},{"post_id":"cjihkbv3p000dka0tylv3eqef","tag_id":"cjihkbv5u001fka0t79f5lnow","_id":"cjihkbv6o002vka0txbcp4han"},{"post_id":"cjihkbv3t000eka0tipa7ng3n","tag_id":"cjihkbv5u001fka0t79f5lnow","_id":"cjihkbv6o002xka0t8xw9ib3k"},{"post_id":"cjihkbv3w000fka0td41u2mp8","tag_id":"cjihkbv5z001jka0thw4uoyhd","_id":"cjihkbv6o002zka0t10sugnqr"},{"post_id":"cjihkbv3z000gka0tyy9p7801","tag_id":"cjihkbv60001lka0trg1t4nbf","_id":"cjihkbv6o0031ka0tn95qr7rf"},{"post_id":"cjihkbv3z000gka0tyy9p7801","tag_id":"cjihkbv61001nka0tdweml7s1","_id":"cjihkbv6o0033ka0t5xyrq171"},{"post_id":"cjihkbv41000hka0taxpz568c","tag_id":"cjihkbv62001pka0t89t4p8h2","_id":"cjihkbv6p0035ka0tl9uqw0y2"},{"post_id":"cjihkbv43000ika0t2btab4ux","tag_id":"cjihkbv5z001jka0thw4uoyhd","_id":"cjihkbv6p0037ka0t09gph3uy"},{"post_id":"cjihkbv44000jka0tdbpzdpq5","tag_id":"cjihkbv63001tka0tkog5w5ez","_id":"cjihkbv6p0039ka0tadb5jvfp"},{"post_id":"cjihkbv4b000lka0t9wm33axn","tag_id":"cjihkbv61001nka0tdweml7s1","_id":"cjihkbv6p003bka0tsdlgv3sk"},{"post_id":"cjihkbv4e000mka0t7cp91iu4","tag_id":"cjihkbv5m0015ka0thmix1wy4","_id":"cjihkbv6p003dka0trs60f0v0"},{"post_id":"cjihkbv4e000mka0t7cp91iu4","tag_id":"cjihkbv6a001zka0tezfey17f","_id":"cjihkbv6p003fka0tmspif9y8"},{"post_id":"cjihkbv4e000mka0t7cp91iu4","tag_id":"cjihkbv6b0021ka0t6xfyx7j2","_id":"cjihkbv6p003hka0t2x3jtj8t"},{"post_id":"cjihkbv4e000mka0t7cp91iu4","tag_id":"cjihkbv6d0023ka0t9uihl9w4","_id":"cjihkbv6p003jka0t4fkmtnet"},{"post_id":"cjihkbv4f000nka0tvarnri2w","tag_id":"cjihkbv6f0024ka0t7ux6serj","_id":"cjihkbv6q003kka0tfaza65xk"},{"post_id":"cjihkbv4h000pka0tr7sgyok5","tag_id":"cjihkbv5m0015ka0thmix1wy4","_id":"cjihkbv6q003lka0t6ac383jt"}],"Tag":[{"name":"Sass","_id":"cjihkbv5c000rka0t0hxfpiob"},{"name":"ES6","_id":"cjihkbv5e000tka0txw4z62b9"},{"name":"Jest","_id":"cjihkbv5f000vka0thcbbfzd4"},{"name":"Ramda","_id":"cjihkbv5g000xka0t2jmrhhar"},{"name":"Nodejs","_id":"cjihkbv5h000zka0t17awtdlm"},{"name":"React","_id":"cjihkbv5i0011ka0t8tj75txj"},{"name":"Javascript","_id":"cjihkbv5m0015ka0thmix1wy4"},{"name":"axios","_id":"cjihkbv5s001dka0tbzcfe2sm"},{"name":"git","_id":"cjihkbv5u001fka0t79f5lnow"},{"name":"Hexo","_id":"cjihkbv5z001jka0thw4uoyhd"},{"name":"Less","_id":"cjihkbv60001lka0trg1t4nbf"},{"name":"vscode","_id":"cjihkbv61001nka0tdweml7s1"},{"name":"jQuery源码","_id":"cjihkbv62001pka0t89t4p8h2"},{"name":"mock","_id":"cjihkbv63001tka0tkog5w5ez"},{"name":"HTTP","_id":"cjihkbv6a001zka0tezfey17f"},{"name":"安全","_id":"cjihkbv6b0021ka0t6xfyx7j2"},{"name":"Node","_id":"cjihkbv6d0023ka0t9uihl9w4"},{"name":"函数式编程","_id":"cjihkbv6f0024ka0t7ux6serj"}]}}