title: 对象与数组的深浅拷贝
date: 2018/06/13
categories: 前端基础
toc: true
tags:
  - Javascript
---
<!-- <img src="https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg" style="width:56%"></img> -->


使用场景：

引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。

当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作
<!--more-->

## Javascript中的深拷贝与浅拷贝为什么会有区别？
对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。

首先了解一些javascript的基本知识。
### 1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。
**基本类型** 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：

number、string、boolean、null、undefined、symbol

**引用类型** 值指那些可能由多个值构成的对象，只有一种如下：

object（Array也属于对象）

在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。
引用类型的值是保存在内存中的对象。与其他语言不同，**JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。**
### 2.javascript的变量的存储方式--栈（stack）和堆（heap）
**栈** ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址
**堆** ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。
<!-- <img src="https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg"></img> -->
### 3.javascript值传递与址传递
基本类型与引用类型最大的区别实际就是 **传值与传址的区别**
值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。
址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。

所以当
```
var obj={};
var newObj=obj;
newObj={"name":"shengyu"}
```
时候，打印出obj的值，会发现obj的值与newObj一起被修改了

那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。

## 什么是深拷贝/浅拷贝？
本文认为
浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，**彼此之间的操作会互相影响**。
深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 **是完全隔离的**。
由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 **保证复制的对象与源对象完全隔离** 。然而，*还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深*。


## 如何对常见引用类型进行深/浅拷贝？
*本文认为，浅复制就是简单的引用复制，这种情况较很简单，通过如下代码简单理解一下*
```
var src = {
       name:"src"
   }
   //复制一份src对象的应用
   var target = src;
   target.name = "target";
   console.log(src.name);   //输出 "target"
```
target对象只是src对象的引用值的复制，因此target的改变也会影响src。

### 数组
#### 数组的浅拷贝
- 拷贝原数组的引用，这是最简单的浅拷贝。

#### 数组的深拷贝
- Array的slice和concat方法

Array的slice和concat方法都会返回一个新的数组实例，但是这两个方法 **对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制**，通过以下代码进行理解：
concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。

```
var o1 = ['darko', {age: 22}];
var o2 = o1.slice(); // 根据Array.prototype.slice()的特性，这里会返回一个o1的深拷贝对象

console.log(o1 === o2); // => false，说明o2拷贝的是o1的一个实例

o2[0] = 'lee';
console.log(o1[0]); // => "darko" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响

o2[1].age = 23;
console.log(o1[1].age); // =>23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响，属于浅拷贝
```

通过代码的输出可以看出concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。


### 对象
#### 对象的浅拷贝
- 拷贝原对象的引用，这是最简单的浅拷贝。

#### 对象的深拷贝
- (1) JSON对象的parse和stringify
JSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深复制

```
var source = {
    name:"source",
    child:{
        name:"child"
    }
}
var target = JSON.parse(JSON.stringify(source));
//改变target的name属性
target.name = "target";
console.log(source.name);   //source
console.log(target.name);   //target
//改变target的child
target.child.name = "target child";
console.log(source.child.name);  //child
console.log(target.child.name);  //target child
```
从代码的输出可以看出，复制后的target与source是完全隔离的，二者不会相互影响。
*这个方法使用较为简单，可以满足基本的深复制需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深复制(而且会直接丢失相应的值)，同时如果对象中存在循环引用的情况也无法正确处理*

- jQuery中的extend方法可以用来扩展对象，这个方法可以传入一个参数:deep(true or false)，表示是否执行深复制(如果是深复制则会执行递归复制)，我们首先看一下jquery中的源码(1.9.1)
```
jQuery.extend = jQuery.fn.extend = function() {
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if ( typeof target === "boolean" ) {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
        target = {};
    }

    // extend jQuery itself if only one argument is passed
    if ( length === i ) {
        target = this;
        --i;
    }

    for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
            // Extend the base object
            for ( name in options ) {
                src = target[ name ];
                copy = options[ name ];

                // Prevent never-ending loop
                if ( target === copy ) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    if ( copyIsArray ) {
                        copyIsArray = false;
                        clone = src && jQuery.isArray(src) ? src : [];

                    } else {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[ name ] = jQuery.extend( deep, clone, copy );

                // Don't bring in undefined values
                } else if ( copy !== undefined ) {
                    target[ name ] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};
```
这个方法是jQuery中重要的基础方法之一，可以用来扩展jQuery对象及其原型，也是我们编写jQuery插件的关键方法，事实上这个方法基本的思路就是如果碰到array或者object的属性，那么就执行递归复制，这也导致对于Date,Function等引用类型，jQuery的extend也无法支持。下面我们大致分析一下这个方法：

（1）第1-6行定义了一些局部变量，这些局部变量将在以后用到，这种将函数中可能用到的局部变量先统一定义好的方式也就是“单var”模式

（2）第9-13行用来修正deep参数，jQuery的这个方法是将deep作为第一个参数传递的，因此这里就判断了第一个参数是不是boolean类型，如果是，那么就调整target和i值，i值表示第一个source对象的索引

（3）第17-19行修正了target对象，如果target的typeof操作符返回的不是对象，也不是函数，那么说明target传入的是一个基本类型，因此需要修正为一个空的对象字面量{}

（4）第22-25行来处理只传入了一个参数的情况，这个方法在传入一个参数的情况下为扩展jQuery对象或者其原型对象

（5）从27行开始使用for in去遍历source对象列表，因为extend方法是可以传入多个source对象，取出每一个source对象，然后再嵌套一个for in循环，去遍历某个source对象的属性

（6）第32行分别取出了target的当前属性和source的当前属性，35-38行的主要作用在于防止深度遍历时的死循环。然而如果source对象本身存在循环引用的话，extend方法依然会报堆栈溢出的错误

（7）第41行的if用来处理深复制的情况，如果传入的deep参数为true，并且当前的source属性值是plainObject(使用对象字面量创建的对象或new Object()创建的对象)或数组，则需要进行递归深复制

（8）第42-48根据copy的类型是plainObject还是Array，对src进行处理：如果copy是数组，那么src如果不是数组，就改写为一个空数组；如果copy是chainObject，那么src如果不是chainObject，就改写为{}

（9）如果41行的if条件不成立，那么直接把target的src属性用copy覆盖

jQuery的extend方法使用基本的递归思路实现了深度复制，但是这个方法也无法处理source对象内部循环引用的问题，同时对于Date、Function等类型的值也没有实现真正的深度复制，但是这些类型的值在重新定义时一般都是直接覆盖，所以也不会对源对象造成影响，因此一定程度上也符合深复制的条件

- (2) 自己实现一个copy方法
```
//util作为判断变量具体类型的辅助模块
   var util = (function(){
       var class2type = {};
       ["Null","Undefined","Number","Boolean","String","Object","Function","Array","RegExp","Date"].forEach(function(item){
           class2type["[object "+ item + "]"] = item.toLowerCase();
       })

       function isType(obj, type){
           return getType(obj) === type;
       }
       function getType(obj){
           return class2type[Object.prototype.toString.call(obj)] || "object";
       }
       return {
           isType:isType,
           getType:getType
       }
   })();

   function copy(obj,deep){
        //如果obj不是对象，那么直接返回值就可以了
       if(obj === null || typeof obj !== "object"){
           return obj;
       }
　　　　//定义需要的局部变脸，根据obj的类型来调整target的类型
       var i, target = util.isType(obj,"array") ? [] : {},value,valueType;
       for(i in obj){ value = obj[i];
           valueType = util.getType(value);
　　　　　　　//只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制
           if(deep && (valueType === "array" || valueType === "object")){
               target[i] = copy(value);
           }else{
               target[i] = value;
           }
       }
       return target;
   }
```

### ES6中对象的浅拷贝
扩展运算符(...)用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
```
let z = {a:3,b:4};
let n = {...z};
n //{a:3,b:4}}
```

原文：
1. [快速浅拷贝一个数组](https://blog.csdn.net/yiifaa/article/details/73438088)
2. https://www.zhihu.com/question/23031215
3. [推荐！](https://www.cnblogs.com/tracylin/p/5346314.html)
4. [JavaScript复制（合并）对象](https://segmentfault.com/a/1190000011492291)
5. [ES6之扩展运算符与应用](https://www.jianshu.com/p/35f9efe95fff)
