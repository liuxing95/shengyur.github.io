<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>浏览器解析渲染过程解析 | 往东</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浏览器解析渲染过程解析</h1><a id="logo" href="/.">往东</a><p class="description">宁在一思进，莫在一思停。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浏览器解析渲染过程解析</h1><div class="post-meta">Sep 29, 2018<span> | </span><span class="category"><a href="/categories/Foundation/">前端基础</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#页面呈现六部曲"><span class="toc-number">1.</span> <span class="toc-text">页面呈现六部曲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六部曲中存在的阻塞"><span class="toc-number">2.</span> <span class="toc-text">六部曲中存在的阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六部曲之——DOM树的构建"><span class="toc-number">3.</span> <span class="toc-text">六部曲之——DOM树的构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六部曲之——CSSOM树的构建"><span class="toc-number">4.</span> <span class="toc-text">六部曲之——CSSOM树的构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六部曲之——渲染树的构建"><span class="toc-number">5.</span> <span class="toc-text">六部曲之——渲染树的构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六部曲之——布局"><span class="toc-number">6.</span> <span class="toc-text">六部曲之——布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六部曲之——绘制"><span class="toc-number">7.</span> <span class="toc-text">六部曲之——绘制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六部曲之——复合图层化"><span class="toc-number">8.</span> <span class="toc-text">六部曲之——复合图层化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何创建layer"><span class="toc-number">8.1.</span> <span class="toc-text">如何创建layer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拒绝layer泛滥"><span class="toc-number">8.2.</span> <span class="toc-text">拒绝layer泛滥</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意事项"><span class="toc-number">9.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器的渲染流程方向的优化手段"><span class="toc-number">10.</span> <span class="toc-text">浏览器的渲染流程方向的优化手段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化不可避免的阻塞：优化关键呈现路径"><span class="toc-number">10.1.</span> <span class="toc-text">优化不可避免的阻塞：优化关键呈现路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关键呈现路径里的一些概念："><span class="toc-number">10.1.1.</span> <span class="toc-text">关键呈现路径里的一些概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化关键呈现路径的指导原则："><span class="toc-number">10.1.2.</span> <span class="toc-text">优化关键呈现路径的指导原则：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化关键呈现路径常规步骤："><span class="toc-number">10.1.3.</span> <span class="toc-text">优化关键呈现路径常规步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化关键呈现路径的具体建议："><span class="toc-number">10.1.4.</span> <span class="toc-text">优化关键呈现路径的具体建议：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#针对复合图层化的优化"><span class="toc-number">10.2.</span> <span class="toc-text">针对复合图层化的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复合图层化机制是怎样的呢？"><span class="toc-number">10.2.1.</span> <span class="toc-text">复合图层化机制是怎样的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图层化的优势"><span class="toc-number">10.2.2.</span> <span class="toc-text">图层化的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#因为开销，所以节制"><span class="toc-number">10.2.3.</span> <span class="toc-text">因为开销，所以节制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#针对回流的优化"><span class="toc-number">10.3.</span> <span class="toc-text">针对回流的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#技术使用优先级："><span class="toc-number">10.3.1.</span> <span class="toc-text">技术使用优先级：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#What-forces-layout"><span class="toc-number">10.3.2.</span> <span class="toc-text">What forces layout</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少渲染时的内存消耗"><span class="toc-number">10.4.</span> <span class="toc-text">减少渲染时的内存消耗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少渲染时的计算数量"><span class="toc-number">10.5.</span> <span class="toc-text">减少渲染时的计算数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节流函数"><span class="toc-number">10.6.</span> <span class="toc-text">节流函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#惰性载入函数"><span class="toc-number">10.7.</span> <span class="toc-text">惰性载入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重任务分片多帧"><span class="toc-number">10.8.</span> <span class="toc-text">重任务分片多帧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回答几个问题-自测"><span class="toc-number">11.</span> <span class="toc-text">回答几个问题 自测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解-getComputedStyle"><span class="toc-number">11.1.</span> <span class="toc-text">如何理解 getComputedStyle?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#visibility-hidden和-display-none的区别"><span class="toc-number">11.2.</span> <span class="toc-text">visibility:hidden和 display:none的区别?</span></a></li></ol></li></ol></div></div><div class="post-content"><p>在浏览器从获取到HTML，然后解析，渲染的过程中，到底发生了什么？</p>
<h2 id="页面呈现六部曲"><a href="#页面呈现六部曲" class="headerlink" title="页面呈现六部曲"></a>页面呈现六部曲</h2><p>1.解析HTML,构建DOM树。<br>2.解析CSS,生成CSS规则树。<br><em>在chrome的Timeline 工具中对应的阶段是：Re-caculate。为什么是 Re-caculate Style 呢？这是因为浏览器本身有 User Agent StyleSheet，所以最终的样式是我们的样式代码样式与用户代理默认样式覆盖/重新计算得到的。</em><br>3.合并 DOM 树与 CSSOM 树为 Render 树<br>4.布局（Layout）<br>5.绘制（Paint）<br>6.复合图层化（Composite）<br>多个复合层的合成，最终合成的页面被用户看到。</p>
<a id="more"></a>
<h2 id="六部曲中存在的阻塞"><a href="#六部曲中存在的阻塞" class="headerlink" title="六部曲中存在的阻塞"></a>六部曲中存在的阻塞</h2><p>虽然六部曲看似和谐，分工合作，有序进行。但是实际上这里面却是波云诡谲，风起云涌，就像平时的工作一样，看似你和我各司其职，分工明确，但是实际干起活来却可能因为某一个人的某一环而阻滞整个进度。</p>
<p>那么下面我们来分析一下六部曲中存在的阻塞：</p>
<ol>
<li>当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（阻塞1）<br>然而，是否停下 DOM 的构建的同时，立马就执行 JavaScript 代码或者下载外部脚本执行，其实还是要视情况而定</li>
<li>当遇到 &lt;script&gt;标签需要执行脚本代码时，浏览器会检查是否这个 &lt;script&gt;标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 &lt;script&gt;上部还有 CSS 样式没加载，则浏览器会等待 &lt;script&gt;上方样式的加载完成才会执行该 &lt;script&gt;内的脚本，（阻塞2）</li>
<li>DOM 树与 CSSOM 树的成功构建是后面步骤的根基（同步阻塞）</li>
<li>同时外部脚本、外部样式表的下载也是耗费时间较多的点</li>
</ol>
<h2 id="六部曲之——DOM树的构建"><a href="#六部曲之——DOM树的构建" class="headerlink" title="六部曲之——DOM树的构建"></a>六部曲之——DOM树的构建</h2><p><img src="https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/DOM%20tree.png"></p>
<p>浏览器构建DOM树可以简单的总结为以下几步：</p>
<ol>
<li>转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</li>
<li>Tokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</li>
<li>构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）<br><img src="https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/htmlParse.png"></li>
<li>构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 Chrome 开发者工具下 Timeline 面板的 <span class="built_in">Parse</span> HTML 阶段对应着 DOM 树的构建。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/24911872?refer=dreawer" target="_blank" rel="noopener">从Chrome源码看浏览器如何构建DOM树 </a><br>留意这篇文章的这些点：</p>
<ol>
<li>DOM 构建时对 DOCType 处理</li>
<li>DOCType 的不同或漏缺带来的文档解析模式（怪异模式、有限怪异模式、标准模式）的影响</li>
<li>处理开标签与闭标签的压栈、弹栈处理</li>
<li>Chromium 对待自定义标签的处理</li>
<li>JavaScript 方法查找 DOM 的过程，使用 ID、类名、复杂选择器查找 DOM 的对比</li>
</ol>
<h2 id="六部曲之——CSSOM树的构建"><a href="#六部曲之——CSSOM树的构建" class="headerlink" title="六部曲之——CSSOM树的构建"></a>六部曲之——CSSOM树的构建</h2><p>CSSOM 树的构建 “原料” 的来源有：外部 CSS 文件、内部样式、内联样式。</p>
<p><em>CSSOM 树的构建其实是一个 样式的重新计算 的过程，为什么是重新计算呢？</em><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户代理（即浏览器）本身有一套内置样式表，所以我们最终的 CSSOM 树其实是用户代理样式与页面所有样式的重新计算。</span><br><span class="line">所以在 Chrome 浏览器开发者工具的 Timeline 面板下，CSSOM 树的构建对应的是 Recalculate <span class="keyword">Style</span> 阶段</span><br></pre></td></tr></table></figure></p>
<p>与 DOM 树的构建过程相似，CSSOM 的构建也要经历以下过程：<br><img src="https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom.png"></p>
<p>最终构建的 CSSOM 树大致如下：<br><img src="https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom_end.png"></p>
<h2 id="六部曲之——渲染树的构建"><a href="#六部曲之——渲染树的构建" class="headerlink" title="六部曲之——渲染树的构建"></a>六部曲之——渲染树的构建</h2><p>1.DOM 树与 CSSOM 树融合成渲染树<br>2.渲染树只包括渲染页面需要的节点<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排除 <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"> <span class="tag">&lt;<span class="name">meta</span>&gt;</span> 等功能化、非视觉节点</span></span></span><br><span class="line"><span class="undefined">排除 display: none 的节点</span></span><br></pre></td></tr></table></figure></p>
<p>过程大致如下：<br><img src="https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/renderTree.png"></p>
<h2 id="六部曲之——布局"><a href="#六部曲之——布局" class="headerlink" title="六部曲之——布局"></a>六部曲之——布局</h2><p>Layout 阶段做的工作：确定页面各元素的位置、尺寸。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Layout</span> 在 Chrome 开发者工具 Timeline 面板中被归并到 Paint 阶段</span><br></pre></td></tr></table></figure></p>
<p>当元素某些样式变更/JavaScript 执行某些样式请求，会导致 Layout trashing，又叫做回流（Reflow）。</p>
<h2 id="六部曲之——绘制"><a href="#六部曲之——绘制" class="headerlink" title="六部曲之——绘制"></a>六部曲之——绘制</h2><p>一旦布局（Layout）步骤完成，浏览器便触发 <em>Paint Setup</em> 与 <em>Paint</em> 事件（渲染引擎底层概念），执行 paint 操作，结合渲染树与布局信息绘制实际像素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：在 Timeline 工具内，Layout 与 Paint 两个过程被统一归并到 Paint 阶段。</span><br></pre></td></tr></table></figure></p>
<h2 id="六部曲之——复合图层化"><a href="#六部曲之——复合图层化" class="headerlink" title="六部曲之——复合图层化"></a>六部曲之——复合图层化</h2><p>在很多情况下，我们不会将复合图层化归入页面呈现的必要过程。图层化是浏览器为了充分利用已有渲染成果（缓存渲染成果），最小化 GPU 运算，将“脏区”提升为复合图层，隔离变化影响的操作。</p>
<p>详情见<a href="一篇文章说清浏览器解析和CSS（GPU）动画优化">https://segmentfault.com/a/1190000008015671</a></p>
<h3 id="如何创建layer"><a href="#如何创建layer" class="headerlink" title="如何创建layer"></a>如何创建layer</h3><p>1.3D 或透视变换(perspective transform) CSS 属性<br>2.使用加速视频解码的元素，如&lt;video&gt;<br>3.拥有 3D (WebGL) 上下文或加速的 2D 上下文的，如&lt;canvas&gt;<br>4.混合插件(如 Flash)<br>5.对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素<br>6.拥有加速 CSS 过滤器的元素，如CSS filters<br>7.元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)<br>8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)<br>9.在webkit内核的浏览器中，如果有上述情况，则会创建一个独立的layer。</p>
<h3 id="拒绝layer泛滥"><a href="#拒绝layer泛滥" class="headerlink" title="拒绝layer泛滥"></a>拒绝layer泛滥</h3><p><strong>当对元素创建layer之后，会节省layout和paint阶段，但是layer不能泛滥。 layer跟psd中图层很像，我们知道在psd中图层越多，psd图片就会越大。 同理，layer越多，占用的内存就越多，当在内存有限的移动设备上（手机），过多的渲染带来的开销超过了它在性能上的改善,得不偿失； 白白的给元素添加layer，一般通过* {-webkit-transform: translateZ(0);}为元素添加layer 但创建layer的原则：当且仅当需要的时候才为元素创建渲染层。</strong></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>渲染分为三阶段：layout，paint，composite layer，修改不同的css属性会触发不同的阶段，触发的阶段越靠前，渲染的代价越高。</strong><br>1：尽量避免触发layout（位置相关的可通过transform代替 top left），paint。 除写css属性外，读取css的位置大小相关属性会导致触发layout阶段，要分离读写，减少layout。<br>2：应该尽量避免重绘，并且尽可能的使绘制区域最小，以提升页面性能。 但是有些必须使用的样式效果还是要用的，比如fixed等重要的是作为前端人员，能够预估这些代码所带来的性能损耗及所造成的影响。<br>3：避免组合触发 比如滚动和hover效果，hover中若使用border-shadow，border-style修改，则会损耗较大的性能，有可能会触发丢帧的现象。 改进办法：在滚动时，增加计时器，可先把hover效果禁掉，滚动结束后再打开hover效果。</p>
<h2 id="浏览器的渲染流程方向的优化手段"><a href="#浏览器的渲染流程方向的优化手段" class="headerlink" title="浏览器的渲染流程方向的优化手段"></a>浏览器的渲染流程方向的优化手段</h2><p>知道了页面渲染的原理，那么我们也就得到了页面性能优化的依据。提炼六部曲中每一步的优化空间，针对六部曲中的每一步提出针对性的优化方案也就能达到我们最终的优化目的。</p>
<h3 id="优化不可避免的阻塞：优化关键呈现路径"><a href="#优化不可避免的阻塞：优化关键呈现路径" class="headerlink" title="优化不可避免的阻塞：优化关键呈现路径"></a>优化不可避免的阻塞：优化关键呈现路径</h3><h4 id="关键呈现路径里的一些概念："><a href="#关键呈现路径里的一些概念：" class="headerlink" title="关键呈现路径里的一些概念："></a>关键呈现路径里的一些概念：</h4><ul>
<li><strong>关键资源</strong>：可能阻止网页首次呈现的资源。</li>
<li><strong>关键路径长度</strong>：即往返过程数量，或提取所有关键资源所需的总时间。</li>
<li><strong>关键字节</strong>：实现网页首次呈现所需的总字节数，是所有关键资源的传输文件大小总和。 带有一个 HTML 网页的首个示例包含一项关键资源（HTML 文档），关键路径长度也与 1 个网络往返过程（假设文件较小）相等，而且总的关键字节数正好是 HTML 文档本身的传输大小。</li>
</ul>
<h4 id="优化关键呈现路径的指导原则："><a href="#优化关键呈现路径的指导原则：" class="headerlink" title="优化关键呈现路径的指导原则："></a>优化关键呈现路径的指导原则：</h4><ul>
<li>尽量减少关键资源数量。</li>
<li>尽量减少关键字节数。</li>
<li>尽量缩短关键路径的长度。</li>
</ul>
<h4 id="优化关键呈现路径常规步骤："><a href="#优化关键呈现路径常规步骤：" class="headerlink" title="优化关键呈现路径常规步骤："></a>优化关键呈现路径常规步骤：</h4><ul>
<li>分析和描述关键路径：资源数量、字节数、长度。</li>
<li>尽量减少关键资源数量：删除相应资源、延迟下载、标记为异步资源等等。</li>
<li>优化剩余关键资源的加载顺序：你需要尽早下载所有关键资源，以缩短关键路径长度。</li>
<li>尽量减少关键字节数，以缩短下载时间（和往返次数）。</li>
</ul>
<h4 id="优化关键呈现路径的具体建议："><a href="#优化关键呈现路径的具体建议：" class="headerlink" title="优化关键呈现路径的具体建议："></a>优化关键呈现路径的具体建议：</h4><ul>
<li><p>文件合并、压缩</p>
</li>
<li><p>推荐使用异步（async） JavaScript 资源，或使用延迟（defer）执行的 JavaScript</p>
</li>
<li><p>一般 &lt;script&gt;脚本的靠后书写</p>
</li>
<li><p>避免运行时间长的 JavaScript，耗时任务的拆分，chunk 化运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：使用定时器将大任务拆分为小任务，使得浏览器得到空隙做其他事情。</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用 CSS import</p>
</li>
<li>内联、内部化阻止呈现的 CSS<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般不采用，百度、Google 这样的极度重视性能与体验的服务才可能这样做。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="针对复合图层化的优化"><a href="#针对复合图层化的优化" class="headerlink" title="针对复合图层化的优化"></a>针对复合图层化的优化</h3><p>因为浏览器有图层化这个机制，那么我们就搞懂它并充分利用吧。</p>
<h4 id="复合图层化机制是怎样的呢？"><a href="#复合图层化机制是怎样的呢？" class="headerlink" title="复合图层化机制是怎样的呢？"></a>复合图层化机制是怎样的呢？</h4><p>如果某些属性的变更（transform、opacity）满足以下条件:</p>
<ul>
<li>不影响文档流</li>
<li>不依赖文档流</li>
<li>不会造成重绘</li>
</ul>
<p>那么，这些属性变更时，就需要一种机制：<br>能将属性变更的部分与页面其他部分隔离开来，对其他部分已经渲染完的进行缓存，变更的部分在单独的图层上进行，然后对缓存的部分与变更的图层进行合成。<br>关键字：<strong>缓存、隔离、图层合成</strong><br>使用 transform 与 opacity 进行属性变更是经典的复合图层优化方法，以下是其他会提升元素为复合图层的场景：<br>1.3d 或透视变换 CSS 属性，例如 translate3d, translateZ 等等（JS 一般通过这种方式，使元素获得复合图层）<br>2.&lt;video&gt; &lt;iframe&gt; &lt;canvas&gt; &lt;webgl&gt;等元素<br>3.混合插件（如flash）<br>4.元素自身的 opacity 和 transform 做 CSS 动画<br>5.拥有<a href="http://www.runoob.com/cssref/css3-pr-filter.html" target="_blank" rel="noopener">CSS Filter</a>的元素<br>6.使用 will-change 属性<br>7.position:fixed<br>8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上方)</p>
<h4 id="图层化的优势"><a href="#图层化的优势" class="headerlink" title="图层化的优势"></a>图层化的优势</h4><p>很容易看出来：充分利用缓存、隔离的思想，无需像回流、重绘那么大性能（GPU、CPU）开支，图层化能带来 <strong>动画性能的提升</strong>。</p>
<p>图层化的潜在问题/弊端 —— 内存开销<br>因为图层化的存在，每个图层对需要在内存中存储该图层相关的信息，当图层太多会造成内存开销过大的情况。</p>
<h4 id="因为开销，所以节制"><a href="#因为开销，所以节制" class="headerlink" title="因为开销，所以节制"></a>因为开销，所以节制</h4><p>内存开销在桌面端可能还能接受，但是在资源有限的移动端，复合图层过多便可能导致内存开支过大，页面反而变得停滞、卡顿，甚至浏览器假死，系统无法正常运行。</p>
<h3 id="针对回流的优化"><a href="#针对回流的优化" class="headerlink" title="针对回流的优化"></a>针对回流的优化</h3><p>首先，我们需要知道什么情况下会触发浏览器的repaint/reflow：<br>查询哪些属性会触发Layout/Paing/Composite,可参考：<br><a href="https://csstriggers.com/" target="_blank" rel="noopener">https://csstriggers.com/</a></p>
<h4 id="技术使用优先级："><a href="#技术使用优先级：" class="headerlink" title="技术使用优先级："></a>技术使用优先级：</h4><p>1.CSS3 &gt; JavaScript<br>2.属性变更优先考虑顺序（性能表现排序）</p>
<ul>
<li>transfrom, opacity</li>
<li>background-color等</li>
<li>position top、bottom、left、right</li>
<li>width、height等</li>
<li>margin、padding、border</li>
</ul>
<h4 id="What-forces-layout"><a href="#What-forces-layout" class="headerlink" title="What forces layout"></a>What forces layout</h4><p>能够引起重绘和回流的属性修改/查找：</p>
<ul>
<li>Element<br><strong>Box metrics</strong><br>elem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParent<br>elem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeight<br>elem.getClientRects(), elem.getBoundingClientRect()</li>
</ul>
<p><strong>Scroll stuff</strong><br>elem.scrollBy(), elem.scrollTo()<br>elem.scrollIntoView(), elem.scrollIntoViewIfNeeded()<br>elem.scrollWidth, elem.scrollHeight<br>elem.scrollLeft, elem.scrollTop also, setting them</p>
<p><strong>Focus</strong><br>elem.focus() can trigger a double forced layout (source)</p>
<p><strong>Also…</strong><br>elem.computedRole, elem.computedName<br>elem.innerText (source)</p>
<ul>
<li><p>getComputedStyle</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>详情查看：<a href="https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9" target="_blank" rel="noopener">https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9</a><br><strong>JavaScript 存在这样的机制：当连续有大量 DOM 样式的操作时，出于性能考虑，防止零碎变更导致频繁的回流、重绘，会尽可能地将这些操作先缓存起来，然后一次性地变更。这个机制我们难以察觉但是确实存在。<br>然而当我们进行某些 DOM 样式的读、写时，出于时效性的考虑，则会立即触发浏览器回流、重绘以返回正确、合理的值。</strong></p>
<h3 id="减少渲染时的内存消耗"><a href="#减少渲染时的内存消耗" class="headerlink" title="减少渲染时的内存消耗"></a>减少渲染时的内存消耗</h3><p>1.避免浏览器的隐式合成。</p>
<ul>
<li>保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。</li>
<li>将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。</li>
</ul>
<p>2.减小复合层的尺寸<br>看一下两张图片，有什么不同吗？<br><img src="https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/MinComposite.png"><br>这两张图片视觉上是一样的，但是它们的尺寸一个是39kb；另外一个是400b。不同之处在于，第二个纯色层是通过scale放大10倍做到的。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#a</span>, <span class="selector-id">#b</span> &#123;</span></span><br><span class="line"><span class="undefined"> will-change: transform;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#a</span> &#123;</span></span><br><span class="line"><span class="undefined"> width: 100px;</span></span><br><span class="line"><span class="undefined"> height: 100px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#b</span> &#123;</span></span><br><span class="line"><span class="undefined"> width: 10px;</span></span><br><span class="line"><span class="undefined"> height: 10px;</span></span><br><span class="line"><span class="undefined"> transform: scale(10);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对于图片，你要怎么做呢？你可以将图片的尺寸减少5%——10%，然后使用scale将它们放大；用户不会看到什么区别，但是你可以减少大量的存储空间。</p>
<h3 id="减少渲染时的计算数量"><a href="#减少渲染时的计算数量" class="headerlink" title="减少渲染时的计算数量"></a>减少渲染时的计算数量</h3><p>1.用css动画而不是js动画<br>css动画有一个重要的特性，它是完全工作在GPU上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给GPU。<br>而如果使用js动画，浏览器必须计算每一帧的状态；<br>为了保证平滑的动画，我们必须在浏览器主线程计算新状态；<br>把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画；<br>当主线程的计算任务过多时，会造成动画的延迟、卡顿。</p>
<p>所以尽可能地使用基于css的动画，不仅仅更快；也不会被大量的js计算所阻塞。</p>
<h3 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h3><h3 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h3><h3 id="重任务分片多帧"><a href="#重任务分片多帧" class="headerlink" title="重任务分片多帧"></a><a href="https://zhuanlan.zhihu.com/p/25166666?refer=dreawer" target="_blank" rel="noopener">重任务分片多帧</a></h3><p>知道原理之后，常用的有如下几点优化方法：</p>
<p>1.避免在document上直接进行频繁的DOM操作，如果确实需要可以采用off-document的方式进行，具体的方法包括但不完全包括以下几种：<br>(1). 先将元素从document中删除，完成修改后再把元素放回原来的位置</p>
<p>(2). 将元素的display设置为”none”，完成修改后再把display修改为原来的值</p>
<p>(3). 如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document</p>
<p>2.集中修改样式<br>(1). 尽可能少的修改元素style上的属性</p>
<p>(2). 尽量通过修改className来修改样式</p>
<p>(3). 通过cssText属性/className来设置样式值</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(<span class="string">"d1"</span>).style.cssText = <span class="string">"color:red; font-size:13px;"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>3.缓存Layout属性值<br>对于Layout属性中非引用类型的值（数字型），如果需要多次访问则可以在一次访问时先存储到局部变量中，之后都使用局部变量，这样可以避免每次读取属性时造成浏览器的渲染。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var width</span> = el.offsetWidth; <span class="attribute">v</span><span class="attribute">a</span><span class="attribute">r</span> <span class="attribute">s</span><span class="attribute">c</span><span class="attribute">r</span><span class="attribute">o</span><span class="attribute">l</span><span class="attribute">l</span><span class="attribute">L</span><span class="attribute">e</span><span class="attribute">f</span><span class="attribute">t</span> = el.scrollLeft;</span><br></pre></td></tr></table></figure></p>
<p>4.设置元素的position为absolute或fixed</p>
<p>5.不要使用table布局。</p>
<p>6.css动画中尽量只使用transform和opacity，这不会发生重排和重绘。<br>如上所说，transform和opacity保证了元素属性的变化不影响文档流、也不受文档流影响；并且不会造成repaint。<br>有些时候你可能想要改变其他的css属性，作为动画。例如：你可能想使用background属性改变背景：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"bg-change"</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="selector-class">.bg-change</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bg-change</span>:hover &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，在动画的每一步；浏览器都会进行一次重绘。我们可以使用一个复层在这个元素上面，并且仅仅变换opacity属性：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bg-change"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.bg-change</span> &#123;</span></span><br><span class="line"><span class="undefined">  width: 100px;</span></span><br><span class="line"><span class="undefined">  height: 100px;</span></span><br><span class="line"><span class="undefined">  background: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.bg-change</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="undefined">  content: '';</span></span><br><span class="line"><span class="undefined">  display: block;</span></span><br><span class="line"><span class="undefined">  width: 100%;</span></span><br><span class="line"><span class="undefined">  height: 100%;</span></span><br><span class="line"><span class="undefined">  background: blue;</span></span><br><span class="line"><span class="undefined">  opacity: 0;</span></span><br><span class="line"><span class="undefined">  transition: opacity 20s;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.bg-change</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="undefined">  opacity: 1;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="回答几个问题-自测"><a href="#回答几个问题-自测" class="headerlink" title="回答几个问题 自测"></a>回答几个问题 自测</h2><h3 id="如何理解-getComputedStyle"><a href="#如何理解-getComputedStyle" class="headerlink" title="如何理解 getComputedStyle?"></a>如何理解 getComputedStyle?</h3><p>在尚未梳理知识体系前，大概会这样回答：</p>
<p>普通版本： getComputedStyle会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过 window.getComputedStyle等价于 document.defaultView.getComputedStyle调用</p>
<p>详细版本： window.getComputedStyle(elem,null).getPropertyValue(“height”)可能的值为 100px，而且，就算是css上写的是 inherit， getComputedStyle也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么 getComputedStyle获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。</p>
<p>就这个API来说，上述的回答已经比较全面了。</p>
<p>但是，其实它是可以继续延伸的。</p>
<p>譬如现在会这样回答：</p>
<p>getComputedStyle会获取当前元素所有最终使用的CSS属性值， window.和 document.defaultView.等价…</p>
<p>getComputedStyle会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如 offsetXXX， scrollXXX， clientXXX， currentStyle等等</p>
<h3 id="visibility-hidden和-display-none的区别"><a href="#visibility-hidden和-display-none的区别" class="headerlink" title="visibility:hidden和 display:none的区别?"></a>visibility:hidden和 display:none的区别?</h3><p>可以如下回答：</p>
<p>普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置</p>
<p>进一步， display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大</p>
<p>再进一步，当一个页面某个元素经常需要切换 display时如何优化，一般会用复合层优化，或者要求低一点用 absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流， absolute文档流，复合图层的区别，</p>
<p>再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）</p>
<p>上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖</p>
<p>参考：</p>
<ul>
<li><a href="如何减少浏览器repaint和reflow">https://www.cnblogs.com/fullhouse/archive/2012/02/20/2360301.html</a></li>
<li><a href="从输入URL到页面加载的过程？">https://mp.weixin.qq.com/s/LIfvU8j0gBVIFF8AYYtfFg</a></li>
<li><a href="浏览器内核、页面呈现原理及其优化">https://www.cnblogs.com/ys-wuhan/p/6985624.html</a></li>
<li><a href="从Chrome源码看浏览器如何构建DOM树">https://zhuanlan.zhihu.com/p/24911872?refer=dreawer</a></li>
<li><a href="一篇文章说清浏览器解析和CSS（GPU）动画优化">https://segmentfault.com/a/1190000008015671#articleHeader9</a></li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/10/25/JS中的深浅拷贝/">JS中的深浅拷贝</a><a class="next" href="/2018/08/20/chrome原生input框的自动补全如何关闭？/">chrome原生input框的自动补全如何关闭？</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Nodejs/">Nodejs</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/人间不值得/">人间不值得</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Foundation/">前端基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JsTest/">前端自动化测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Questions/">十万个为什么</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/小算法/">小算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frame/">库/框架</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术思想/">技术思想</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">效率工具</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Analysis/">源码浅析</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/YAML/" style="font-size: 15px;">YAML</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/性能/" style="font-size: 15px;">性能</a> <a href="/tags/CDN/" style="font-size: 15px;">CDN</a> <a href="/tags/Javascript/" style="font-size: 15px;">Javascript</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/Sass/" style="font-size: 15px;">Sass</a> <a href="/tags/Jest/" style="font-size: 15px;">Jest</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/diff算法/" style="font-size: 15px;">diff算法</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/XMLHttpRequest/" style="font-size: 15px;">XMLHttpRequest</a> <a href="/tags/ES5/" style="font-size: 15px;">ES5</a> <a href="/tags/axios/" style="font-size: 15px;">axios</a> <a href="/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/jQuery源码/" style="font-size: 15px;">jQuery源码</a> <a href="/tags/Less/" style="font-size: 15px;">Less</a> <a href="/tags/vscode/" style="font-size: 15px;">vscode</a> <a href="/tags/mock/" style="font-size: 15px;">mock</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/Node/" style="font-size: 15px;">Node</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/25/JS中的深浅拷贝/">JS中的深浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/29/浏览器解析渲染过程解析/">浏览器解析渲染过程解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/chrome原生input框的自动补全如何关闭？/">chrome原生input框的自动补全如何关闭？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/和固定，求两项（难度：★）/">和固定，求两项（难度：★）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/为什么git经常无法提交？/">为什么git经常无法提交？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/性能优化工具分析/">常用前端性能优化工具分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/curl命令怎么使用的？/">curl命令是怎么使用的？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/CDN工作机制以及原理浅析/">CDN工作机制以及原理浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/前端性能优化的常见措施/">前端性能优化的常见措施</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/WAI-ARIA无障碍网页应用属性/">盲人阅读网页时使用的读屏技术是怎样的？</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html" title="大道至简——Hexo简洁主题推荐" target="_blank">大道至简——Hexo简洁主题推荐</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">往东.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>