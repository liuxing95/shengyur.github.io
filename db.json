{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/1_2.jpg","path":"img/1_2.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/flex.png","path":"img/flex.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/flexDemo.jpg","path":"img/flexDemo.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/license.png","path":"img/license.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/describe.jpg","path":"img/describe.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/sass.jpg","path":"img/sass.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/1+2.jpg","path":"img/1+2.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BLOG.jpg","path":"img/BLOG.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/lufi.jpeg","path":"img/lufi.jpeg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/hexo4000.png","path":"img/hexo4000.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/fl.jpeg","path":"img/fl.jpeg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/zhang.jpg","path":"img/zhang.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/README.md","hash":"1048dc5e0f5f0c490a0ffca40ce9e75a06a83fb2","modified":1524155161000},{"_id":"source/.DS_Store","hash":"48df97b7e938535367c7964b7158e68ebafbe979","modified":1532564800000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1523973498000},{"_id":"themes/maupassant/.DS_Store","hash":"b4b33445001dd555fdbe5f2655e26ff6758f0456","modified":1528988500000},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1523973498000},{"_id":"themes/maupassant/_config.yml","hash":"ef9fae5458cacb23e6720c1eeb9aa9f58b8d9d6d","modified":1529391529000},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1523973498000},{"_id":"source/favicon.ico","hash":"09740f8468e4238f27d9e9d5b7b8b6bd48a0dfc1","modified":1523974374000},{"_id":"source/_posts/CSS效率工具之 Sass的常见用法.md","hash":"4e43c19bfe352d4e314dcae946717e16bc027205","modified":1527344810000},{"_id":"source/_posts/.DS_Store","hash":"e8445ed280ab4aafc647fc58dcbbd2b8a71c106e","modified":1532051513000},{"_id":"source/_posts/Array、Object常用方法.md","hash":"327e84dec4e8e302608fbd4067e6fe85b2bd80c0","modified":1530803171000},{"_id":"source/_posts/CDN工作机制以及原理浅析.md","hash":"11f59fd821905cb182eec0781cfa00fd6b731949","modified":1532224558000},{"_id":"source/_posts/ES6_super.md","hash":"4df858ce22700c1bfbd7ee81c01a280185044121","modified":1529150489000},{"_id":"source/_posts/ES6之扩展运算符与应用.md","hash":"0efc779f338abb529fcfea39b028867b1f6d34f9","modified":1532357009000},{"_id":"source/_posts/HTTP状态码解读.md","hash":"8182d8ca286b0724611c53e7a27032f647aaeaba","modified":1531561933000},{"_id":"source/_posts/JavaScript-test-framework.md","hash":"79da32ae47108b6affd64664da67a4da3dc0d186","modified":1528559416000},{"_id":"source/_posts/Nodejs之npm&package.json学习.md","hash":"68b6b9e06ebe5d4e542ece669fbe8bf2c7d7b85c","modified":1529854354000},{"_id":"source/_posts/React 深入之diff算法.md","hash":"a34da9cf3cad8efb5fe9752bdff30c077fdbfc9d","modified":1532082302000},{"_id":"source/_posts/React-Element中的StyleSheet.reset方法为何可以重置样式？.md","hash":"c11efdea247a252e097f05fe17bc6f3c3a509a30","modified":1528895123000},{"_id":"source/_posts/React基础之 key的必要性与使用.md","hash":"893dcd0f45d49c2a62cccfa6761514d61a219a0d","modified":1531968782000},{"_id":"source/_posts/React基础之 react生命周期.md","hash":"7abbdebc6289c278a9d264af0204884e0e26b46f","modified":1531933532000},{"_id":"source/_posts/React基础之 父组件如何调用子组件中的方法.md","hash":"e4a4b16d7fd85f2d48c974347b1f93eee5959350","modified":1527940808000},{"_id":"source/_posts/React基础之 排坑日常.md","hash":"3ac4fcd5ce2e9d5fa012c96a23d9b4e04a9699e5","modified":1531534038000},{"_id":"source/_posts/React进阶之 React性能优化.md","hash":"fa5a2e0d28678f824e110be08c762e61a0e4d54f","modified":1531063135000},{"_id":"source/_posts/React进阶之 使用mobx进行状态管理.md","hash":"a353058f4c4c5a01f26ebe2cce9cfcc4cd1ea8fa","modified":1532010788000},{"_id":"source/_posts/WAI-ARIA无障碍网页应用属性.md","hash":"88f7d2a3a84789d668cc64824e49593a17ecce41","modified":1532357643000},{"_id":"source/_posts/XMLHttpRequest.md","hash":"be00b741e1af344108bd0565656087701e1d3708","modified":1531535422000},{"_id":"source/_posts/YAML语言入门.md","hash":"f6b5c8be7a4d5fef661408ad4f068cbb4845af7b","modified":1529500959000},{"_id":"source/_posts/axios常用攻略.md","hash":"7a143251ba4ad0d7a85358d3454c2f7a46b4b33e","modified":1528988657000},{"_id":"source/_posts/chrome原生input框的自动补全如何关闭？.md","hash":"7c5b0c5911301e545c29f364f91ad7ed72ab3a39","modified":1534724122000},{"_id":"source/_posts/curl命令怎么使用的？.md","hash":"5ac6201de265ba7c8c561330aa11eaafcae7587d","modified":1532616728000},{"_id":"source/_posts/flex布局从入门到运用.md","hash":"f17baf5fa4d047e8229139e1163144b2e34101a6","modified":1526126295000},{"_id":"source/_posts/git常用基本命令.md","hash":"6f1fc6f71293ea9436f6e7c82478960f8b7e001e","modified":1531151879000},{"_id":"source/_posts/git踩坑小记录.md","hash":"c9097f2cf03dde0c1ebc1efe31782d7a40903a91","modified":1531935217000},{"_id":"source/_posts/hexo+github+Maupassant搭建博客.md","hash":"6b169af17c24c5a5fc3e41523fcce49585483d7d","modified":1534724795000},{"_id":"source/_posts/jquery源码解读01-总体架构.md","hash":"bed1ac16647c16859267b0b2c24f9ae0579a1f06","modified":1525269696000},{"_id":"source/_posts/less配合vscode使用的配置.md","hash":"e91c68410e665de6a000470476239aaed621318c","modified":1527345229000},{"_id":"source/_posts/mock工具使用.md","hash":"184218593e2c760a7f390a7c52cd3b67c08d6d08","modified":1529028483000},{"_id":"source/_posts/node_module无法删除？.md","hash":"f9e43a9a9e51f5ac51df7a8a8ea81467cd4d6364","modified":1530622158000},{"_id":"source/_posts/node版本切换工具nvm的常用命令.md","hash":"3eaeb2f4d2325bc233a39d6200bd0053240919dd","modified":1525524691000},{"_id":"source/_posts/为什么git经常无法提交？.md","hash":"1f096aae98992847b11543f8d6fb3f3daf28e811","modified":1533689988000},{"_id":"source/_posts/vscode之多设备配置同步.md","hash":"e0fbdf198be814c8dfe2e61f8d1714f6a9a604b4","modified":1527783705000},{"_id":"source/_posts/为啥老王要敲头？.md","hash":"145d25b763c8bcb83980688c661075e57dfd1be3","modified":1530194841000},{"_id":"source/_posts/函数式编程入门.md","hash":"30470b727059d16deb5f7b549df699909c9764fd","modified":1529501031000},{"_id":"source/_posts/利用hexo在多台电脑上提交和更新github pages博客.md","hash":"154314727f2493267443c3c98630f3437afad322","modified":1534521132000},{"_id":"source/_posts/前端性能优化的常见措施.md","hash":"24ee8f4e574417fcb874d448fb957a8d48c9b898","modified":1532186127000},{"_id":"source/_posts/前端技能图谱.md","hash":"8e7abb2e8205236d4163e16fc8ba23848f854c7e","modified":1534722715000},{"_id":"source/_posts/和固定，求两项（难度：★）.md","hash":"d331e787f4398efc47504ae0c2f220e9140299df","modified":1534723961000},{"_id":"source/_posts/复制知乎简书的文本内容，为什么会自带版权声明？.md","hash":"3546fc0e21f5850c0a7fc8c45ce29f82956382d9","modified":1525269725000},{"_id":"source/_posts/如何使用a标签或者href实现文件的下载？.md","hash":"de2bfafcec7d5def12e008526aa45cf762e4c251","modified":1529762261000},{"_id":"source/_posts/性能优化工具分析.md","hash":"8d7274eafd15925c32b001647dcda4819670939b","modified":1532225179000},{"_id":"source/_posts/数组与对象的深浅拷贝.md","hash":"c280dc3b2fd14dc98b7019d0408f5224bde6de2d","modified":1530803520000},{"_id":"source/_posts/说大人，则渺之。.md","hash":"1c05b8a160a529bc7638956afcf2294d2bde0c19","modified":1530459117000},{"_id":"source/_posts/浏览器解析渲染过程解析.md","hash":"f14655a99c3bc0557e243e54a55c6564dbe54a19","modified":1538996985000},{"_id":"source/about/index.md","hash":"dedc492db47f25a6b55e54757bc63ef16b91541b","modified":1524845996000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1523973498000},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1523973498000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1523973482000},{"_id":"themes/maupassant/.git/index","hash":"fa5e3b44c158c6d4cf73105713d4d4a96e9df7b1","modified":1529559348000},{"_id":"themes/maupassant/.git/packed-refs","hash":"173e6e733ade4ee56d29907aff7d181d2f539e5c","modified":1523973498000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1523973498000},{"_id":"themes/maupassant/languages/en.yml","hash":"9dc51349f64e882433957c00dc757366229e0269","modified":1523973498000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1523973498000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1523973498000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1523973498000},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1523973498000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ffce5df2448a80dbad71da115c84b81f42a42778","modified":1523973498000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1523973498000},{"_id":"themes/maupassant/layout/.DS_Store","hash":"0818527eb211dfb26a430bdf9628d91422703a29","modified":1527878061000},{"_id":"themes/maupassant/layout/archive.pug","hash":"665582bb4092fcd81bfaf4d08fc1689abee1e6c4","modified":1523973498000},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1523973498000},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1523973498000},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1523973498000},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1523973498000},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1523973498000},{"_id":"themes/maupassant/layout/post.pug","hash":"d0325a145fadc81083e71264c651306b11e4962d","modified":1523973498000},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1523973498000},{"_id":"themes/maupassant/source/.DS_Store","hash":"d4381eeac841c26c231d30a01828328a1a3fd391","modified":1528990658000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1523973482000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1523973482000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"2d3beab52f55464ea791892dd585c5aeabc19983","modified":1523973498000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1523973482000},{"_id":"themes/maupassant/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1523973482000},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"510535f1730834a37e057b17f22c7c63d1517daf","modified":1525186462000},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1524760338000},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"a02e78c558682a40a7ae583c0159868bca51b4e4","modified":1528040160000},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"84c7eac1d29be42a0ddfea8c91c6a5b7cea26492","modified":1527878609000},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"9925dc2f58d600d3890111d694c76315f6b8b95b","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"1202fc6685c368de8a8f080827fbbc285d86c274","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1523973498000},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1523973498000},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1523973498000},{"_id":"themes/maupassant/source/css/donate.css","hash":"d0079ba8202d925a93ab1cb44f2087b81f476755","modified":1523973498000},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1523973498000},{"_id":"themes/maupassant/source/css/style.scss","hash":"547bed40ce40b44bf527b02924df5be26472ac73","modified":1527878616000},{"_id":"themes/maupassant/source/img/.DS_Store","hash":"6631c96666bbce3dae5f5c9c326b1329d4376da7","modified":1528988546000},{"_id":"themes/maupassant/source/img/1_2.jpg","hash":"f2976eda60c23d58b0b08465802da5efb281cd93","modified":1524725719000},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1523973498000},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1523973498000},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1523973498000},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1523973498000},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1523973498000},{"_id":"themes/maupassant/source/img/flex.png","hash":"1ecaac9b18d66edf3ab7aeaadde91dd7b47ac4f5","modified":1525662776000},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1523973498000},{"_id":"themes/maupassant/source/img/flexDemo.jpg","hash":"2713986a8aaa4abd88c51c6869b4e3602f29d6e5","modified":1525701162000},{"_id":"themes/maupassant/source/img/license.png","hash":"140f114850c37c18ae9b0421a720ce2ce14d7ed0","modified":1526655645000},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1523973498000},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1523973498000},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1523973498000},{"_id":"themes/maupassant/source/donate/index.html","hash":"88cc1b52c1d8ce455d7e819c356a50554e6d90bc","modified":1523973498000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1523973498000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1523973498000},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1523973498000},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1523973498000},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1523973498000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1523973498000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1523973498000},{"_id":"themes/maupassant/source/img/describe.jpg","hash":"aa74dd130cab8104b0077cfca43a6c529a225bde","modified":1524755508000},{"_id":"themes/maupassant/source/img/sass.jpg","hash":"60483c1264119b7d7cc97cb501fe9a7c1e604f61","modified":1527259350000},{"_id":"themes/maupassant/.git/objects/pack/pack-af07c7f9ceb9dfeaa56ca1686fc858ae0d162e11.idx","hash":"174eff35f63b9c65c3b53ff826614b0a9c62f821","modified":1523973498000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"fa1c4b944193934a792617657c7a2e0eaa08dd22","modified":1523973498000},{"_id":"themes/maupassant/source/img/1+2.jpg","hash":"b5cc36ed3b7b37ea9ff79463a751807534898f64","modified":1524725674000},{"_id":"themes/maupassant/source/img/BLOG.jpg","hash":"5e1f542310c2201f8d229a13f5b6193486bbe9f3","modified":1524151040000},{"_id":"themes/maupassant/source/img/lufi.jpeg","hash":"dbcf416d6e6e249d9d4de7efb2810dfa687881c5","modified":1528681245000},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1523973498000},{"_id":"themes/maupassant/source/img/hexo4000.png","hash":"5456237c018d7774fdce1efa72167b841fc3b489","modified":1524063566000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"2d3beab52f55464ea791892dd585c5aeabc19983","modified":1523973498000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1523973498000},{"_id":"themes/maupassant/source/img/fl.jpeg","hash":"c06bd9b79a45b3adbcdd1f0342690e59210511cd","modified":1528595744000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"2d3beab52f55464ea791892dd585c5aeabc19983","modified":1523973498000},{"_id":"themes/maupassant/source/img/zhang.jpg","hash":"0db5610922f8cc3dc2ac4a46217642cae23e664e","modified":1524151302000},{"_id":"themes/maupassant/.git/objects/pack/pack-af07c7f9ceb9dfeaa56ca1686fc858ae0d162e11.pack","hash":"4a2c9a6b9d9dc188b2a5cf44439657d4c30d625e","modified":1523973498000}],"Category":[{"name":"效率工具","_id":"cjnn81uwe00037q0tr5pvkwp7"},{"name":"前端基础","_id":"cjnn81uwm00087q0t55s5op88"},{"name":"性能优化","_id":"cjnn81uws000e7q0taaw4b611"},{"name":"前端自动化测试","_id":"cjnn81ux7000v7q0t66ezgoos"},{"name":"Nodejs","_id":"cjnn81uxa00127q0t6wr7v459"},{"name":"库/框架","_id":"cjnn81uxl001a7q0tz5oix0uq"},{"name":"十万个为什么","_id":"cjnn81uxo001g7q0t7uls9qrp"},{"name":"源码浅析","_id":"cjnn81uyl00317q0tt9465rfy"},{"name":"小算法","_id":"cjnn81uyq00397q0tg3xsy3yg"},{"name":"人间不值得","_id":"cjnn81uz1003l7q0t8vzcbtvm"},{"name":"技术思想","_id":"cjnn81wgo00567q0tdpl86uln"}],"Data":[],"Page":[{"title":"关于","date":"2018-04-27T16:00:58.000Z","_content":"<span></span>\n<p><i class=\"fa fa-user\"></i> Nickname: <a href=\"https://shengyur.github.io/\">shengyu</a></p>\n<p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:sheldo.cn@gmail.com\" target=\"_blank\" rel=\"noopener\">sheldo.cn@gmail.com</a></p>\n<p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/shengyur\" target=\"_blank\" rel=\"noopener\">shengyur</a></p>\n<p><i class=\"fa fa-location-arrow\"></i> Location: 江苏 南京</a></p>\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-04-28 00:00:58\n---\n<span></span>\n<p><i class=\"fa fa-user\"></i> Nickname: <a href=\"https://shengyur.github.io/\">shengyu</a></p>\n<p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:sheldo.cn@gmail.com\" target=\"_blank\" rel=\"noopener\">sheldo.cn@gmail.com</a></p>\n<p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/shengyur\" target=\"_blank\" rel=\"noopener\">shengyur</a></p>\n<p><i class=\"fa fa-location-arrow\"></i> Location: 江苏 南京</a></p>\n","updated":"2018-04-27T16:19:56.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjnn81uwb00017q0tox49iww4","content":"<p><span></span></p>\n<p><i class=\"fa fa-user\"></i> Nickname: <a href=\"https://shengyur.github.io/\" target=\"_blank\" rel=\"noopener\">shengyu</a></p><br><p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:sheldo.cn@gmail.com\" target=\"_blank\" rel=\"noopener\">sheldo.cn@gmail.com</a></p><br><p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/shengyur\" target=\"_blank\" rel=\"noopener\">shengyur</a></p><br><p><i class=\"fa fa-location-arrow\"></i> Location: 江苏 南京</p>\n","site":{"data":{}},"excerpt":"","more":"<p><span></span></p>\n<p><i class=\"fa fa-user\"></i> Nickname: <a href=\"https://shengyur.github.io/\" target=\"_blank\" rel=\"noopener\">shengyu</a></p><br><p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:sheldo.cn@gmail.com\" target=\"_blank\" rel=\"noopener\">sheldo.cn@gmail.com</a></p><br><p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/shengyur\" target=\"_blank\" rel=\"noopener\">shengyur</a></p><br><p><i class=\"fa fa-location-arrow\"></i> Location: 江苏 南京</p>\n"}],"Post":[{"title":"CSS效率工具之 Sass的常见用法","date":"2018-05-24T16:00:00.000Z","_content":"<figure>\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/sass.jpg\">\n</figure>\n### 一 使用变量\n1. 可以使用变量：\n声明变量的方式：使用$符号，$highlight-color  $sidebar-width\n\n2. 变量存在作用域\n作用域使用方式：类似ES6的块级作用域，使用{}区分作用域\n  <!--more-->\n\n```\n$nav-color: #F90;\nnav {\n  $width: 100px;\n  width: $width;\n  color: $nav-color;\n}\n\n//编译后\n\nnav {\n  width: 100px;\n  color: #F90;\n}\n```\n\n3. 变量如何命名更好\nsass的变量名可以包括中划线和下划线，如$highlight-color（更普遍）、$highlight_color ，在sass中，这两种写法的内容是互通的，比如，对sass来说$link-color和$link_color其实指向的是同一个变量，但是在sass中纯css部分不互通，比如类名、ID或属性名。\n\n```\n$link-color: blue;\na {\n  color: $link_color;\n}\n\n//编译后\n\na {\n  color: blue;\n}\n```\n\n### 二 嵌套CSS\n1. 可以避免书写重复的长串选择器\n\n```\n#content article h1 { color: #333 }\n#content article p { margin-bottom: 1.4em }\n#content aside { background-color: #EEE }\n /* 编译后 */\n#content article h1 { color: #333 }\n#content article p { margin-bottom: 1.4em }\n#content aside { background-color: #EEE }\n```\n\n例外情况：\n比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构 &。\n\n2. 父选择器的标识符&\n\n```\narticle a {\n  color: blue;\n  &:hover { color: red }\n}\n```\n\n当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&被父选择器直接替换：\n\n```\narticle a { color: blue }\narticle a:hover { color: red }\n```\n\n3.  群组选择器的嵌套(减少重复敲写)\n.container h1, .container h2, .container h3 { margin-bottom: .8em }\n可以写成：\n\n```\n.container {\n  h1, h2, h3 {margin-bottom: .8em}\n}\n```\n\n4. 子组合选择器和同层组合选择器：>、+和~ 都支持使用\n\n&gt;:子组合选择器,用于选择一个元素的直接子元素\n+:同层相邻组合选择器+选择header元素后紧跟的p元素\n~:同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素\n\n```\narticle ~ article { border-top: 1px dashed #ccc }\n```\n\n5. 属性也可以嵌套\n\n```\nnav {\n  border: {\n  style: solid;\n  width: 1px;\n  color: #ccc;\n  }\n}\n```\n\n嵌套属性的规则：\n把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。\n\n```\nnav {\n  border-style: solid;\n  border-width: 1px;\n  border-color: #ccc;\n}\n```\n\n### 三、导入SASS文件\ncss原生的特性@import规则，允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。\n\nsass的@import规则，在生成css文件时，就会把相关样式导入进来。而且导入时，可以省略后缀的书写\n如@import\"sidebar\";这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。\n\n常用的就以上几点了，记录一下方便以后翻阅。\n\n参考：https://www.sass.hk/guide/\n","source":"_posts/CSS效率工具之 Sass的常见用法.md","raw":"title: CSS效率工具之 Sass的常见用法\ndate: 2018/05/25\ncategories: 效率工具\ntags:\n  - Sass\n---\n<figure>\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/sass.jpg\">\n</figure>\n### 一 使用变量\n1. 可以使用变量：\n声明变量的方式：使用$符号，$highlight-color  $sidebar-width\n\n2. 变量存在作用域\n作用域使用方式：类似ES6的块级作用域，使用{}区分作用域\n  <!--more-->\n\n```\n$nav-color: #F90;\nnav {\n  $width: 100px;\n  width: $width;\n  color: $nav-color;\n}\n\n//编译后\n\nnav {\n  width: 100px;\n  color: #F90;\n}\n```\n\n3. 变量如何命名更好\nsass的变量名可以包括中划线和下划线，如$highlight-color（更普遍）、$highlight_color ，在sass中，这两种写法的内容是互通的，比如，对sass来说$link-color和$link_color其实指向的是同一个变量，但是在sass中纯css部分不互通，比如类名、ID或属性名。\n\n```\n$link-color: blue;\na {\n  color: $link_color;\n}\n\n//编译后\n\na {\n  color: blue;\n}\n```\n\n### 二 嵌套CSS\n1. 可以避免书写重复的长串选择器\n\n```\n#content article h1 { color: #333 }\n#content article p { margin-bottom: 1.4em }\n#content aside { background-color: #EEE }\n /* 编译后 */\n#content article h1 { color: #333 }\n#content article p { margin-bottom: 1.4em }\n#content aside { background-color: #EEE }\n```\n\n例外情况：\n比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构 &。\n\n2. 父选择器的标识符&\n\n```\narticle a {\n  color: blue;\n  &:hover { color: red }\n}\n```\n\n当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&被父选择器直接替换：\n\n```\narticle a { color: blue }\narticle a:hover { color: red }\n```\n\n3.  群组选择器的嵌套(减少重复敲写)\n.container h1, .container h2, .container h3 { margin-bottom: .8em }\n可以写成：\n\n```\n.container {\n  h1, h2, h3 {margin-bottom: .8em}\n}\n```\n\n4. 子组合选择器和同层组合选择器：>、+和~ 都支持使用\n\n&gt;:子组合选择器,用于选择一个元素的直接子元素\n+:同层相邻组合选择器+选择header元素后紧跟的p元素\n~:同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素\n\n```\narticle ~ article { border-top: 1px dashed #ccc }\n```\n\n5. 属性也可以嵌套\n\n```\nnav {\n  border: {\n  style: solid;\n  width: 1px;\n  color: #ccc;\n  }\n}\n```\n\n嵌套属性的规则：\n把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。\n\n```\nnav {\n  border-style: solid;\n  border-width: 1px;\n  border-color: #ccc;\n}\n```\n\n### 三、导入SASS文件\ncss原生的特性@import规则，允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。\n\nsass的@import规则，在生成css文件时，就会把相关样式导入进来。而且导入时，可以省略后缀的书写\n如@import\"sidebar\";这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。\n\n常用的就以上几点了，记录一下方便以后翻阅。\n\n参考：https://www.sass.hk/guide/\n","slug":"CSS效率工具之 Sass的常见用法","published":1,"updated":"2018-05-26T14:26:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uw600007q0to3pmx7wt","content":"<p><figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/sass.jpg\"><br></figure></p>\n<h3 id=\"一-使用变量\"><a href=\"#一-使用变量\" class=\"headerlink\" title=\"一 使用变量\"></a>一 使用变量</h3><ol>\n<li><p>可以使用变量：<br>声明变量的方式：使用$符号，$highlight-color  $sidebar-width</p>\n</li>\n<li><p>变量存在作用域<br>作用域使用方式：类似ES6的块级作用域，使用{}区分作用域</p>\n<a id=\"more\"></a>\n</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$nav-color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"variable\">$width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$nav-color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>变量如何命名更好<br>sass的变量名可以包括中划线和下划线，如$highlight-color（更普遍）、$highlight_color ，在sass中，这两种写法的内容是互通的，比如，对sass来说$link-color和$link_color其实指向的是同一个变量，但是在sass中纯css部分不互通，比如类名、ID或属性名。</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$link</span>-<span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$link_color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-嵌套CSS\"><a href=\"#二-嵌套CSS\" class=\"headerlink\" title=\"二 嵌套CSS\"></a>二 嵌套CSS</h3><ol>\n<li>可以避免书写重复的长串选择器</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">h1</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">1.4em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#EEE</span> &#125;</span><br><span class=\"line\"> <span class=\"comment\">/* 编译后 */</span></span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">h1</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">1.4em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#EEE</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>例外情况：<br>比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构 &amp;。</p>\n<ol start=\"2\">\n<li>父选择器的标识符&amp;</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">  &amp;:hover &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">color</span>: blue &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span>:hover &#123; <span class=\"attribute\">color</span>: red &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>群组选择器的嵌套(减少重复敲写)<br>.container h1, .container h2, .container h3 { margin-bottom: .8em }<br>可以写成：</li>\n</ol>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"class\">container </span>&#123;</span><br><span class=\"line\">  h1, h2, <span class=\"class\">h3 </span>&#123;margin-bottom: <span class=\"number\">.8</span>em&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>子组合选择器和同层组合选择器：&gt;、+和~ 都支持使用</li>\n</ol>\n<p>&gt;:子组合选择器,用于选择一个元素的直接子元素<br>+:同层相邻组合选择器+选择header元素后紧跟的p元素<br>~:同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> ~ <span class=\"selector-tag\">article</span> &#123; <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> dashed <span class=\"number\">#ccc</span> &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>属性也可以嵌套</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: &#123;</span><br><span class=\"line\">  style: solid;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嵌套属性的规则：<br>把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、导入SASS文件\"><a href=\"#三、导入SASS文件\" class=\"headerlink\" title=\"三、导入SASS文件\"></a>三、导入SASS文件</h3><p>css原生的特性@import规则，允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。</p>\n<p>sass的@import规则，在生成css文件时，就会把相关样式导入进来。而且导入时，可以省略后缀的书写<br>如@import”sidebar”;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。</p>\n<p>常用的就以上几点了，记录一下方便以后翻阅。</p>\n<p>参考：<a href=\"https://www.sass.hk/guide/\" target=\"_blank\" rel=\"noopener\">https://www.sass.hk/guide/</a></p>\n","site":{"data":{}},"excerpt":"<p><figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/sass.jpg\"><br></figure></p>\n<h3 id=\"一-使用变量\"><a href=\"#一-使用变量\" class=\"headerlink\" title=\"一 使用变量\"></a>一 使用变量</h3><ol>\n<li><p>可以使用变量：<br>声明变量的方式：使用$符号，$highlight-color  $sidebar-width</p>\n</li>\n<li><p>变量存在作用域<br>作用域使用方式：类似ES6的块级作用域，使用{}区分作用域</p>","more":"</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$nav-color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"variable\">$width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$nav-color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>变量如何命名更好<br>sass的变量名可以包括中划线和下划线，如$highlight-color（更普遍）、$highlight_color ，在sass中，这两种写法的内容是互通的，比如，对sass来说$link-color和$link_color其实指向的是同一个变量，但是在sass中纯css部分不互通，比如类名、ID或属性名。</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$link</span>-<span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$link_color</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-嵌套CSS\"><a href=\"#二-嵌套CSS\" class=\"headerlink\" title=\"二 嵌套CSS\"></a>二 嵌套CSS</h3><ol>\n<li>可以避免书写重复的长串选择器</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">h1</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">1.4em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#EEE</span> &#125;</span><br><span class=\"line\"> <span class=\"comment\">/* 编译后 */</span></span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">h1</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">article</span> <span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">1.4em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">background-color</span>: <span class=\"number\">#EEE</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>例外情况：<br>比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构 &amp;。</p>\n<ol start=\"2\">\n<li>父选择器的标识符&amp;</li>\n</ol>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">  &amp;:hover &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">color</span>: blue &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span>:hover &#123; <span class=\"attribute\">color</span>: red &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>群组选择器的嵌套(减少重复敲写)<br>.container h1, .container h2, .container h3 { margin-bottom: .8em }<br>可以写成：</li>\n</ol>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"class\">container </span>&#123;</span><br><span class=\"line\">  h1, h2, <span class=\"class\">h3 </span>&#123;margin-bottom: <span class=\"number\">.8</span>em&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>子组合选择器和同层组合选择器：&gt;、+和~ 都支持使用</li>\n</ol>\n<p>&gt;:子组合选择器,用于选择一个元素的直接子元素<br>+:同层相邻组合选择器+选择header元素后紧跟的p元素<br>~:同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span> ~ <span class=\"selector-tag\">article</span> &#123; <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> dashed <span class=\"number\">#ccc</span> &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>属性也可以嵌套</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: &#123;</span><br><span class=\"line\">  style: solid;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嵌套属性的规则：<br>把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、导入SASS文件\"><a href=\"#三、导入SASS文件\" class=\"headerlink\" title=\"三、导入SASS文件\"></a>三、导入SASS文件</h3><p>css原生的特性@import规则，允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。</p>\n<p>sass的@import规则，在生成css文件时，就会把相关样式导入进来。而且导入时，可以省略后缀的书写<br>如@import”sidebar”;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。</p>\n<p>常用的就以上几点了，记录一下方便以后翻阅。</p>\n<p>参考：<a href=\"https://www.sass.hk/guide/\" target=\"_blank\" rel=\"noopener\">https://www.sass.hk/guide/</a></p>"},{"title":"Array、Object常用方法（ES3、ES5、ES6）","date":"2018-06-24T16:00:00.000Z","toc":true,"_content":"\n使用场景：\n使用react、vue等数据驱动的框架时，dom操作基本不用了，更多的是修改数据来驱动UI渲染。\n所以总结一下常用的方法，以提高coding效率~\n\n## 数组方法\n\n### 数组元素的添加和删除\n1. 为新索引赋值\n```\narr[0]=\"zero\"\n```\n2. 使用arr.push()在数组末尾增加一个或多个元素：\n```\narr.push(\"zero\")\n```\n3. 使用arr.pop()来从末尾推出一个值，并返回被推出的值\n\n4. 使用arr.shift()方法，从数组头部删除一个元素,返回被删除的元素，整个数组的index少1\n\n5. 使用arr.unshift()方法，从数组头部推入一个元素，返回新数组的长度\n\n6. 使用delete运算符来删除数组元素(原数组会变成稀疏数组)\n```\na=[1,2,3]\ndelete a[1];\n1 in a   //false\na.length //3 delete操作并不会影响数组长度  \n```\n7. 设置length属性为一个新的期望长度来删除数组 **末尾** 的元素arr\n\n8. splice()方法用来插入、删除、替换元素\n\n### 数组遍历\n\n1. for循环\n  Object.keys(arr)可以获得数组的下标\n\n2. for in (可以枚举继承的属性名，如添加到Array.property中的方法)\n```\n  for(var i in arr){\n    if(!a.hasOwnProperty(i)) continue;//跳过继承的属性\n    //循环体\n  }\n\n  或\n\n  for(var i in arr){\n    if(String(Math.floor(Math.abs(Number(i))))!==i) continue;//跳过不是非负整数的i\n  }\n```\n3. es5中提供了forEach()方法\n\n### 数组方法\n\n(ES3)\n1. Array.join()方法\n将数组中的所有元素转化为字符串并拼接在一起，\n```\nvar arr=[1,2,3,4];\narr.join(\",\")   //\"1,2,3,4\"\n```\nArray.join()方法是String.split()方法的逆向操作，后者是把字符串分割成若干块来创建一个数组。\n\n2. Array.reverse() （修改原数组）\n不通过用重新排列的元素创建新数组，而是在原先的数组中重新排列他们\n\n\n\n### 对象属性的遍历 ES6\n\nES6 一共有 5 种方法可以遍历对象的属性。\n\n（1）for...in\n\n  for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。\n\n（2）Object.keys(obj)\n\n  Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。\n\n（3）Object.getOwnPropertyNames(obj)\n\n  Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。\n\n（4）Object.getOwnPropertySymbols(obj)\n\n  Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。\n\n（5）Reflect.ownKeys(obj)\n  Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。\n\n以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。\n\n  - 首先遍历所有数值键，按照数值升序排列。\n  - 其次遍历所有字符串键，按照加入时间升序排列。\n  - 最后遍历所有 Symbol 键，按照加入时间升序排列。\n\n\n\n\n\n参考：\n https://segmentfault.com/a/1190000014100810?utm_source=index-hottest\n","source":"_posts/Array、Object常用方法.md","raw":"title: Array、Object常用方法（ES3、ES5、ES6）\ndate: 2018/06/25\ncategories: 前端基础\ntoc: true\ntags:\n  - ES6\n  - ES5\n---\n\n使用场景：\n使用react、vue等数据驱动的框架时，dom操作基本不用了，更多的是修改数据来驱动UI渲染。\n所以总结一下常用的方法，以提高coding效率~\n\n## 数组方法\n\n### 数组元素的添加和删除\n1. 为新索引赋值\n```\narr[0]=\"zero\"\n```\n2. 使用arr.push()在数组末尾增加一个或多个元素：\n```\narr.push(\"zero\")\n```\n3. 使用arr.pop()来从末尾推出一个值，并返回被推出的值\n\n4. 使用arr.shift()方法，从数组头部删除一个元素,返回被删除的元素，整个数组的index少1\n\n5. 使用arr.unshift()方法，从数组头部推入一个元素，返回新数组的长度\n\n6. 使用delete运算符来删除数组元素(原数组会变成稀疏数组)\n```\na=[1,2,3]\ndelete a[1];\n1 in a   //false\na.length //3 delete操作并不会影响数组长度  \n```\n7. 设置length属性为一个新的期望长度来删除数组 **末尾** 的元素arr\n\n8. splice()方法用来插入、删除、替换元素\n\n### 数组遍历\n\n1. for循环\n  Object.keys(arr)可以获得数组的下标\n\n2. for in (可以枚举继承的属性名，如添加到Array.property中的方法)\n```\n  for(var i in arr){\n    if(!a.hasOwnProperty(i)) continue;//跳过继承的属性\n    //循环体\n  }\n\n  或\n\n  for(var i in arr){\n    if(String(Math.floor(Math.abs(Number(i))))!==i) continue;//跳过不是非负整数的i\n  }\n```\n3. es5中提供了forEach()方法\n\n### 数组方法\n\n(ES3)\n1. Array.join()方法\n将数组中的所有元素转化为字符串并拼接在一起，\n```\nvar arr=[1,2,3,4];\narr.join(\",\")   //\"1,2,3,4\"\n```\nArray.join()方法是String.split()方法的逆向操作，后者是把字符串分割成若干块来创建一个数组。\n\n2. Array.reverse() （修改原数组）\n不通过用重新排列的元素创建新数组，而是在原先的数组中重新排列他们\n\n\n\n### 对象属性的遍历 ES6\n\nES6 一共有 5 种方法可以遍历对象的属性。\n\n（1）for...in\n\n  for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。\n\n（2）Object.keys(obj)\n\n  Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。\n\n（3）Object.getOwnPropertyNames(obj)\n\n  Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。\n\n（4）Object.getOwnPropertySymbols(obj)\n\n  Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。\n\n（5）Reflect.ownKeys(obj)\n  Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。\n\n以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。\n\n  - 首先遍历所有数值键，按照数值升序排列。\n  - 其次遍历所有字符串键，按照加入时间升序排列。\n  - 最后遍历所有 Symbol 键，按照加入时间升序排列。\n\n\n\n\n\n参考：\n https://segmentfault.com/a/1190000014100810?utm_source=index-hottest\n","slug":"Array、Object常用方法","published":1,"updated":"2018-07-05T15:06:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uwc00027q0t8ksgygrn","content":"<p>使用场景：<br>使用react、vue等数据驱动的框架时，dom操作基本不用了，更多的是修改数据来驱动UI渲染。<br>所以总结一下常用的方法，以提高coding效率~</p>\n<h2 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h2><h3 id=\"数组元素的添加和删除\"><a href=\"#数组元素的添加和删除\" class=\"headerlink\" title=\"数组元素的添加和删除\"></a>数组元素的添加和删除</h3><ol>\n<li><p>为新索引赋值</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">arr[0]</span>=<span class=\"string\">\"zero\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用arr.push()在数组末尾增加一个或多个元素：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.<span class=\"keyword\">push</span>(<span class=\"string\">\"zero\"</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用arr.pop()来从末尾推出一个值，并返回被推出的值</p>\n</li>\n<li><p>使用arr.shift()方法，从数组头部删除一个元素,返回被删除的元素，整个数组的index少1</p>\n</li>\n<li><p>使用arr.unshift()方法，从数组头部推入一个元素，返回新数组的长度</p>\n</li>\n<li><p>使用delete运算符来删除数组元素(原数组会变成稀疏数组)</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">delete a[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"number\">1</span> in a   <span class=\"comment\">//false</span></span><br><span class=\"line\">a.length <span class=\"comment\">//3 delete操作并不会影响数组长度</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置length属性为一个新的期望长度来删除数组 <strong>末尾</strong> 的元素arr</p>\n</li>\n<li><p>splice()方法用来插入、删除、替换元素</p>\n</li>\n</ol>\n<h3 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h3><ol>\n<li><p>for循环<br>Object.keys(arr)可以获得数组的下标</p>\n</li>\n<li><p>for in (可以枚举继承的属性名，如添加到Array.property中的方法)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> arr)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!a.hasOwnProperty(i)) <span class=\"keyword\">continue</span>;<span class=\"comment\">//跳过继承的属性</span></span><br><span class=\"line\">  <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">或</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> arr)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">String</span>(<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.abs(<span class=\"built_in\">Number</span>(i))))!==i) <span class=\"keyword\">continue</span>;<span class=\"comment\">//跳过不是非负整数的i</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>es5中提供了forEach()方法</p>\n</li>\n</ol>\n<h3 id=\"数组方法-1\"><a href=\"#数组方法-1\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h3><p>(ES3)</p>\n<ol>\n<li>Array.join()方法<br>将数组中的所有元素转化为字符串并拼接在一起，<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">arr.join(<span class=\"string\">\",\"</span>)   <span class=\"comment\">//\"1,2,3,4\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Array.join()方法是String.split()方法的逆向操作，后者是把字符串分割成若干块来创建一个数组。</p>\n<ol start=\"2\">\n<li>Array.reverse() （修改原数组）<br>不通过用重新排列的元素创建新数组，而是在原先的数组中重新排列他们</li>\n</ol>\n<h3 id=\"对象属性的遍历-ES6\"><a href=\"#对象属性的遍历-ES6\" class=\"headerlink\" title=\"对象属性的遍历 ES6\"></a>对象属性的遍历 ES6</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>\n<p>（1）for…in</p>\n<p>  for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>\n<p>（2）Object.keys(obj)</p>\n<p>  Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>\n<p>（3）Object.getOwnPropertyNames(obj)</p>\n<p>  Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>\n<p>（4）Object.getOwnPropertySymbols(obj)</p>\n<p>  Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>\n<p>（5）Reflect.ownKeys(obj)<br>  Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>\n<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>\n<ul>\n<li>首先遍历所有数值键，按照数值升序排列。</li>\n<li>其次遍历所有字符串键，按照加入时间升序排列。</li>\n<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>\n</ul>\n<p>参考：<br> <a href=\"https://segmentfault.com/a/1190000014100810?utm_source=index-hottest\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000014100810?utm_source=index-hottest</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用场景：<br>使用react、vue等数据驱动的框架时，dom操作基本不用了，更多的是修改数据来驱动UI渲染。<br>所以总结一下常用的方法，以提高coding效率~</p>\n<h2 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h2><h3 id=\"数组元素的添加和删除\"><a href=\"#数组元素的添加和删除\" class=\"headerlink\" title=\"数组元素的添加和删除\"></a>数组元素的添加和删除</h3><ol>\n<li><p>为新索引赋值</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">arr[0]</span>=<span class=\"string\">\"zero\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用arr.push()在数组末尾增加一个或多个元素：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.<span class=\"keyword\">push</span>(<span class=\"string\">\"zero\"</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用arr.pop()来从末尾推出一个值，并返回被推出的值</p>\n</li>\n<li><p>使用arr.shift()方法，从数组头部删除一个元素,返回被删除的元素，整个数组的index少1</p>\n</li>\n<li><p>使用arr.unshift()方法，从数组头部推入一个元素，返回新数组的长度</p>\n</li>\n<li><p>使用delete运算符来删除数组元素(原数组会变成稀疏数组)</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">delete a[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"number\">1</span> in a   <span class=\"comment\">//false</span></span><br><span class=\"line\">a.length <span class=\"comment\">//3 delete操作并不会影响数组长度</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置length属性为一个新的期望长度来删除数组 <strong>末尾</strong> 的元素arr</p>\n</li>\n<li><p>splice()方法用来插入、删除、替换元素</p>\n</li>\n</ol>\n<h3 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h3><ol>\n<li><p>for循环<br>Object.keys(arr)可以获得数组的下标</p>\n</li>\n<li><p>for in (可以枚举继承的属性名，如添加到Array.property中的方法)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> arr)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!a.hasOwnProperty(i)) <span class=\"keyword\">continue</span>;<span class=\"comment\">//跳过继承的属性</span></span><br><span class=\"line\">  <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">或</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> arr)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">String</span>(<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.abs(<span class=\"built_in\">Number</span>(i))))!==i) <span class=\"keyword\">continue</span>;<span class=\"comment\">//跳过不是非负整数的i</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>es5中提供了forEach()方法</p>\n</li>\n</ol>\n<h3 id=\"数组方法-1\"><a href=\"#数组方法-1\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h3><p>(ES3)</p>\n<ol>\n<li>Array.join()方法<br>将数组中的所有元素转化为字符串并拼接在一起，<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">arr.join(<span class=\"string\">\",\"</span>)   <span class=\"comment\">//\"1,2,3,4\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Array.join()方法是String.split()方法的逆向操作，后者是把字符串分割成若干块来创建一个数组。</p>\n<ol start=\"2\">\n<li>Array.reverse() （修改原数组）<br>不通过用重新排列的元素创建新数组，而是在原先的数组中重新排列他们</li>\n</ol>\n<h3 id=\"对象属性的遍历-ES6\"><a href=\"#对象属性的遍历-ES6\" class=\"headerlink\" title=\"对象属性的遍历 ES6\"></a>对象属性的遍历 ES6</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>\n<p>（1）for…in</p>\n<p>  for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>\n<p>（2）Object.keys(obj)</p>\n<p>  Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>\n<p>（3）Object.getOwnPropertyNames(obj)</p>\n<p>  Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>\n<p>（4）Object.getOwnPropertySymbols(obj)</p>\n<p>  Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>\n<p>（5）Reflect.ownKeys(obj)<br>  Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>\n<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>\n<ul>\n<li>首先遍历所有数值键，按照数值升序排列。</li>\n<li>其次遍历所有字符串键，按照加入时间升序排列。</li>\n<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>\n</ul>\n<p>参考：<br> <a href=\"https://segmentfault.com/a/1190000014100810?utm_source=index-hottest\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000014100810?utm_source=index-hottest</a></p>\n"},{"title":"CDN工作机制以及原理浅析","date":"2018-07-20T16:00:00.000Z","toc":true,"_content":"\n在前端性能优化中，使用CDN加速也是重要的优化手段。那么CDN的工作机制以及原理到底是什么呢？本文将对此做一个简单介绍\n\n### 什么是CDN?\nCDN内容分布网络（ContentDelivery Network）是构筑在现有的Internet上的一种先进的流量分配网络。\n\n- 其目的是在现有的Internet上增加一层新的网络架构，将网站的内容发布到最接近用户的服务器，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。\n\n- 一个CND架构 = 镜像（Mirror）+ 缓存（Cache）+整体负载均衡（GSLB）\n<!--more-->\n\n### 请求CDN上的资源的过程\n![](https://raw.githubusercontent.com/shengyur/Images/master/cdn.jpg)\n\n1. 用户向浏览器输入 www.xxxx.com 这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求；\n\n2. 网站的DNS域名解析器设置了CNAME，指向了www.xxxx.com ,请求指向了CDN网络中的智能DNS负载均衡系统；\n\n3. **智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；**\n\n4. 用户向该IP节点（CDN服务器）发出请求；\n\n5. 由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；\n\n6. 请求结果发给用户。\n\n**CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，这就是CDN的最基本的原理。**\n\n当用户访问加入CDN服务的网站时，域名解析请求将最终交给 **全局负载均衡DNS** 进行处理。全局负载均衡DNS通过 **一组预先定义好的策略** ，将 **当时最接近用户的节点地址** 提供给用户，使用户能够得到快速的服务。同时，它还 **与分布在世界各地的所有CDN节点保持通信** ，搜集各节点的通信状态，确保不将用户的请求 **分配到不可用的CDN节点上** ，实际上是 **通过DNS做全局负载均衡。**\n\n\n对于普通的Internet用户来讲，每个CDN节点就相当于一个放置在它周围的WEB。通过全局负载均衡DNS的控制，用户的请求被透明地指向离他最近的节点，节点中CDN服务器会像网站的原始服务器一样，响应用户的请求。由于它离用户更近，因而响应时间必然更快。\n\n*每个CDN节点由两部分组成:负载均衡设备和高速缓存服务器*\n\n- 负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率;\n- 同时，负载均衡设备还负责收集节点与周围环境的信息，保持与全局负载DNS的通信，实现整个系统的负载均衡。\nCDN的管理系统是整个系统能够正常运转的保证。它不仅能对系统中的各个子系统和设备进行实时监控，对各种故障产生相应的告警，还可以实时监测到系统中 总的流量和各节点的流量，并保存在系统的数据库中，使网管人员能够方便地进行进一步分析。通过完善的网管系统，用户可以对系统配置进行修改。\n\n**理论上，最简单的CDN网络有一个负责全局负载均衡的DNS和各节点一台Cache，即可运行。DNS支持根据用户源IP地址解析不同的IP，实现 就近访问。为了保证高可用性等，需要监视各节点的流量、健康状况等。一个节点的单台Cache承载数量不够时，才需要多台Cache，多台Cache同时 工作，才需要负载均衡器，使Cache群协同工作。**\n\n\n### cdn网络加速常见问题解答\n\n1. cdn网络加速比较适合那些类型的网站？\n\n    ① 资讯网站：信息咨询网站. 政府网站、行业网站、商城网站等 ；\n\n    ② 动态网站，论坛、博客、交友、网络游戏、搜索/查询等；\n\n    ③ 提供http下载的网站：软件开发商、内容服务提供商、网络游戏运行商、源码下载等 ；\n\n    ④ 有大量流媒体应用的网站：视频点播平台、体育频道、在线教育、视频博客等网站类型。\n\n2. cdn网络加速是对服务器加速，还是对域名加速？\n\n    cdn网络加速是只对网站的某一个具体的域名进行加速。如果一个网站有多个域名，则访客访问加入cdn网络加速的域名获得加速效果，访问未加入cdn网络加速的域名，则无法获得cdn网络加速效果。\n\n3. 使用cdn网络加速后，原网站是否需要进行修改？\n\n    一般而言，网站无需任何修改，即可使用cdn网络加速获得加速效果。\n\n4. 为什么更新网站后，通过cdn网络加速后看到网页还是旧网页，怎么解决？\n\n    由于cdn网络加速采用各节点缓存的机制，网站的静态网页和图片修改后，如果cdn缓存没有做相应更新，则看到的还是旧的网页。我们可在cdn网络加速管理面板中，通知cdn各节点来刷新自己的缓存。\n\n    注意：在URL推送地址栏中，输入具体的网址或者图片地址，则各节点中的缓存内容即被统一删除，并且当即生效，如果需要推送的网址和图片太多，可以选择目录推送。\n\n5. 启用cdn网络加速后，多长时间生效？\n\n    启用cdn网络加速后，最快1个小时即可生效，慢的话需要8个小时生效。若超过12个小时还未生效，估计是大家在操作流程上有失误，大部分情况便是没有指定的流程进行操作。\n\n6. 网站启用cdn网络加速后，有些地区无法访问，怎么解决？\n\n    cdn网络加速启用后，若某些地区不能正常访问，大致有以下几种原因：\n\n    ① cdn网络加速的问题；\n\n    ② 源站点出现故障；\n\n    ③ 源站点被关闭；\n\n    ④ 访客自己的网络故障。\n\n\n\n  原文：\n  http://host.zzidc.com/wljc/1048.html\n  https://blog.csdn.net/u011159417/article/details/53694603\n  https://blog.csdn.net/coolmeme/article/details/9468743\n","source":"_posts/CDN工作机制以及原理浅析.md","raw":"title: CDN工作机制以及原理浅析\ndate: 2018/07/21\ncategories: 性能优化\ntoc: true\ntags:\n  - 性能\n  - CDN\n---\n\n在前端性能优化中，使用CDN加速也是重要的优化手段。那么CDN的工作机制以及原理到底是什么呢？本文将对此做一个简单介绍\n\n### 什么是CDN?\nCDN内容分布网络（ContentDelivery Network）是构筑在现有的Internet上的一种先进的流量分配网络。\n\n- 其目的是在现有的Internet上增加一层新的网络架构，将网站的内容发布到最接近用户的服务器，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。\n\n- 一个CND架构 = 镜像（Mirror）+ 缓存（Cache）+整体负载均衡（GSLB）\n<!--more-->\n\n### 请求CDN上的资源的过程\n![](https://raw.githubusercontent.com/shengyur/Images/master/cdn.jpg)\n\n1. 用户向浏览器输入 www.xxxx.com 这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求；\n\n2. 网站的DNS域名解析器设置了CNAME，指向了www.xxxx.com ,请求指向了CDN网络中的智能DNS负载均衡系统；\n\n3. **智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；**\n\n4. 用户向该IP节点（CDN服务器）发出请求；\n\n5. 由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；\n\n6. 请求结果发给用户。\n\n**CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，这就是CDN的最基本的原理。**\n\n当用户访问加入CDN服务的网站时，域名解析请求将最终交给 **全局负载均衡DNS** 进行处理。全局负载均衡DNS通过 **一组预先定义好的策略** ，将 **当时最接近用户的节点地址** 提供给用户，使用户能够得到快速的服务。同时，它还 **与分布在世界各地的所有CDN节点保持通信** ，搜集各节点的通信状态，确保不将用户的请求 **分配到不可用的CDN节点上** ，实际上是 **通过DNS做全局负载均衡。**\n\n\n对于普通的Internet用户来讲，每个CDN节点就相当于一个放置在它周围的WEB。通过全局负载均衡DNS的控制，用户的请求被透明地指向离他最近的节点，节点中CDN服务器会像网站的原始服务器一样，响应用户的请求。由于它离用户更近，因而响应时间必然更快。\n\n*每个CDN节点由两部分组成:负载均衡设备和高速缓存服务器*\n\n- 负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率;\n- 同时，负载均衡设备还负责收集节点与周围环境的信息，保持与全局负载DNS的通信，实现整个系统的负载均衡。\nCDN的管理系统是整个系统能够正常运转的保证。它不仅能对系统中的各个子系统和设备进行实时监控，对各种故障产生相应的告警，还可以实时监测到系统中 总的流量和各节点的流量，并保存在系统的数据库中，使网管人员能够方便地进行进一步分析。通过完善的网管系统，用户可以对系统配置进行修改。\n\n**理论上，最简单的CDN网络有一个负责全局负载均衡的DNS和各节点一台Cache，即可运行。DNS支持根据用户源IP地址解析不同的IP，实现 就近访问。为了保证高可用性等，需要监视各节点的流量、健康状况等。一个节点的单台Cache承载数量不够时，才需要多台Cache，多台Cache同时 工作，才需要负载均衡器，使Cache群协同工作。**\n\n\n### cdn网络加速常见问题解答\n\n1. cdn网络加速比较适合那些类型的网站？\n\n    ① 资讯网站：信息咨询网站. 政府网站、行业网站、商城网站等 ；\n\n    ② 动态网站，论坛、博客、交友、网络游戏、搜索/查询等；\n\n    ③ 提供http下载的网站：软件开发商、内容服务提供商、网络游戏运行商、源码下载等 ；\n\n    ④ 有大量流媒体应用的网站：视频点播平台、体育频道、在线教育、视频博客等网站类型。\n\n2. cdn网络加速是对服务器加速，还是对域名加速？\n\n    cdn网络加速是只对网站的某一个具体的域名进行加速。如果一个网站有多个域名，则访客访问加入cdn网络加速的域名获得加速效果，访问未加入cdn网络加速的域名，则无法获得cdn网络加速效果。\n\n3. 使用cdn网络加速后，原网站是否需要进行修改？\n\n    一般而言，网站无需任何修改，即可使用cdn网络加速获得加速效果。\n\n4. 为什么更新网站后，通过cdn网络加速后看到网页还是旧网页，怎么解决？\n\n    由于cdn网络加速采用各节点缓存的机制，网站的静态网页和图片修改后，如果cdn缓存没有做相应更新，则看到的还是旧的网页。我们可在cdn网络加速管理面板中，通知cdn各节点来刷新自己的缓存。\n\n    注意：在URL推送地址栏中，输入具体的网址或者图片地址，则各节点中的缓存内容即被统一删除，并且当即生效，如果需要推送的网址和图片太多，可以选择目录推送。\n\n5. 启用cdn网络加速后，多长时间生效？\n\n    启用cdn网络加速后，最快1个小时即可生效，慢的话需要8个小时生效。若超过12个小时还未生效，估计是大家在操作流程上有失误，大部分情况便是没有指定的流程进行操作。\n\n6. 网站启用cdn网络加速后，有些地区无法访问，怎么解决？\n\n    cdn网络加速启用后，若某些地区不能正常访问，大致有以下几种原因：\n\n    ① cdn网络加速的问题；\n\n    ② 源站点出现故障；\n\n    ③ 源站点被关闭；\n\n    ④ 访客自己的网络故障。\n\n\n\n  原文：\n  http://host.zzidc.com/wljc/1048.html\n  https://blog.csdn.net/u011159417/article/details/53694603\n  https://blog.csdn.net/coolmeme/article/details/9468743\n","slug":"CDN工作机制以及原理浅析","published":1,"updated":"2018-07-22T01:55:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uwi00057q0t9e6h4wm0","content":"<p>在前端性能优化中，使用CDN加速也是重要的优化手段。那么CDN的工作机制以及原理到底是什么呢？本文将对此做一个简单介绍</p>\n<h3 id=\"什么是CDN\"><a href=\"#什么是CDN\" class=\"headerlink\" title=\"什么是CDN?\"></a>什么是CDN?</h3><p>CDN内容分布网络（ContentDelivery Network）是构筑在现有的Internet上的一种先进的流量分配网络。</p>\n<ul>\n<li><p>其目的是在现有的Internet上增加一层新的网络架构，将网站的内容发布到最接近用户的服务器，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</p>\n</li>\n<li><p>一个CND架构 = 镜像（Mirror）+ 缓存（Cache）+整体负载均衡（GSLB）</p>\n<a id=\"more\"></a>\n</li>\n</ul>\n<h3 id=\"请求CDN上的资源的过程\"><a href=\"#请求CDN上的资源的过程\" class=\"headerlink\" title=\"请求CDN上的资源的过程\"></a>请求CDN上的资源的过程</h3><p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/cdn.jpg\" alt=\"\"></p>\n<ol>\n<li><p>用户向浏览器输入 <a href=\"http://www.xxxx.com\" target=\"_blank\" rel=\"noopener\">www.xxxx.com</a> 这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求；</p>\n</li>\n<li><p>网站的DNS域名解析器设置了CNAME，指向了<a href=\"http://www.xxxx.com\" target=\"_blank\" rel=\"noopener\">www.xxxx.com</a> ,请求指向了CDN网络中的智能DNS负载均衡系统；</p>\n</li>\n<li><p><strong>智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；</strong></p>\n</li>\n<li><p>用户向该IP节点（CDN服务器）发出请求；</p>\n</li>\n<li><p>由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；</p>\n</li>\n<li><p>请求结果发给用户。</p>\n</li>\n</ol>\n<p><strong>CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，这就是CDN的最基本的原理。</strong></p>\n<p>当用户访问加入CDN服务的网站时，域名解析请求将最终交给 <strong>全局负载均衡DNS</strong> 进行处理。全局负载均衡DNS通过 <strong>一组预先定义好的策略</strong> ，将 <strong>当时最接近用户的节点地址</strong> 提供给用户，使用户能够得到快速的服务。同时，它还 <strong>与分布在世界各地的所有CDN节点保持通信</strong> ，搜集各节点的通信状态，确保不将用户的请求 <strong>分配到不可用的CDN节点上</strong> ，实际上是 <strong>通过DNS做全局负载均衡。</strong></p>\n<p>对于普通的Internet用户来讲，每个CDN节点就相当于一个放置在它周围的WEB。通过全局负载均衡DNS的控制，用户的请求被透明地指向离他最近的节点，节点中CDN服务器会像网站的原始服务器一样，响应用户的请求。由于它离用户更近，因而响应时间必然更快。</p>\n<p><em>每个CDN节点由两部分组成:负载均衡设备和高速缓存服务器</em></p>\n<ul>\n<li>负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率;</li>\n<li>同时，负载均衡设备还负责收集节点与周围环境的信息，保持与全局负载DNS的通信，实现整个系统的负载均衡。<br>CDN的管理系统是整个系统能够正常运转的保证。它不仅能对系统中的各个子系统和设备进行实时监控，对各种故障产生相应的告警，还可以实时监测到系统中 总的流量和各节点的流量，并保存在系统的数据库中，使网管人员能够方便地进行进一步分析。通过完善的网管系统，用户可以对系统配置进行修改。</li>\n</ul>\n<p><strong>理论上，最简单的CDN网络有一个负责全局负载均衡的DNS和各节点一台Cache，即可运行。DNS支持根据用户源IP地址解析不同的IP，实现 就近访问。为了保证高可用性等，需要监视各节点的流量、健康状况等。一个节点的单台Cache承载数量不够时，才需要多台Cache，多台Cache同时 工作，才需要负载均衡器，使Cache群协同工作。</strong></p>\n<h3 id=\"cdn网络加速常见问题解答\"><a href=\"#cdn网络加速常见问题解答\" class=\"headerlink\" title=\"cdn网络加速常见问题解答\"></a>cdn网络加速常见问题解答</h3><ol>\n<li><p>cdn网络加速比较适合那些类型的网站？</p>\n<p> ① 资讯网站：信息咨询网站. 政府网站、行业网站、商城网站等 ；</p>\n<p> ② 动态网站，论坛、博客、交友、网络游戏、搜索/查询等；</p>\n<p> ③ 提供http下载的网站：软件开发商、内容服务提供商、网络游戏运行商、源码下载等 ；</p>\n<p> ④ 有大量流媒体应用的网站：视频点播平台、体育频道、在线教育、视频博客等网站类型。</p>\n</li>\n<li><p>cdn网络加速是对服务器加速，还是对域名加速？</p>\n<p> cdn网络加速是只对网站的某一个具体的域名进行加速。如果一个网站有多个域名，则访客访问加入cdn网络加速的域名获得加速效果，访问未加入cdn网络加速的域名，则无法获得cdn网络加速效果。</p>\n</li>\n<li><p>使用cdn网络加速后，原网站是否需要进行修改？</p>\n<p> 一般而言，网站无需任何修改，即可使用cdn网络加速获得加速效果。</p>\n</li>\n<li><p>为什么更新网站后，通过cdn网络加速后看到网页还是旧网页，怎么解决？</p>\n<p> 由于cdn网络加速采用各节点缓存的机制，网站的静态网页和图片修改后，如果cdn缓存没有做相应更新，则看到的还是旧的网页。我们可在cdn网络加速管理面板中，通知cdn各节点来刷新自己的缓存。</p>\n<p> 注意：在URL推送地址栏中，输入具体的网址或者图片地址，则各节点中的缓存内容即被统一删除，并且当即生效，如果需要推送的网址和图片太多，可以选择目录推送。</p>\n</li>\n<li><p>启用cdn网络加速后，多长时间生效？</p>\n<p> 启用cdn网络加速后，最快1个小时即可生效，慢的话需要8个小时生效。若超过12个小时还未生效，估计是大家在操作流程上有失误，大部分情况便是没有指定的流程进行操作。</p>\n</li>\n<li><p>网站启用cdn网络加速后，有些地区无法访问，怎么解决？</p>\n<p> cdn网络加速启用后，若某些地区不能正常访问，大致有以下几种原因：</p>\n<p> ① cdn网络加速的问题；</p>\n<p> ② 源站点出现故障；</p>\n<p> ③ 源站点被关闭；</p>\n<p> ④ 访客自己的网络故障。</p>\n</li>\n</ol>\n<p>  原文：<br>  <a href=\"http://host.zzidc.com/wljc/1048.html\" target=\"_blank\" rel=\"noopener\">http://host.zzidc.com/wljc/1048.html</a><br>  <a href=\"https://blog.csdn.net/u011159417/article/details/53694603\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011159417/article/details/53694603</a><br>  <a href=\"https://blog.csdn.net/coolmeme/article/details/9468743\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/coolmeme/article/details/9468743</a></p>\n","site":{"data":{}},"excerpt":"<p>在前端性能优化中，使用CDN加速也是重要的优化手段。那么CDN的工作机制以及原理到底是什么呢？本文将对此做一个简单介绍</p>\n<h3 id=\"什么是CDN\"><a href=\"#什么是CDN\" class=\"headerlink\" title=\"什么是CDN?\"></a>什么是CDN?</h3><p>CDN内容分布网络（ContentDelivery Network）是构筑在现有的Internet上的一种先进的流量分配网络。</p>\n<ul>\n<li><p>其目的是在现有的Internet上增加一层新的网络架构，将网站的内容发布到最接近用户的服务器，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</p>\n</li>\n<li><p>一个CND架构 = 镜像（Mirror）+ 缓存（Cache）+整体负载均衡（GSLB）</p>","more":"</li>\n</ul>\n<h3 id=\"请求CDN上的资源的过程\"><a href=\"#请求CDN上的资源的过程\" class=\"headerlink\" title=\"请求CDN上的资源的过程\"></a>请求CDN上的资源的过程</h3><p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/cdn.jpg\" alt=\"\"></p>\n<ol>\n<li><p>用户向浏览器输入 <a href=\"http://www.xxxx.com\" target=\"_blank\" rel=\"noopener\">www.xxxx.com</a> 这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求；</p>\n</li>\n<li><p>网站的DNS域名解析器设置了CNAME，指向了<a href=\"http://www.xxxx.com\" target=\"_blank\" rel=\"noopener\">www.xxxx.com</a> ,请求指向了CDN网络中的智能DNS负载均衡系统；</p>\n</li>\n<li><p><strong>智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；</strong></p>\n</li>\n<li><p>用户向该IP节点（CDN服务器）发出请求；</p>\n</li>\n<li><p>由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；</p>\n</li>\n<li><p>请求结果发给用户。</p>\n</li>\n</ol>\n<p><strong>CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，这就是CDN的最基本的原理。</strong></p>\n<p>当用户访问加入CDN服务的网站时，域名解析请求将最终交给 <strong>全局负载均衡DNS</strong> 进行处理。全局负载均衡DNS通过 <strong>一组预先定义好的策略</strong> ，将 <strong>当时最接近用户的节点地址</strong> 提供给用户，使用户能够得到快速的服务。同时，它还 <strong>与分布在世界各地的所有CDN节点保持通信</strong> ，搜集各节点的通信状态，确保不将用户的请求 <strong>分配到不可用的CDN节点上</strong> ，实际上是 <strong>通过DNS做全局负载均衡。</strong></p>\n<p>对于普通的Internet用户来讲，每个CDN节点就相当于一个放置在它周围的WEB。通过全局负载均衡DNS的控制，用户的请求被透明地指向离他最近的节点，节点中CDN服务器会像网站的原始服务器一样，响应用户的请求。由于它离用户更近，因而响应时间必然更快。</p>\n<p><em>每个CDN节点由两部分组成:负载均衡设备和高速缓存服务器</em></p>\n<ul>\n<li>负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率;</li>\n<li>同时，负载均衡设备还负责收集节点与周围环境的信息，保持与全局负载DNS的通信，实现整个系统的负载均衡。<br>CDN的管理系统是整个系统能够正常运转的保证。它不仅能对系统中的各个子系统和设备进行实时监控，对各种故障产生相应的告警，还可以实时监测到系统中 总的流量和各节点的流量，并保存在系统的数据库中，使网管人员能够方便地进行进一步分析。通过完善的网管系统，用户可以对系统配置进行修改。</li>\n</ul>\n<p><strong>理论上，最简单的CDN网络有一个负责全局负载均衡的DNS和各节点一台Cache，即可运行。DNS支持根据用户源IP地址解析不同的IP，实现 就近访问。为了保证高可用性等，需要监视各节点的流量、健康状况等。一个节点的单台Cache承载数量不够时，才需要多台Cache，多台Cache同时 工作，才需要负载均衡器，使Cache群协同工作。</strong></p>\n<h3 id=\"cdn网络加速常见问题解答\"><a href=\"#cdn网络加速常见问题解答\" class=\"headerlink\" title=\"cdn网络加速常见问题解答\"></a>cdn网络加速常见问题解答</h3><ol>\n<li><p>cdn网络加速比较适合那些类型的网站？</p>\n<p> ① 资讯网站：信息咨询网站. 政府网站、行业网站、商城网站等 ；</p>\n<p> ② 动态网站，论坛、博客、交友、网络游戏、搜索/查询等；</p>\n<p> ③ 提供http下载的网站：软件开发商、内容服务提供商、网络游戏运行商、源码下载等 ；</p>\n<p> ④ 有大量流媒体应用的网站：视频点播平台、体育频道、在线教育、视频博客等网站类型。</p>\n</li>\n<li><p>cdn网络加速是对服务器加速，还是对域名加速？</p>\n<p> cdn网络加速是只对网站的某一个具体的域名进行加速。如果一个网站有多个域名，则访客访问加入cdn网络加速的域名获得加速效果，访问未加入cdn网络加速的域名，则无法获得cdn网络加速效果。</p>\n</li>\n<li><p>使用cdn网络加速后，原网站是否需要进行修改？</p>\n<p> 一般而言，网站无需任何修改，即可使用cdn网络加速获得加速效果。</p>\n</li>\n<li><p>为什么更新网站后，通过cdn网络加速后看到网页还是旧网页，怎么解决？</p>\n<p> 由于cdn网络加速采用各节点缓存的机制，网站的静态网页和图片修改后，如果cdn缓存没有做相应更新，则看到的还是旧的网页。我们可在cdn网络加速管理面板中，通知cdn各节点来刷新自己的缓存。</p>\n<p> 注意：在URL推送地址栏中，输入具体的网址或者图片地址，则各节点中的缓存内容即被统一删除，并且当即生效，如果需要推送的网址和图片太多，可以选择目录推送。</p>\n</li>\n<li><p>启用cdn网络加速后，多长时间生效？</p>\n<p> 启用cdn网络加速后，最快1个小时即可生效，慢的话需要8个小时生效。若超过12个小时还未生效，估计是大家在操作流程上有失误，大部分情况便是没有指定的流程进行操作。</p>\n</li>\n<li><p>网站启用cdn网络加速后，有些地区无法访问，怎么解决？</p>\n<p> cdn网络加速启用后，若某些地区不能正常访问，大致有以下几种原因：</p>\n<p> ① cdn网络加速的问题；</p>\n<p> ② 源站点出现故障；</p>\n<p> ③ 源站点被关闭；</p>\n<p> ④ 访客自己的网络故障。</p>\n</li>\n</ol>\n<p>  原文：<br>  <a href=\"http://host.zzidc.com/wljc/1048.html\" target=\"_blank\" rel=\"noopener\">http://host.zzidc.com/wljc/1048.html</a><br>  <a href=\"https://blog.csdn.net/u011159417/article/details/53694603\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011159417/article/details/53694603</a><br>  <a href=\"https://blog.csdn.net/coolmeme/article/details/9468743\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/coolmeme/article/details/9468743</a></p>"},{"title":"ES6 Class的继承之super关键字","date":"2018-05-21T16:00:00.000Z","_content":"\nsuper关键字有两种用法，既可以当成函数使用，也可以当成对象使用。在这两种情况下，它的用法完全不同。\n\n在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。\n\n1. 当super作为函数调用时\nsuper作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n\n```\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();//调用父类的构造函数，否则会报错\n  }\n}\n```\n\n注意：\nsuper虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。\n<!--more-->\n\n\n```\nclass A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n```\n\n上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。\n**作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错**\n\n提示：\nnew.target属性，一般用在构造函数之中，返回new命令作用于的那个构造函数。\n\n2. super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\n```\nclass Human {\n  constructor() {}\n  static ping() {\n    return 'ping';\n  }\n}\nclass Computer extends Human {\n  constructor() {}\n  static pingpong() {\n    return super.ping() + ' pong';//在 静态方法 中，super指向父类\n  }\n}\nComputer.pingpong(); // 'ping pong'\n```\n\n提示：\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法 **不会被实例继承，而是直接通过类来调用**，这就称为“静态方法”。\n\n```\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2 在普通方法中，super指向父类的原型对象\n  }\n}\n\nlet b = new B();\n```\n\n上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\n这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。\n\n```\nclass A {\n  constructor() {\n    this.p = 2;\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\n上面代码中，p是父类A实例的属性，super.p就引用不到它。\n\n如果属性定义在父类的原型对象上，super就可以取到。\n\nES6 规定,**在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例**。\n\n```\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super(); //this指向当前的子类实例--b\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n```\n\n由于this指向子类实例，所以 **如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性**。\n\n```\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;  //b.x=2\n    super.x = 3;  //this.x=3\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n```\n\n\n\n参考：\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\nhttp://es6.ruanyifeng.com/?search=prop&x=0&y=0#docs/class-extends\n","source":"_posts/ES6_super.md","raw":"title: ES6 Class的继承之super关键字\ndate: 2018/05/22\ncategories: 前端基础\ntags:\n  - ES6\n---\n\nsuper关键字有两种用法，既可以当成函数使用，也可以当成对象使用。在这两种情况下，它的用法完全不同。\n\n在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。\n\n1. 当super作为函数调用时\nsuper作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n\n```\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();//调用父类的构造函数，否则会报错\n  }\n}\n```\n\n注意：\nsuper虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。\n<!--more-->\n\n\n```\nclass A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n```\n\n上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。\n**作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错**\n\n提示：\nnew.target属性，一般用在构造函数之中，返回new命令作用于的那个构造函数。\n\n2. super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\n```\nclass Human {\n  constructor() {}\n  static ping() {\n    return 'ping';\n  }\n}\nclass Computer extends Human {\n  constructor() {}\n  static pingpong() {\n    return super.ping() + ' pong';//在 静态方法 中，super指向父类\n  }\n}\nComputer.pingpong(); // 'ping pong'\n```\n\n提示：\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法 **不会被实例继承，而是直接通过类来调用**，这就称为“静态方法”。\n\n```\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2 在普通方法中，super指向父类的原型对象\n  }\n}\n\nlet b = new B();\n```\n\n上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\n这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。\n\n```\nclass A {\n  constructor() {\n    this.p = 2;\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\n上面代码中，p是父类A实例的属性，super.p就引用不到它。\n\n如果属性定义在父类的原型对象上，super就可以取到。\n\nES6 规定,**在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例**。\n\n```\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super(); //this指向当前的子类实例--b\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n```\n\n由于this指向子类实例，所以 **如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性**。\n\n```\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;  //b.x=2\n    super.x = 3;  //this.x=3\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n```\n\n\n\n参考：\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\nhttp://es6.ruanyifeng.com/?search=prop&x=0&y=0#docs/class-extends\n","slug":"ES6_super","published":1,"updated":"2018-06-16T12:01:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uwj00067q0tv9y7vex9","content":"<p>super关键字有两种用法，既可以当成函数使用，也可以当成对象使用。在这两种情况下，它的用法完全不同。</p>\n<p>在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。</p>\n<ol>\n<li>当super作为函数调用时<br>super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();<span class=\"comment\">//调用父类的构造函数，否则会报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：<br>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。<br><a id=\"more\"></a></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    console.log(<span class=\"keyword\">new</span>.target.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。<br><strong>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错</strong></p>\n<p>提示：<br>new.target属性，一般用在构造函数之中，返回new命令作用于的那个构造函数。</p>\n<ol start=\"2\">\n<li>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">  static ping() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"symbol\">'pin</span>g';</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Computer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">  static pingpong() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.ping() + ' pong';<span class=\"comment\">//在 静态方法 中，super指向父类</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">Computer</span>.pingpong(); <span class=\"comment\">// 'ping pong'</span></span><br></pre></td></tr></table></figure>\n<p>提示：<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法 <strong>不会被实例继承，而是直接通过类来调用</strong>，这就称为“静态方法”。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  p() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    console.log(<span class=\"keyword\">super</span>.p()); <span class=\"comment\">// 2 在普通方法中，super指向父类的原型对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br></pre></td></tr></table></figure>\n<p>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。<br>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.p = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  get m() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br><span class=\"line\">b.m <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p>\n<p>如果属性定义在父类的原型对象上，super就可以取到。</p>\n<p>ES6 规定,<strong>在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</strong>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  print() &#123;</span><br><span class=\"line\">    console.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(); <span class=\"comment\">//this指向当前的子类实例--b</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  m() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.print();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br><span class=\"line\">b.m() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>由于this指向子类实例，所以 <strong>如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性</strong>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;  <span class=\"comment\">//b.x=2</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.x = <span class=\"number\">3</span>;  <span class=\"comment\">//this.x=3</span></span><br><span class=\"line\">    console.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    console.log(<span class=\"keyword\">this</span>.x); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super</a><br><a href=\"http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends</a></p>\n","site":{"data":{}},"excerpt":"<p>super关键字有两种用法，既可以当成函数使用，也可以当成对象使用。在这两种情况下，它的用法完全不同。</p>\n<p>在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。</p>\n<ol>\n<li>当super作为函数调用时<br>super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();<span class=\"comment\">//调用父类的构造函数，否则会报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：<br>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。<br>","more":"</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    console.log(<span class=\"keyword\">new</span>.target.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。<br><strong>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错</strong></p>\n<p>提示：<br>new.target属性，一般用在构造函数之中，返回new命令作用于的那个构造函数。</p>\n<ol start=\"2\">\n<li>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">  static ping() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"symbol\">'pin</span>g';</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Computer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">  static pingpong() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.ping() + ' pong';<span class=\"comment\">//在 静态方法 中，super指向父类</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">Computer</span>.pingpong(); <span class=\"comment\">// 'ping pong'</span></span><br></pre></td></tr></table></figure>\n<p>提示：<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法 <strong>不会被实例继承，而是直接通过类来调用</strong>，这就称为“静态方法”。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  p() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    console.log(<span class=\"keyword\">super</span>.p()); <span class=\"comment\">// 2 在普通方法中，super指向父类的原型对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br></pre></td></tr></table></figure>\n<p>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。<br>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.p = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  get m() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br><span class=\"line\">b.m <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p>\n<p>如果属性定义在父类的原型对象上，super就可以取到。</p>\n<p>ES6 规定,<strong>在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</strong>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  print() &#123;</span><br><span class=\"line\">    console.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(); <span class=\"comment\">//this指向当前的子类实例--b</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  m() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.print();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br><span class=\"line\">b.m() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>由于this指向子类实例，所以 <strong>如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性</strong>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;  <span class=\"comment\">//b.x=2</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.x = <span class=\"number\">3</span>;  <span class=\"comment\">//this.x=3</span></span><br><span class=\"line\">    console.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    console.log(<span class=\"keyword\">this</span>.x); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let b = <span class=\"keyword\">new</span> <span class=\"type\">B</span>();</span><br></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super</a><br><a href=\"http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends</a></p>"},{"title":"ES6之扩展运算符与应用","date":"2018-07-19T16:00:00.000Z","_content":"\n在使用react的过程中，会有如下写法\n```\nconst data={name:\"ssdfin\"，value:1}\nconst component = <Component {...data}>\n```\n发现对 ... 三个点理解不是很深，所以单独记录下 ES6 rest/spread 特性\n\n### 扩展运算符(spread)\n\n1. 场景1：使用在数组之前。\n作用：将一个数组转为用逗号分隔的参数序列\n\n```javascript\nfunction foo(x, y, z){\n    console.log(x, y, z)\n}\nfoo.apply(null, [1, 2, 3])　　//在ES6之前我们这样使用数组作为函数参数调用。\nfoo(...[1, 2, 3])　　//此处...[1, 2, 3]就被展开为用逗号隔开的1, 2, 3参数序列\n```\n\n　当运算符\"...\"用在数组之前时，数组会被转为用逗号分隔的参数序列。\n\n2. 场景2：替代apply()方法\n\n```JavaScript\n// ES5的 写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nArray.prototype.push.apply(arr1, arr2);　　//push方法参数不能为数组，ES5需要借助apply()方法实现。\n\n// ES6 的写法\nlet arr1 = [0, 1, 2];\nlet arr2 = [3, 4, 5];\narr1.push(...arr2);　　　　　　　　　　　　　　//ES6中借助扩展运算符直接将数组转为了参数序列。\n```\n\n3. 场景3：替代数组的concat()方法\n\n```javascript\nlet a = [2, 3, 4]\nlet b = [1, ...a, 5]    //此处a数组被展开为2, 3, 4\nconsole.log(b)          //结果为[1, 2, 3, 4, 5]\n```\n上面的用法基本上替代了concat(..)，这里的行为就像[1].concat(a, [5])\n\n注意：扩展运算符后如果是空数组，不会产生任何效果\n\n```javascript\n[...[], 1]\n// [1]\n```\n\n\n### 收集运算符(rest)\n\n作用：收集剩余的参数转为一个数组。\n\n　　场景：在函数参数之前使用。\n\n1. 场景1：函数参数之前\n```javascript\n\n\nfunction foo(x, y, ...z){   //z表示把剩余的参数收集到一起组成一个名叫z的数组。\n    console.log(x, y, z)\n}\nfoo(1, 2, 3, 4, 5)          //x赋值1，y赋值2，z中赋值[3, 4, 5]数组\n```\n2. 场景2：结构赋值\n\n```javascript\nconst [first, ...rest] = [1, 2, 3, 4, 5];　　//此处'...'作为rest收集运算符使用\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []\n\nconst [first, ...rest] = [\"foo\"];\nfirst  // \"foo\"\nrest   // []\n```\n\n### 总结：\n如何判断ES6中的运算符是扩展运算符(spread)还是收集运算符(rest)，主要取决于其作用的位置。\n\n1.数组之前，作为扩展运算符使用，将数组转为逗号分隔的参数序列。\n\n2.函数形参中，收集传入的参数为数组。\n\n3.解构赋值中，收集对应的数据为数组。\n\n原文：\n1. [ES6之扩展运算符与应用(数组篇)](https://www.jianshu.com/p/41f499fa0e7b)\n2. [ES6之扩展运算符与应用(对象篇)](https://www.jianshu.com/p/35f9efe95fff)\n3. https://www.cnblogs.com/diweikang/p/8976854.html\n","source":"_posts/ES6之扩展运算符与应用.md","raw":"title: ES6之扩展运算符与应用\ndate: 2018/07/20\ncategories: 前端基础\ntags:\n  - ES6\n---\n\n在使用react的过程中，会有如下写法\n```\nconst data={name:\"ssdfin\"，value:1}\nconst component = <Component {...data}>\n```\n发现对 ... 三个点理解不是很深，所以单独记录下 ES6 rest/spread 特性\n\n### 扩展运算符(spread)\n\n1. 场景1：使用在数组之前。\n作用：将一个数组转为用逗号分隔的参数序列\n\n```javascript\nfunction foo(x, y, z){\n    console.log(x, y, z)\n}\nfoo.apply(null, [1, 2, 3])　　//在ES6之前我们这样使用数组作为函数参数调用。\nfoo(...[1, 2, 3])　　//此处...[1, 2, 3]就被展开为用逗号隔开的1, 2, 3参数序列\n```\n\n　当运算符\"...\"用在数组之前时，数组会被转为用逗号分隔的参数序列。\n\n2. 场景2：替代apply()方法\n\n```JavaScript\n// ES5的 写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nArray.prototype.push.apply(arr1, arr2);　　//push方法参数不能为数组，ES5需要借助apply()方法实现。\n\n// ES6 的写法\nlet arr1 = [0, 1, 2];\nlet arr2 = [3, 4, 5];\narr1.push(...arr2);　　　　　　　　　　　　　　//ES6中借助扩展运算符直接将数组转为了参数序列。\n```\n\n3. 场景3：替代数组的concat()方法\n\n```javascript\nlet a = [2, 3, 4]\nlet b = [1, ...a, 5]    //此处a数组被展开为2, 3, 4\nconsole.log(b)          //结果为[1, 2, 3, 4, 5]\n```\n上面的用法基本上替代了concat(..)，这里的行为就像[1].concat(a, [5])\n\n注意：扩展运算符后如果是空数组，不会产生任何效果\n\n```javascript\n[...[], 1]\n// [1]\n```\n\n\n### 收集运算符(rest)\n\n作用：收集剩余的参数转为一个数组。\n\n　　场景：在函数参数之前使用。\n\n1. 场景1：函数参数之前\n```javascript\n\n\nfunction foo(x, y, ...z){   //z表示把剩余的参数收集到一起组成一个名叫z的数组。\n    console.log(x, y, z)\n}\nfoo(1, 2, 3, 4, 5)          //x赋值1，y赋值2，z中赋值[3, 4, 5]数组\n```\n2. 场景2：结构赋值\n\n```javascript\nconst [first, ...rest] = [1, 2, 3, 4, 5];　　//此处'...'作为rest收集运算符使用\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []\n\nconst [first, ...rest] = [\"foo\"];\nfirst  // \"foo\"\nrest   // []\n```\n\n### 总结：\n如何判断ES6中的运算符是扩展运算符(spread)还是收集运算符(rest)，主要取决于其作用的位置。\n\n1.数组之前，作为扩展运算符使用，将数组转为逗号分隔的参数序列。\n\n2.函数形参中，收集传入的参数为数组。\n\n3.解构赋值中，收集对应的数据为数组。\n\n原文：\n1. [ES6之扩展运算符与应用(数组篇)](https://www.jianshu.com/p/41f499fa0e7b)\n2. [ES6之扩展运算符与应用(对象篇)](https://www.jianshu.com/p/35f9efe95fff)\n3. https://www.cnblogs.com/diweikang/p/8976854.html\n","slug":"ES6之扩展运算符与应用","published":1,"updated":"2018-07-23T14:43:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uwl00077q0th23wx5t1","content":"<p>在使用react的过程中，会有如下写法<br><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">const</span> <span class=\"class\"><span class=\"keyword\">data</span>=&#123;<span class=\"title\">name</span>:\"<span class=\"title\">ssdfin</span>\"，<span class=\"title\">value</span>:1&#125;</span></span><br><span class=\"line\"><span class=\"title\">const</span> component = &lt;<span class=\"type\">Component</span> &#123;...<span class=\"class\"><span class=\"keyword\">data</span>&#125;&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>发现对 … 三个点理解不是很深，所以单独记录下 ES6 rest/spread 特性</p>\n<h3 id=\"扩展运算符-spread\"><a href=\"#扩展运算符-spread\" class=\"headerlink\" title=\"扩展运算符(spread)\"></a>扩展运算符(spread)</h3><ol>\n<li>场景1：使用在数组之前。<br>作用：将一个数组转为用逗号分隔的参数序列</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y, z</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x, y, z)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.apply(<span class=\"literal\">null</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])　　<span class=\"comment\">//在ES6之前我们这样使用数组作为函数参数调用。</span></span><br><span class=\"line\">foo(...[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])　　<span class=\"comment\">//此处...[1, 2, 3]就被展开为用逗号隔开的1, 2, 3参数序列</span></span><br></pre></td></tr></table></figure>\n<p>　当运算符”…”用在数组之前时，数组会被转为用逗号分隔的参数序列。</p>\n<ol start=\"2\">\n<li>场景2：替代apply()方法</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5的 写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(arr1, arr2);　　<span class=\"comment\">//push方法参数不能为数组，ES5需要借助apply()方法实现。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6 的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr1.push(...arr2);　　　　　　　　　　　　　　<span class=\"comment\">//ES6中借助扩展运算符直接将数组转为了参数序列。</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>场景3：替代数组的concat()方法</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = [<span class=\"number\">1</span>, ...a, <span class=\"number\">5</span>]    <span class=\"comment\">//此处a数组被展开为2, 3, 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b)          <span class=\"comment\">//结果为[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n<p>上面的用法基本上替代了concat(..)，这里的行为就像[1].concat(a, [5])</p>\n<p>注意：扩展运算符后如果是空数组，不会产生任何效果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...[], <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"收集运算符-rest\"><a href=\"#收集运算符-rest\" class=\"headerlink\" title=\"收集运算符(rest)\"></a>收集运算符(rest)</h3><p>作用：收集剩余的参数转为一个数组。</p>\n<p>　　场景：在函数参数之前使用。</p>\n<ol>\n<li><p>场景1：函数参数之前</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y, ...z</span>)</span>&#123;   <span class=\"comment\">//z表示把剩余的参数收集到一起组成一个名叫z的数组。</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x, y, z)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)          <span class=\"comment\">//x赋值1，y赋值2，z中赋值[3, 4, 5]数组</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>场景2：结构赋值</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];　　<span class=\"comment\">//此处'...'作为rest收集运算符使用</span></span><br><span class=\"line\">first <span class=\"comment\">// 1</span></span><br><span class=\"line\">rest  <span class=\"comment\">// [2, 3, 4, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [];</span><br><span class=\"line\">first <span class=\"comment\">// undefined</span></span><br><span class=\"line\">rest  <span class=\"comment\">// []</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"string\">\"foo\"</span>];</span><br><span class=\"line\">first  <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\">rest   <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>如何判断ES6中的运算符是扩展运算符(spread)还是收集运算符(rest)，主要取决于其作用的位置。</p>\n<p>1.数组之前，作为扩展运算符使用，将数组转为逗号分隔的参数序列。</p>\n<p>2.函数形参中，收集传入的参数为数组。</p>\n<p>3.解构赋值中，收集对应的数据为数组。</p>\n<p>原文：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/41f499fa0e7b\" target=\"_blank\" rel=\"noopener\">ES6之扩展运算符与应用(数组篇)</a></li>\n<li><a href=\"https://www.jianshu.com/p/35f9efe95fff\" target=\"_blank\" rel=\"noopener\">ES6之扩展运算符与应用(对象篇)</a></li>\n<li><a href=\"https://www.cnblogs.com/diweikang/p/8976854.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/diweikang/p/8976854.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用react的过程中，会有如下写法<br><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">const</span> <span class=\"class\"><span class=\"keyword\">data</span>=&#123;<span class=\"title\">name</span>:\"<span class=\"title\">ssdfin</span>\"，<span class=\"title\">value</span>:1&#125;</span></span><br><span class=\"line\"><span class=\"title\">const</span> component = &lt;<span class=\"type\">Component</span> &#123;...<span class=\"class\"><span class=\"keyword\">data</span>&#125;&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>发现对 … 三个点理解不是很深，所以单独记录下 ES6 rest/spread 特性</p>\n<h3 id=\"扩展运算符-spread\"><a href=\"#扩展运算符-spread\" class=\"headerlink\" title=\"扩展运算符(spread)\"></a>扩展运算符(spread)</h3><ol>\n<li>场景1：使用在数组之前。<br>作用：将一个数组转为用逗号分隔的参数序列</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y, z</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x, y, z)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.apply(<span class=\"literal\">null</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])　　<span class=\"comment\">//在ES6之前我们这样使用数组作为函数参数调用。</span></span><br><span class=\"line\">foo(...[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])　　<span class=\"comment\">//此处...[1, 2, 3]就被展开为用逗号隔开的1, 2, 3参数序列</span></span><br></pre></td></tr></table></figure>\n<p>　当运算符”…”用在数组之前时，数组会被转为用逗号分隔的参数序列。</p>\n<ol start=\"2\">\n<li>场景2：替代apply()方法</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5的 写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(arr1, arr2);　　<span class=\"comment\">//push方法参数不能为数组，ES5需要借助apply()方法实现。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6 的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr1.push(...arr2);　　　　　　　　　　　　　　<span class=\"comment\">//ES6中借助扩展运算符直接将数组转为了参数序列。</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>场景3：替代数组的concat()方法</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = [<span class=\"number\">1</span>, ...a, <span class=\"number\">5</span>]    <span class=\"comment\">//此处a数组被展开为2, 3, 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b)          <span class=\"comment\">//结果为[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n<p>上面的用法基本上替代了concat(..)，这里的行为就像[1].concat(a, [5])</p>\n<p>注意：扩展运算符后如果是空数组，不会产生任何效果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...[], <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"收集运算符-rest\"><a href=\"#收集运算符-rest\" class=\"headerlink\" title=\"收集运算符(rest)\"></a>收集运算符(rest)</h3><p>作用：收集剩余的参数转为一个数组。</p>\n<p>　　场景：在函数参数之前使用。</p>\n<ol>\n<li><p>场景1：函数参数之前</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y, ...z</span>)</span>&#123;   <span class=\"comment\">//z表示把剩余的参数收集到一起组成一个名叫z的数组。</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x, y, z)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)          <span class=\"comment\">//x赋值1，y赋值2，z中赋值[3, 4, 5]数组</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>场景2：结构赋值</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];　　<span class=\"comment\">//此处'...'作为rest收集运算符使用</span></span><br><span class=\"line\">first <span class=\"comment\">// 1</span></span><br><span class=\"line\">rest  <span class=\"comment\">// [2, 3, 4, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [];</span><br><span class=\"line\">first <span class=\"comment\">// undefined</span></span><br><span class=\"line\">rest  <span class=\"comment\">// []</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"string\">\"foo\"</span>];</span><br><span class=\"line\">first  <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\">rest   <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>如何判断ES6中的运算符是扩展运算符(spread)还是收集运算符(rest)，主要取决于其作用的位置。</p>\n<p>1.数组之前，作为扩展运算符使用，将数组转为逗号分隔的参数序列。</p>\n<p>2.函数形参中，收集传入的参数为数组。</p>\n<p>3.解构赋值中，收集对应的数据为数组。</p>\n<p>原文：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/41f499fa0e7b\" target=\"_blank\" rel=\"noopener\">ES6之扩展运算符与应用(数组篇)</a></li>\n<li><a href=\"https://www.jianshu.com/p/35f9efe95fff\" target=\"_blank\" rel=\"noopener\">ES6之扩展运算符与应用(对象篇)</a></li>\n<li><a href=\"https://www.cnblogs.com/diweikang/p/8976854.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/diweikang/p/8976854.html</a></li>\n</ol>\n"},{"title":"HTTP状态码解读","date":"2018-07-09T16:00:00.000Z","toc":true,"_content":"\n平时在工作中，经常遇到客户端与服务端交互出问题的情况，复习下状态码，以快速定位问题~~\n\n状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。\n```\n状态码\t  响应类别\t                       原因短语\n1XX\t    信息性状态码（Informational）\t    服务器正在处理请求\n2XX\t    成功状态码（Success）\t           请求已正常处理完毕\n3XX\t    重定向状态码（Redirection）\t      需要进行额外操作以完成请求\n4XX\t    客户端错误状态码（Client Error）\t 客户端原因导致服务器无法处理请求\n5XX\t    服务器错误状态码（Server Error）\t 服务器原因导致处理请求出错\n```\n\n### HTTP1状态码（1.1）\n仅记录在 RFC2616 上的HTTP状态码就多达40种，若再加上 RFC4912、5842状态码等扩展，数量就多达60多种，虽然种类繁多，但是常用的只有14种，\n下面就简单介绍一下\n\n### 2xx 成功\n2xx的响应结果表明请求被正常处理了\n\n1. 200 OK\n表示从客户端发来的请求在服务器端被正常处理了。\n\n2. 204 No Content\n代表服务器接受的请求已成功受理，但在返回的响应报文中不含实体的主体部分。\n一般在只需要往服务器发送消息，而对客户端不需要发送新信息内容的情况下使用。\n\n3. 206 Partial Content\n表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。相应报文中包含由 Content-Range 指定范围的实体内容。\n\n### 3xx 重定向\n3xx表明浏览器需要执行某些特殊的处理以正确处理请求。\n\n1. 301 Moved Permanently 永久重定向\n表示请求的资源已经被分配到了新的URI，**以后** 应使用资源现在所指的URI\n\n2. 302 Found 临时重定向\n表示请求的资源已经被分配到了新的URI，希望用户 **本次** 使用资源新的URI\n\n3. 303 See Other 临时重定向\n表示由于请求的资源存在着另一个URI，应该使用GET方法定向获取请求的资源\n302、303的区别？\n- 303明确表示客户端应该采用 get 方式获取资源 ，这点与 302 有明显区别\n\n4. 304 Not Modified\n该状态码表示客户端发送附带条件的请求(采用GET方法的请求报文中 包含 If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任一首部)时，服务端允许请求访问资源，但因发送请求未能满足条件的情况后，直接返回304 Not Unmodified\n\n5. 307 Temporary Redirect 临时重定向\n\n### 4xx 客户端错误\n4xx的相应结果表明客户端是发生错误的原因所在\n\n1. 400 Bad Request\n表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容之后再次发送。另外，浏览器会像对待 200 OK 一样对待该状态码\n\n2. 401 Unauthorized\n该状态码表示发送的请求需要通过HTTP认证的认证信息，另外若之前已经进行过1次请求，则表示用户认证失败。\n\n3. 403 Forbidden\n表明 对请求资源的访问被服务器拒绝了，服务器端没有必要给出拒绝的理由，要是想给的话，会放在实体的主体部分对原因进行描述。\n**未获得文件系统的访问授权，访问权限出现某些问题，都是403发生的原因**\n\n4. 404 Not Found\n服务器上没有请求的资源，服务器拒绝且不想解释的时候，会使用\n\n### 5xx服务器错误\n5xx的相应结果表明服务器本身发生错误。\n\n1. 500 Internal Server Error\n表示 服务器端在执行请求时发生了错误\n\n2. 503 Service Unavilable\n表示服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。\n","source":"_posts/HTTP状态码解读.md","raw":"title: HTTP状态码解读\ndate: 2018/07/10\ncategories: 前端基础\ntoc: true\ntags:\n  - HTTP\n---\n\n平时在工作中，经常遇到客户端与服务端交互出问题的情况，复习下状态码，以快速定位问题~~\n\n状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。\n```\n状态码\t  响应类别\t                       原因短语\n1XX\t    信息性状态码（Informational）\t    服务器正在处理请求\n2XX\t    成功状态码（Success）\t           请求已正常处理完毕\n3XX\t    重定向状态码（Redirection）\t      需要进行额外操作以完成请求\n4XX\t    客户端错误状态码（Client Error）\t 客户端原因导致服务器无法处理请求\n5XX\t    服务器错误状态码（Server Error）\t 服务器原因导致处理请求出错\n```\n\n### HTTP1状态码（1.1）\n仅记录在 RFC2616 上的HTTP状态码就多达40种，若再加上 RFC4912、5842状态码等扩展，数量就多达60多种，虽然种类繁多，但是常用的只有14种，\n下面就简单介绍一下\n\n### 2xx 成功\n2xx的响应结果表明请求被正常处理了\n\n1. 200 OK\n表示从客户端发来的请求在服务器端被正常处理了。\n\n2. 204 No Content\n代表服务器接受的请求已成功受理，但在返回的响应报文中不含实体的主体部分。\n一般在只需要往服务器发送消息，而对客户端不需要发送新信息内容的情况下使用。\n\n3. 206 Partial Content\n表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。相应报文中包含由 Content-Range 指定范围的实体内容。\n\n### 3xx 重定向\n3xx表明浏览器需要执行某些特殊的处理以正确处理请求。\n\n1. 301 Moved Permanently 永久重定向\n表示请求的资源已经被分配到了新的URI，**以后** 应使用资源现在所指的URI\n\n2. 302 Found 临时重定向\n表示请求的资源已经被分配到了新的URI，希望用户 **本次** 使用资源新的URI\n\n3. 303 See Other 临时重定向\n表示由于请求的资源存在着另一个URI，应该使用GET方法定向获取请求的资源\n302、303的区别？\n- 303明确表示客户端应该采用 get 方式获取资源 ，这点与 302 有明显区别\n\n4. 304 Not Modified\n该状态码表示客户端发送附带条件的请求(采用GET方法的请求报文中 包含 If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任一首部)时，服务端允许请求访问资源，但因发送请求未能满足条件的情况后，直接返回304 Not Unmodified\n\n5. 307 Temporary Redirect 临时重定向\n\n### 4xx 客户端错误\n4xx的相应结果表明客户端是发生错误的原因所在\n\n1. 400 Bad Request\n表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容之后再次发送。另外，浏览器会像对待 200 OK 一样对待该状态码\n\n2. 401 Unauthorized\n该状态码表示发送的请求需要通过HTTP认证的认证信息，另外若之前已经进行过1次请求，则表示用户认证失败。\n\n3. 403 Forbidden\n表明 对请求资源的访问被服务器拒绝了，服务器端没有必要给出拒绝的理由，要是想给的话，会放在实体的主体部分对原因进行描述。\n**未获得文件系统的访问授权，访问权限出现某些问题，都是403发生的原因**\n\n4. 404 Not Found\n服务器上没有请求的资源，服务器拒绝且不想解释的时候，会使用\n\n### 5xx服务器错误\n5xx的相应结果表明服务器本身发生错误。\n\n1. 500 Internal Server Error\n表示 服务器端在执行请求时发生了错误\n\n2. 503 Service Unavilable\n表示服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。\n","slug":"HTTP状态码解读","published":1,"updated":"2018-07-14T09:52:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uwn000b7q0tsext06lt","content":"<p>平时在工作中，经常遇到客户端与服务端交互出问题的情况，复习下状态码，以快速定位问题~~</p>\n<p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">状态码\t  响应类别\t                       原因短语</span><br><span class=\"line\"><span class=\"number\">1</span>XX\t    信息性状态码（Informational）\t    服务器正在处理请求</span><br><span class=\"line\"><span class=\"number\">2</span>XX\t    成功状态码（Success）\t           请求已正常处理完毕</span><br><span class=\"line\"><span class=\"number\">3</span>XX\t    重定向状态码（Redirection）\t      需要进行额外操作以完成请求</span><br><span class=\"line\"><span class=\"number\">4</span>XX\t    客户端错误状态码（Client Error）\t 客户端原因导致服务器无法处理请求</span><br><span class=\"line\"><span class=\"number\">5</span>XX\t    服务器错误状态码（Server Error）\t 服务器原因导致处理请求出错</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"HTTP1状态码（1-1）\"><a href=\"#HTTP1状态码（1-1）\" class=\"headerlink\" title=\"HTTP1状态码（1.1）\"></a>HTTP1状态码（1.1）</h3><p>仅记录在 RFC2616 上的HTTP状态码就多达40种，若再加上 RFC4912、5842状态码等扩展，数量就多达60多种，虽然种类繁多，但是常用的只有14种，<br>下面就简单介绍一下</p>\n<h3 id=\"2xx-成功\"><a href=\"#2xx-成功\" class=\"headerlink\" title=\"2xx 成功\"></a>2xx 成功</h3><p>2xx的响应结果表明请求被正常处理了</p>\n<ol>\n<li><p>200 OK<br>表示从客户端发来的请求在服务器端被正常处理了。</p>\n</li>\n<li><p>204 No Content<br>代表服务器接受的请求已成功受理，但在返回的响应报文中不含实体的主体部分。<br>一般在只需要往服务器发送消息，而对客户端不需要发送新信息内容的情况下使用。</p>\n</li>\n<li><p>206 Partial Content<br>表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。相应报文中包含由 Content-Range 指定范围的实体内容。</p>\n</li>\n</ol>\n<h3 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx 重定向\"></a>3xx 重定向</h3><p>3xx表明浏览器需要执行某些特殊的处理以正确处理请求。</p>\n<ol>\n<li><p>301 Moved Permanently 永久重定向<br>表示请求的资源已经被分配到了新的URI，<strong>以后</strong> 应使用资源现在所指的URI</p>\n</li>\n<li><p>302 Found 临时重定向<br>表示请求的资源已经被分配到了新的URI，希望用户 <strong>本次</strong> 使用资源新的URI</p>\n</li>\n<li><p>303 See Other 临时重定向<br>表示由于请求的资源存在着另一个URI，应该使用GET方法定向获取请求的资源<br>302、303的区别？</p>\n</li>\n</ol>\n<ul>\n<li>303明确表示客户端应该采用 get 方式获取资源 ，这点与 302 有明显区别</li>\n</ul>\n<ol start=\"4\">\n<li><p>304 Not Modified<br>该状态码表示客户端发送附带条件的请求(采用GET方法的请求报文中 包含 If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任一首部)时，服务端允许请求访问资源，但因发送请求未能满足条件的情况后，直接返回304 Not Unmodified</p>\n</li>\n<li><p>307 Temporary Redirect 临时重定向</p>\n</li>\n</ol>\n<h3 id=\"4xx-客户端错误\"><a href=\"#4xx-客户端错误\" class=\"headerlink\" title=\"4xx 客户端错误\"></a>4xx 客户端错误</h3><p>4xx的相应结果表明客户端是发生错误的原因所在</p>\n<ol>\n<li><p>400 Bad Request<br>表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容之后再次发送。另外，浏览器会像对待 200 OK 一样对待该状态码</p>\n</li>\n<li><p>401 Unauthorized<br>该状态码表示发送的请求需要通过HTTP认证的认证信息，另外若之前已经进行过1次请求，则表示用户认证失败。</p>\n</li>\n<li><p>403 Forbidden<br>表明 对请求资源的访问被服务器拒绝了，服务器端没有必要给出拒绝的理由，要是想给的话，会放在实体的主体部分对原因进行描述。<br><strong>未获得文件系统的访问授权，访问权限出现某些问题，都是403发生的原因</strong></p>\n</li>\n<li><p>404 Not Found<br>服务器上没有请求的资源，服务器拒绝且不想解释的时候，会使用</p>\n</li>\n</ol>\n<h3 id=\"5xx服务器错误\"><a href=\"#5xx服务器错误\" class=\"headerlink\" title=\"5xx服务器错误\"></a>5xx服务器错误</h3><p>5xx的相应结果表明服务器本身发生错误。</p>\n<ol>\n<li><p>500 Internal Server Error<br>表示 服务器端在执行请求时发生了错误</p>\n</li>\n<li><p>503 Service Unavilable<br>表示服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>平时在工作中，经常遇到客户端与服务端交互出问题的情况，复习下状态码，以快速定位问题~~</p>\n<p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">状态码\t  响应类别\t                       原因短语</span><br><span class=\"line\"><span class=\"number\">1</span>XX\t    信息性状态码（Informational）\t    服务器正在处理请求</span><br><span class=\"line\"><span class=\"number\">2</span>XX\t    成功状态码（Success）\t           请求已正常处理完毕</span><br><span class=\"line\"><span class=\"number\">3</span>XX\t    重定向状态码（Redirection）\t      需要进行额外操作以完成请求</span><br><span class=\"line\"><span class=\"number\">4</span>XX\t    客户端错误状态码（Client Error）\t 客户端原因导致服务器无法处理请求</span><br><span class=\"line\"><span class=\"number\">5</span>XX\t    服务器错误状态码（Server Error）\t 服务器原因导致处理请求出错</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"HTTP1状态码（1-1）\"><a href=\"#HTTP1状态码（1-1）\" class=\"headerlink\" title=\"HTTP1状态码（1.1）\"></a>HTTP1状态码（1.1）</h3><p>仅记录在 RFC2616 上的HTTP状态码就多达40种，若再加上 RFC4912、5842状态码等扩展，数量就多达60多种，虽然种类繁多，但是常用的只有14种，<br>下面就简单介绍一下</p>\n<h3 id=\"2xx-成功\"><a href=\"#2xx-成功\" class=\"headerlink\" title=\"2xx 成功\"></a>2xx 成功</h3><p>2xx的响应结果表明请求被正常处理了</p>\n<ol>\n<li><p>200 OK<br>表示从客户端发来的请求在服务器端被正常处理了。</p>\n</li>\n<li><p>204 No Content<br>代表服务器接受的请求已成功受理，但在返回的响应报文中不含实体的主体部分。<br>一般在只需要往服务器发送消息，而对客户端不需要发送新信息内容的情况下使用。</p>\n</li>\n<li><p>206 Partial Content<br>表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。相应报文中包含由 Content-Range 指定范围的实体内容。</p>\n</li>\n</ol>\n<h3 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx 重定向\"></a>3xx 重定向</h3><p>3xx表明浏览器需要执行某些特殊的处理以正确处理请求。</p>\n<ol>\n<li><p>301 Moved Permanently 永久重定向<br>表示请求的资源已经被分配到了新的URI，<strong>以后</strong> 应使用资源现在所指的URI</p>\n</li>\n<li><p>302 Found 临时重定向<br>表示请求的资源已经被分配到了新的URI，希望用户 <strong>本次</strong> 使用资源新的URI</p>\n</li>\n<li><p>303 See Other 临时重定向<br>表示由于请求的资源存在着另一个URI，应该使用GET方法定向获取请求的资源<br>302、303的区别？</p>\n</li>\n</ol>\n<ul>\n<li>303明确表示客户端应该采用 get 方式获取资源 ，这点与 302 有明显区别</li>\n</ul>\n<ol start=\"4\">\n<li><p>304 Not Modified<br>该状态码表示客户端发送附带条件的请求(采用GET方法的请求报文中 包含 If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任一首部)时，服务端允许请求访问资源，但因发送请求未能满足条件的情况后，直接返回304 Not Unmodified</p>\n</li>\n<li><p>307 Temporary Redirect 临时重定向</p>\n</li>\n</ol>\n<h3 id=\"4xx-客户端错误\"><a href=\"#4xx-客户端错误\" class=\"headerlink\" title=\"4xx 客户端错误\"></a>4xx 客户端错误</h3><p>4xx的相应结果表明客户端是发生错误的原因所在</p>\n<ol>\n<li><p>400 Bad Request<br>表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容之后再次发送。另外，浏览器会像对待 200 OK 一样对待该状态码</p>\n</li>\n<li><p>401 Unauthorized<br>该状态码表示发送的请求需要通过HTTP认证的认证信息，另外若之前已经进行过1次请求，则表示用户认证失败。</p>\n</li>\n<li><p>403 Forbidden<br>表明 对请求资源的访问被服务器拒绝了，服务器端没有必要给出拒绝的理由，要是想给的话，会放在实体的主体部分对原因进行描述。<br><strong>未获得文件系统的访问授权，访问权限出现某些问题，都是403发生的原因</strong></p>\n</li>\n<li><p>404 Not Found<br>服务器上没有请求的资源，服务器拒绝且不想解释的时候，会使用</p>\n</li>\n</ol>\n<h3 id=\"5xx服务器错误\"><a href=\"#5xx服务器错误\" class=\"headerlink\" title=\"5xx服务器错误\"></a>5xx服务器错误</h3><p>5xx的相应结果表明服务器本身发生错误。</p>\n<ol>\n<li><p>500 Internal Server Error<br>表示 服务器端在执行请求时发生了错误</p>\n</li>\n<li><p>503 Service Unavilable<br>表示服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。</p>\n</li>\n</ol>\n"},{"title":"前端自动化测试探索","date":"2018-06-03T16:00:00.000Z","toc":true,"_content":"\n\n### 常用的前端测试工具一览\n前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为 **测试框架**、**断言库**、**测试覆盖率工具** 等几类。在正式开始本文之前，我们先来大致了解下它们：\n### 测试框架\n测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。\n测试一般分两种：BDD和TDD\n<!--more-->\n1. 先介绍Test-Driven Development(TDD)即测试驱动开发，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。国外使用这种开发模式较多，github上大型的开源项目，如果没跑过测试用例，大概是没人敢在生产环境中使用的。\n测试驱动对开发过程的要求：\n- 单元尽量解耦，否则单元不可测\n- 开发前，先设计接口，再实现细节\n- 便于回归和内部代码重构 (把所有单元测试，集成测试等都做好之后，实现重构就更加从容，可以一块一块进行)\n2. BDD指的是Behavior Drive Development，也就是行为驱动开发。传统的开发模式中，客户很难从技术层面理解问题，开发人员很难从业务需求考虑问题，BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析需求，然后将这些需求写成一个个的故事(应用场景)。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，通过设定各种业务场景中该展示的状态、适用的事件，以及场景的执行结果，基本就完成了一个完整测试的定义。\n\n常见的测试框架有 [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/),以及本文要介绍的 [Jest](https://facebook.github.io/jest/zh-Hans/) 。\n\n### 断言库\n断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 [Should.js](https://shouldjs.github.io/), [Chai.js](http://www.chaijs.com/) 等。\n\n### 测试覆盖率工具\n用于统计测试用例对代码的测试情况，生成相应的报表，比如 [istanbul](https://github.com/gotwarlost/istanbul)。\n\n### Jest\n\n1. 为什么选择Jest\nJest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n而作为一个面向前端的测试框架， Jest 可以利用其特有的[快照测试](https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content)功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。\n\n此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。\n\n2. 安装\nJest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：\n```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\nJest 的测试脚本名形如*.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的*.test.js 或.spec.js 文件、完成测试。\n3. 基本使用\n4. 用例的表示\n表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：\nsum.js\n```\nfunction sum(a, b) {\n    return a + b;\n  }\n  module.exports = sum;\n```\nsum.test.js\n```\nconst sum = require('./sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  //expect(sum(1, 2)).toBe(3);//成功\n  expect(sum(1, 2)).toBe(5);//失败  \n});\n```\n其中toBe('Hello world')便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。\n写完了用例，运行在项目目录下执行npm test，即可看到测试结果：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg)\n修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg)\n\n\n5. 用例的预处理或后处理：\n有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。\n- 对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；\n- 如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；\n- 后处理，可以使用对应的 afterAll() 和 afterEach() 函数。\n- 如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：\n\ncheckAll.js\n```\nfunction obj(){\n  const o={\n    foo:true,\n    bar:false\n  };\n  return o\n}\nmodule.exports=obj();\n```\ncheckAll.test.js\n```\nvar testObject = require('./checkAll');\n\n\ndescribe('test testObject', () => {\n    beforeAll(() => {\n        // 预处理操作\n    })\n\n    test('is foo', () => {\n       expect(testObject.foo).toBeTruthy();\n    })\n\n    test('is not bar', () => {\n        expect(testObject.bar).toBeFalsy();\n    })\n\n    afterAll(() => {\n        // 后处理操作\n    })\n})\n```\n执行npm test\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg)\n\n\n\n### Mocha\nMocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.js内置的assert模块作为断言\n让我们一起看看assert有哪些常见用法：\n\n\n\n原文：\n- https://segmentfault.com/a/1190000004558796\n- https://zhuanlan.zhihu.com/p/28162082\n","source":"_posts/JavaScript-test-framework.md","raw":"title: 前端自动化测试探索\ndate: 2018/06/04\ncategories: 前端自动化测试\ntoc: true\ntags:\n  - Jest\n---\n\n\n### 常用的前端测试工具一览\n前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为 **测试框架**、**断言库**、**测试覆盖率工具** 等几类。在正式开始本文之前，我们先来大致了解下它们：\n### 测试框架\n测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。\n测试一般分两种：BDD和TDD\n<!--more-->\n1. 先介绍Test-Driven Development(TDD)即测试驱动开发，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。国外使用这种开发模式较多，github上大型的开源项目，如果没跑过测试用例，大概是没人敢在生产环境中使用的。\n测试驱动对开发过程的要求：\n- 单元尽量解耦，否则单元不可测\n- 开发前，先设计接口，再实现细节\n- 便于回归和内部代码重构 (把所有单元测试，集成测试等都做好之后，实现重构就更加从容，可以一块一块进行)\n2. BDD指的是Behavior Drive Development，也就是行为驱动开发。传统的开发模式中，客户很难从技术层面理解问题，开发人员很难从业务需求考虑问题，BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析需求，然后将这些需求写成一个个的故事(应用场景)。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，通过设定各种业务场景中该展示的状态、适用的事件，以及场景的执行结果，基本就完成了一个完整测试的定义。\n\n常见的测试框架有 [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/),以及本文要介绍的 [Jest](https://facebook.github.io/jest/zh-Hans/) 。\n\n### 断言库\n断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 [Should.js](https://shouldjs.github.io/), [Chai.js](http://www.chaijs.com/) 等。\n\n### 测试覆盖率工具\n用于统计测试用例对代码的测试情况，生成相应的报表，比如 [istanbul](https://github.com/gotwarlost/istanbul)。\n\n### Jest\n\n1. 为什么选择Jest\nJest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n而作为一个面向前端的测试框架， Jest 可以利用其特有的[快照测试](https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content)功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。\n\n此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。\n\n2. 安装\nJest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：\n```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\nJest 的测试脚本名形如*.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的*.test.js 或.spec.js 文件、完成测试。\n3. 基本使用\n4. 用例的表示\n表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：\nsum.js\n```\nfunction sum(a, b) {\n    return a + b;\n  }\n  module.exports = sum;\n```\nsum.test.js\n```\nconst sum = require('./sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  //expect(sum(1, 2)).toBe(3);//成功\n  expect(sum(1, 2)).toBe(5);//失败  \n});\n```\n其中toBe('Hello world')便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。\n写完了用例，运行在项目目录下执行npm test，即可看到测试结果：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg)\n修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg)\n\n\n5. 用例的预处理或后处理：\n有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。\n- 对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；\n- 如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；\n- 后处理，可以使用对应的 afterAll() 和 afterEach() 函数。\n- 如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：\n\ncheckAll.js\n```\nfunction obj(){\n  const o={\n    foo:true,\n    bar:false\n  };\n  return o\n}\nmodule.exports=obj();\n```\ncheckAll.test.js\n```\nvar testObject = require('./checkAll');\n\n\ndescribe('test testObject', () => {\n    beforeAll(() => {\n        // 预处理操作\n    })\n\n    test('is foo', () => {\n       expect(testObject.foo).toBeTruthy();\n    })\n\n    test('is not bar', () => {\n        expect(testObject.bar).toBeFalsy();\n    })\n\n    afterAll(() => {\n        // 后处理操作\n    })\n})\n```\n执行npm test\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg)\n\n\n\n### Mocha\nMocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.js内置的assert模块作为断言\n让我们一起看看assert有哪些常见用法：\n\n\n\n原文：\n- https://segmentfault.com/a/1190000004558796\n- https://zhuanlan.zhihu.com/p/28162082\n","slug":"JavaScript-test-framework","published":1,"updated":"2018-06-09T15:50:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uwq000c7q0tmou66vc5","content":"<h3 id=\"常用的前端测试工具一览\"><a href=\"#常用的前端测试工具一览\" class=\"headerlink\" title=\"常用的前端测试工具一览\"></a>常用的前端测试工具一览</h3><p>前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为 <strong>测试框架</strong>、<strong>断言库</strong>、<strong>测试覆盖率工具</strong> 等几类。在正式开始本文之前，我们先来大致了解下它们：</p>\n<h3 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h3><p>测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。<br>测试一般分两种：BDD和TDD<br><a id=\"more\"></a></p>\n<ol>\n<li>先介绍Test-Driven Development(TDD)即测试驱动开发，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。国外使用这种开发模式较多，github上大型的开源项目，如果没跑过测试用例，大概是没人敢在生产环境中使用的。<br>测试驱动对开发过程的要求：</li>\n</ol>\n<ul>\n<li>单元尽量解耦，否则单元不可测</li>\n<li>开发前，先设计接口，再实现细节</li>\n<li>便于回归和内部代码重构 (把所有单元测试，集成测试等都做好之后，实现重构就更加从容，可以一块一块进行)</li>\n</ul>\n<ol start=\"2\">\n<li>BDD指的是Behavior Drive Development，也就是行为驱动开发。传统的开发模式中，客户很难从技术层面理解问题，开发人员很难从业务需求考虑问题，BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析需求，然后将这些需求写成一个个的故事(应用场景)。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，通过设定各种业务场景中该展示的状态、适用的事件，以及场景的执行结果，基本就完成了一个完整测试的定义。</li>\n</ol>\n<p>常见的测试框架有 <a href=\"https://jasmine.github.io/\" target=\"_blank\" rel=\"noopener\">Jasmine</a>, <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a>,以及本文要介绍的 <a href=\"https://facebook.github.io/jest/zh-Hans/\" target=\"_blank\" rel=\"noopener\">Jest</a> 。</p>\n<h3 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h3><p>断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 <a href=\"https://shouldjs.github.io/\" target=\"_blank\" rel=\"noopener\">Should.js</a>, <a href=\"http://www.chaijs.com/\" target=\"_blank\" rel=\"noopener\">Chai.js</a> 等。</p>\n<h3 id=\"测试覆盖率工具\"><a href=\"#测试覆盖率工具\" class=\"headerlink\" title=\"测试覆盖率工具\"></a>测试覆盖率工具</h3><p>用于统计测试用例对代码的测试情况，生成相应的报表，比如 <a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"noopener\">istanbul</a>。</p>\n<h3 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h3><ol>\n<li>为什么选择Jest<br>Jest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</li>\n</ol>\n<p>而作为一个面向前端的测试框架， Jest 可以利用其特有的<a href=\"https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content\" target=\"_blank\" rel=\"noopener\">快照测试</a>功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。</p>\n<p>此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。</p>\n<ol start=\"2\">\n<li>安装<br>Jest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"test\"</span>: <span class=\"string\">\"jest\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Jest 的测试脚本名形如<em>.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的</em>.test.js 或.spec.js 文件、完成测试。</p>\n<ol start=\"3\">\n<li>基本使用</li>\n<li>用例的表示<br>表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：<br>sum.js<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> <span class=\"built_in\">sum</span>(a, b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">module</span>.exports = <span class=\"built_in\">sum</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>sum.test.js<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const sum = require('./sum')<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">test('adds <span class=\"number\">1</span> + <span class=\"number\">2</span> to equal <span class=\"number\">3</span>', () =&gt; &#123;</span><br><span class=\"line\">  //expect(<span class=\"name\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">3</span>)<span class=\"comment\">;//成功</span></span><br><span class=\"line\">  expect(<span class=\"name\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">5</span>)<span class=\"comment\">;//失败  </span></span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中toBe(‘Hello world’)便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档<a href=\"https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。</a><br>写完了用例，运行在项目目录下执行npm test，即可看到测试结果：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg\" alt=\"\"><br>修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg\" alt=\"\"></p>\n<ol start=\"5\">\n<li>用例的预处理或后处理：<br>有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。</li>\n</ol>\n<ul>\n<li>对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；</li>\n<li>如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；</li>\n<li>后处理，可以使用对应的 afterAll() 和 afterEach() 函数。</li>\n<li>如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：</li>\n</ul>\n<p>checkAll.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">obj</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> o=&#123;</span><br><span class=\"line\">    foo:<span class=\"literal\">true</span>,</span><br><span class=\"line\">    bar:<span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports=obj();</span><br></pre></td></tr></table></figure></p>\n<p>checkAll.test.js<br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var testObject = <span class=\"built_in\">require</span>(<span class=\"string\">'./checkAll'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'test testObject'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    beforeAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span> 预处理操作</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    test(<span class=\"string\">'is foo'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">       expect(testObject.foo).toBeTruthy();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    test(<span class=\"string\">'is not bar'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        expect(testObject.bar).toBeFalsy();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    afterAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span> 后处理操作</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>执行npm test<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg\" alt=\"\"></p>\n<h3 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a>Mocha</h3><p>Mocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.js内置的assert模块作为断言<br>让我们一起看看assert有哪些常见用法：</p>\n<p>原文：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000004558796\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000004558796</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28162082\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/28162082</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"常用的前端测试工具一览\"><a href=\"#常用的前端测试工具一览\" class=\"headerlink\" title=\"常用的前端测试工具一览\"></a>常用的前端测试工具一览</h3><p>前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为 <strong>测试框架</strong>、<strong>断言库</strong>、<strong>测试覆盖率工具</strong> 等几类。在正式开始本文之前，我们先来大致了解下它们：</p>\n<h3 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h3><p>测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。<br>测试一般分两种：BDD和TDD<br>","more":"</p>\n<ol>\n<li>先介绍Test-Driven Development(TDD)即测试驱动开发，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。国外使用这种开发模式较多，github上大型的开源项目，如果没跑过测试用例，大概是没人敢在生产环境中使用的。<br>测试驱动对开发过程的要求：</li>\n</ol>\n<ul>\n<li>单元尽量解耦，否则单元不可测</li>\n<li>开发前，先设计接口，再实现细节</li>\n<li>便于回归和内部代码重构 (把所有单元测试，集成测试等都做好之后，实现重构就更加从容，可以一块一块进行)</li>\n</ul>\n<ol start=\"2\">\n<li>BDD指的是Behavior Drive Development，也就是行为驱动开发。传统的开发模式中，客户很难从技术层面理解问题，开发人员很难从业务需求考虑问题，BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析需求，然后将这些需求写成一个个的故事(应用场景)。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，通过设定各种业务场景中该展示的状态、适用的事件，以及场景的执行结果，基本就完成了一个完整测试的定义。</li>\n</ol>\n<p>常见的测试框架有 <a href=\"https://jasmine.github.io/\" target=\"_blank\" rel=\"noopener\">Jasmine</a>, <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a>,以及本文要介绍的 <a href=\"https://facebook.github.io/jest/zh-Hans/\" target=\"_blank\" rel=\"noopener\">Jest</a> 。</p>\n<h3 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h3><p>断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 <a href=\"https://shouldjs.github.io/\" target=\"_blank\" rel=\"noopener\">Should.js</a>, <a href=\"http://www.chaijs.com/\" target=\"_blank\" rel=\"noopener\">Chai.js</a> 等。</p>\n<h3 id=\"测试覆盖率工具\"><a href=\"#测试覆盖率工具\" class=\"headerlink\" title=\"测试覆盖率工具\"></a>测试覆盖率工具</h3><p>用于统计测试用例对代码的测试情况，生成相应的报表，比如 <a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"noopener\">istanbul</a>。</p>\n<h3 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h3><ol>\n<li>为什么选择Jest<br>Jest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</li>\n</ol>\n<p>而作为一个面向前端的测试框架， Jest 可以利用其特有的<a href=\"https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content\" target=\"_blank\" rel=\"noopener\">快照测试</a>功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。</p>\n<p>此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。</p>\n<ol start=\"2\">\n<li>安装<br>Jest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"test\"</span>: <span class=\"string\">\"jest\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Jest 的测试脚本名形如<em>.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的</em>.test.js 或.spec.js 文件、完成测试。</p>\n<ol start=\"3\">\n<li>基本使用</li>\n<li>用例的表示<br>表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：<br>sum.js<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> <span class=\"built_in\">sum</span>(a, b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">module</span>.exports = <span class=\"built_in\">sum</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>sum.test.js<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const sum = require('./sum')<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">test('adds <span class=\"number\">1</span> + <span class=\"number\">2</span> to equal <span class=\"number\">3</span>', () =&gt; &#123;</span><br><span class=\"line\">  //expect(<span class=\"name\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">3</span>)<span class=\"comment\">;//成功</span></span><br><span class=\"line\">  expect(<span class=\"name\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)).toBe(<span class=\"number\">5</span>)<span class=\"comment\">;//失败  </span></span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中toBe(‘Hello world’)便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档<a href=\"https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。</a><br>写完了用例，运行在项目目录下执行npm test，即可看到测试结果：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg\" alt=\"\"><br>修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg\" alt=\"\"></p>\n<ol start=\"5\">\n<li>用例的预处理或后处理：<br>有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。</li>\n</ol>\n<ul>\n<li>对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；</li>\n<li>如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；</li>\n<li>后处理，可以使用对应的 afterAll() 和 afterEach() 函数。</li>\n<li>如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：</li>\n</ul>\n<p>checkAll.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">obj</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> o=&#123;</span><br><span class=\"line\">    foo:<span class=\"literal\">true</span>,</span><br><span class=\"line\">    bar:<span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports=obj();</span><br></pre></td></tr></table></figure></p>\n<p>checkAll.test.js<br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var testObject = <span class=\"built_in\">require</span>(<span class=\"string\">'./checkAll'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'test testObject'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    beforeAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span> 预处理操作</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    test(<span class=\"string\">'is foo'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">       expect(testObject.foo).toBeTruthy();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    test(<span class=\"string\">'is not bar'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        expect(testObject.bar).toBeFalsy();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    afterAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span> 后处理操作</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>执行npm test<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg\" alt=\"\"></p>\n<h3 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a>Mocha</h3><p>Mocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.js内置的assert模块作为断言<br>让我们一起看看assert有哪些常见用法：</p>\n<p>原文：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000004558796\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000004558796</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28162082\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/28162082</a></li>\n</ul>"},{"title":"Nodejs之npm&package.json学习","date":"2018-05-17T16:00:00.000Z","_content":"\n作为前端，因为经常用到gulp，webpack等工具，所以我们最常见到的是npm和package.json，所以先总结一下它们俩的常用命令。\n\n## npm\n### 初始化\n```\n npm init //会询问package.json的各种信息，从而确认\n\n npm init --y //全部使用默认值,快速生成package.json\n```\n### 安装依赖包\n```\n npm install <package name> <package name> ...\n\n npm install <package name> -g\n\n npm install <package name> --save\n\n npm install <package name> --save-dev\n\n npm install <pacakage name>  --O //--save-optional  -B: --save-bundle  -E: --save-exact\n```\nnpm install <package name> -g :全局安装，需要注意的是全局模式并不是将一个模块安装包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用，-g的含义是将一个包安装为全局可用的可执行命令,例如gulp，webpack等。\n\n--save与--save-dev的区别 :\n--save:是生产环境中项目运行需要的依赖,比如代码所依赖的库或框架(Jquery,React等)，安装后被记录在package.json中的dependencies关键字下；\n--save-dev:开发时候需要的依赖，安装后被记录在devDependencies关键字下。如一些开发时候需要用的gulp，webpack工具。\n\n同样--O/B/E分别会被记录到对应的关键字下。\n\n### 更新依赖包\n```\n npm update\n\n npm update  -g\n\n npm outdated\n\n npm outdated -g\n```\n\n在项目目录下运行npm update可以升级项目中所用依赖到最新版本，而npm update -g则可以升级全局安装的依赖包到最新版。\n\nnpm outdated用于检查模块是否过时并列出。\n\n### 卸载依赖\n```\n npm uninstall <package name> <package name> ...\n\n npm uninstall <package name> -g\n\n npm uninstall <package name> --save\n\n npm uninstall <package name> --save-dev\n```\n使用npm uninstall可以卸载依赖，但是卸载后，在package.json中的纪录并不会被删除，要想在卸载依赖的同时删除在package.json中的纪录，需要在卸载的时候使用安装时的所有的选项，例如，如果安装时候使用了npm install <package name> --save则卸载的时候，同样使用npm uninstall <pacakage name> --save，而如果使用了--save-dev，卸载时候也需要加相同的选项。\n\n### 使用自定义npm命令\n在package.json中，有一个scripts关键字，只需要在该关键字内写入自定义命令以及对应执行的实际命令即可。\n```\n\"scripts\":{\n    \"test\": \"nonde ./test.js\",\n    \"dev\": \"gulp --gulpfile gulpfile-dev.js\",\n    \"build\": \"gulp --gulpfile gulpfile-build.js\"\n}\n```\n上面的配置中，只要我们在终端运行npm dev就是运行了gulp --gulpfile gulpfile-dev.js，这样就省去了我们在终端输入很长的一段命令，非常方便。\n\n### 其他\nnpm view <pacakage name>可以查看包的package.json文件，如果只是看包的某个特性，在后面加上相应的key即可，例如npm v zepto version就是查看当前安装的zepto的版本，v是view的简写。\n\nnpm ls可以分析出当前当前项目下能够通过模块路径找到的所有包，并生成依赖树。\n\nnpm doc <package name>可以打开该依赖包的官网，其实就是打开了package.json中的homepage。\n\n## package.json文件\n在运行npm init后会生成package.json文件，该文件用于记录项目中所用到的依赖以及项目的配置信息（比如名称、版本、许可证等）。npm install命令根据这个配置文件自动下载项目运行和开发所需要的依赖。\n一个比较完整的package.json文件如下：\n```\n{\n    \"name\": \"project\", //包名\n    \"version\": \"1.0.0\", //版本号\n    \"author\": \"张三\", //包的作者的名字\n    \"description\": \"第一个node.js程序\",//包的描述\n    \"keywords\":[\"node.js\",\"javascript\"], //关键字\n    \"repository\": { //包代码存放的地方，可以是git或者svn\n        \"type\": \"git\",\n        \"url\": \"https://path/to/url\"\n    },\n    \"license\":\"MIT\",//开源许可证\n    \"engines\": {\"node\": \"0.10.x\"},\n    \"bugs\":{\"url\":\"http://path/to/bug\",\"email\":\"bug@example.com\"},\n    \"contributors\":[{\"name\":\"李四\",\"email\":\"lisi@example.com\"}],\n    \"scripts\": {\n        \"start\": \"node index.js\"\n    },\n    \"dependencies\": {\n        \"express\": \"latest\",\n        \"mongoose\": \"~3.8.3\"\n    },\n    \"devDependencies\": {\n        \"grunt\": \"~0.4.1\",\n        \"grunt-contrib-concat\": \"~0.3.0\"\n    }\n}\n```\n1. 小标签1：如何为代码选择开源许可证，这是一个问题。\n世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种----GPL、BSD、MIT、Mozilla、Apache和LGPL----之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是阮一峰老师制作的中文版，请点击看大图。\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/license.png)\n2. engines\n```\n可选字段。既可以指定node版本:\n { \"engines\" : {\"node\" : \">=0.10.3 <0.12\" } }\n也可以指定npm版本：\n { \"engines\" : {\"npm\" : \"~1.0.20\" } }\n```\n\n3. scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包.\n示例如下:\n```\n\n\"scripts\":{\n\n    “install”:\"install.js\",\n\n    \"test\":\"test.js\"\n\n}\n```\n4. main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果该字段不存在，则node会检查目录下的index.js，index.node，index.json作为默认入口。\n\n\n### 使用淘宝 NPM 镜像\n大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。\n\n淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。\n\n你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n这样就可以使用 cnpm 命令来安装模块了：\n```\ncnpm install [name]\n```\n\n### NPM 常用命令\n```\nNPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。\n\nNPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。\n\n使用npm help <command>可查看某条命令的详细帮助，例如npm help install。\n\n在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。\n\n使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。\n\n使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。\n\n使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。\n\n使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。\n```\n\n\n\n原文：\nhttps://segmentfault.com/a/1190000007624021\nhttp://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\nhttps://www.runoob.com/nodejs/nodejs-npm.html\n","source":"_posts/Nodejs之npm&package.json学习.md","raw":"title: Nodejs之npm&package.json学习\ndate: 2018/05/18\ncategories: Nodejs\ntags:\n  - Nodejs\n---\n\n作为前端，因为经常用到gulp，webpack等工具，所以我们最常见到的是npm和package.json，所以先总结一下它们俩的常用命令。\n\n## npm\n### 初始化\n```\n npm init //会询问package.json的各种信息，从而确认\n\n npm init --y //全部使用默认值,快速生成package.json\n```\n### 安装依赖包\n```\n npm install <package name> <package name> ...\n\n npm install <package name> -g\n\n npm install <package name> --save\n\n npm install <package name> --save-dev\n\n npm install <pacakage name>  --O //--save-optional  -B: --save-bundle  -E: --save-exact\n```\nnpm install <package name> -g :全局安装，需要注意的是全局模式并不是将一个模块安装包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用，-g的含义是将一个包安装为全局可用的可执行命令,例如gulp，webpack等。\n\n--save与--save-dev的区别 :\n--save:是生产环境中项目运行需要的依赖,比如代码所依赖的库或框架(Jquery,React等)，安装后被记录在package.json中的dependencies关键字下；\n--save-dev:开发时候需要的依赖，安装后被记录在devDependencies关键字下。如一些开发时候需要用的gulp，webpack工具。\n\n同样--O/B/E分别会被记录到对应的关键字下。\n\n### 更新依赖包\n```\n npm update\n\n npm update  -g\n\n npm outdated\n\n npm outdated -g\n```\n\n在项目目录下运行npm update可以升级项目中所用依赖到最新版本，而npm update -g则可以升级全局安装的依赖包到最新版。\n\nnpm outdated用于检查模块是否过时并列出。\n\n### 卸载依赖\n```\n npm uninstall <package name> <package name> ...\n\n npm uninstall <package name> -g\n\n npm uninstall <package name> --save\n\n npm uninstall <package name> --save-dev\n```\n使用npm uninstall可以卸载依赖，但是卸载后，在package.json中的纪录并不会被删除，要想在卸载依赖的同时删除在package.json中的纪录，需要在卸载的时候使用安装时的所有的选项，例如，如果安装时候使用了npm install <package name> --save则卸载的时候，同样使用npm uninstall <pacakage name> --save，而如果使用了--save-dev，卸载时候也需要加相同的选项。\n\n### 使用自定义npm命令\n在package.json中，有一个scripts关键字，只需要在该关键字内写入自定义命令以及对应执行的实际命令即可。\n```\n\"scripts\":{\n    \"test\": \"nonde ./test.js\",\n    \"dev\": \"gulp --gulpfile gulpfile-dev.js\",\n    \"build\": \"gulp --gulpfile gulpfile-build.js\"\n}\n```\n上面的配置中，只要我们在终端运行npm dev就是运行了gulp --gulpfile gulpfile-dev.js，这样就省去了我们在终端输入很长的一段命令，非常方便。\n\n### 其他\nnpm view <pacakage name>可以查看包的package.json文件，如果只是看包的某个特性，在后面加上相应的key即可，例如npm v zepto version就是查看当前安装的zepto的版本，v是view的简写。\n\nnpm ls可以分析出当前当前项目下能够通过模块路径找到的所有包，并生成依赖树。\n\nnpm doc <package name>可以打开该依赖包的官网，其实就是打开了package.json中的homepage。\n\n## package.json文件\n在运行npm init后会生成package.json文件，该文件用于记录项目中所用到的依赖以及项目的配置信息（比如名称、版本、许可证等）。npm install命令根据这个配置文件自动下载项目运行和开发所需要的依赖。\n一个比较完整的package.json文件如下：\n```\n{\n    \"name\": \"project\", //包名\n    \"version\": \"1.0.0\", //版本号\n    \"author\": \"张三\", //包的作者的名字\n    \"description\": \"第一个node.js程序\",//包的描述\n    \"keywords\":[\"node.js\",\"javascript\"], //关键字\n    \"repository\": { //包代码存放的地方，可以是git或者svn\n        \"type\": \"git\",\n        \"url\": \"https://path/to/url\"\n    },\n    \"license\":\"MIT\",//开源许可证\n    \"engines\": {\"node\": \"0.10.x\"},\n    \"bugs\":{\"url\":\"http://path/to/bug\",\"email\":\"bug@example.com\"},\n    \"contributors\":[{\"name\":\"李四\",\"email\":\"lisi@example.com\"}],\n    \"scripts\": {\n        \"start\": \"node index.js\"\n    },\n    \"dependencies\": {\n        \"express\": \"latest\",\n        \"mongoose\": \"~3.8.3\"\n    },\n    \"devDependencies\": {\n        \"grunt\": \"~0.4.1\",\n        \"grunt-contrib-concat\": \"~0.3.0\"\n    }\n}\n```\n1. 小标签1：如何为代码选择开源许可证，这是一个问题。\n世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种----GPL、BSD、MIT、Mozilla、Apache和LGPL----之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是阮一峰老师制作的中文版，请点击看大图。\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/license.png)\n2. engines\n```\n可选字段。既可以指定node版本:\n { \"engines\" : {\"node\" : \">=0.10.3 <0.12\" } }\n也可以指定npm版本：\n { \"engines\" : {\"npm\" : \"~1.0.20\" } }\n```\n\n3. scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包.\n示例如下:\n```\n\n\"scripts\":{\n\n    “install”:\"install.js\",\n\n    \"test\":\"test.js\"\n\n}\n```\n4. main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果该字段不存在，则node会检查目录下的index.js，index.node，index.json作为默认入口。\n\n\n### 使用淘宝 NPM 镜像\n大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。\n\n淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。\n\n你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n这样就可以使用 cnpm 命令来安装模块了：\n```\ncnpm install [name]\n```\n\n### NPM 常用命令\n```\nNPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。\n\nNPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。\n\n使用npm help <command>可查看某条命令的详细帮助，例如npm help install。\n\n在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。\n\n使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。\n\n使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。\n\n使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。\n\n使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。\n```\n\n\n\n原文：\nhttps://segmentfault.com/a/1190000007624021\nhttp://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\nhttps://www.runoob.com/nodejs/nodejs-npm.html\n","slug":"Nodejs之npm&package.json学习","published":1,"updated":"2018-06-24T15:32:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uws000g7q0tped9yngl","content":"<p>作为前端，因为经常用到gulp，webpack等工具，所以我们最常见到的是npm和package.json，所以先总结一下它们俩的常用命令。</p>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">init</span> <span class=\"comment\">//会询问package.json的各种信息，从而确认</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">init</span> --y <span class=\"comment\">//全部使用默认值,快速生成package.json</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; -g</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save-dev</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;pacakage <span class=\"keyword\">name</span>&gt;  <span class=\"comment\">--O //--save-optional  -B: --save-bundle  -E: --save-exact</span></span><br></pre></td></tr></table></figure>\n<p>npm install <package name=\"\"> -g :全局安装，需要注意的是全局模式并不是将一个模块安装包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用，-g的含义是将一个包安装为全局可用的可执行命令,例如gulp，webpack等。</package></p>\n<p>–save与–save-dev的区别 :<br>–save:是生产环境中项目运行需要的依赖,比如代码所依赖的库或框架(Jquery,React等)，安装后被记录在package.json中的dependencies关键字下；<br>–save-dev:开发时候需要的依赖，安装后被记录在devDependencies关键字下。如一些开发时候需要用的gulp，webpack工具。</p>\n<p>同样–O/B/E分别会被记录到对应的关键字下。</p>\n<h3 id=\"更新依赖包\"><a href=\"#更新依赖包\" class=\"headerlink\" title=\"更新依赖包\"></a>更新依赖包</h3><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> update  -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> outdated</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> outdated -g</span><br></pre></td></tr></table></figure>\n<p>在项目目录下运行npm update可以升级项目中所用依赖到最新版本，而npm update -g则可以升级全局安装的依赖包到最新版。</p>\n<p>npm outdated用于检查模块是否过时并列出。</p>\n<h3 id=\"卸载依赖\"><a href=\"#卸载依赖\" class=\"headerlink\" title=\"卸载依赖\"></a>卸载依赖</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; -g</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save-dev</span></span><br></pre></td></tr></table></figure>\n<p>使用npm uninstall可以卸载依赖，但是卸载后，在package.json中的纪录并不会被删除，要想在卸载依赖的同时删除在package.json中的纪录，需要在卸载的时候使用安装时的所有的选项，例如，如果安装时候使用了npm install <package name=\"\"> –save则卸载的时候，同样使用npm uninstall <pacakage name=\"\"> –save，而如果使用了–save-dev，卸载时候也需要加相同的选项。</pacakage></package></p>\n<h3 id=\"使用自定义npm命令\"><a href=\"#使用自定义npm命令\" class=\"headerlink\" title=\"使用自定义npm命令\"></a>使用自定义npm命令</h3><p>在package.json中，有一个scripts关键字，只需要在该关键字内写入自定义命令以及对应执行的实际命令即可。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"nonde ./test.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"gulp --gulpfile gulpfile-dev.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"gulp --gulpfile gulpfile-build.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的配置中，只要我们在终端运行npm dev就是运行了gulp –gulpfile gulpfile-dev.js，这样就省去了我们在终端输入很长的一段命令，非常方便。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>npm view <pacakage name=\"\">可以查看包的package.json文件，如果只是看包的某个特性，在后面加上相应的key即可，例如npm v zepto version就是查看当前安装的zepto的版本，v是view的简写。</pacakage></p>\n<p>npm ls可以分析出当前当前项目下能够通过模块路径找到的所有包，并生成依赖树。</p>\n<p>npm doc <package name=\"\">可以打开该依赖包的官网，其实就是打开了package.json中的homepage。</package></p>\n<h2 id=\"package-json文件\"><a href=\"#package-json文件\" class=\"headerlink\" title=\"package.json文件\"></a>package.json文件</h2><p>在运行npm init后会生成package.json文件，该文件用于记录项目中所用到的依赖以及项目的配置信息（比如名称、版本、许可证等）。npm install命令根据这个配置文件自动下载项目运行和开发所需要的依赖。<br>一个比较完整的package.json文件如下：<br><figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"project\"</span>, //包名</span><br><span class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>, //版本号</span><br><span class=\"line\">    <span class=\"string\">\"author\"</span>: <span class=\"string\">\"张三\"</span>, //包的作者的名字</span><br><span class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"第一个node.js程序\"</span>,//包的描述</span><br><span class=\"line\">    <span class=\"string\">\"keywords\"</span>:[<span class=\"string\">\"node.js\"</span>,<span class=\"string\">\"javascript\"</span>], //关键字</span><br><span class=\"line\">    <span class=\"string\">\"repository\"</span>: &#123; //包代码存放的地方，可以是git或者svn</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://path/to/url\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"license\"</span>:<span class=\"string\">\"MIT\"</span>,//开源许可证</span><br><span class=\"line\">    <span class=\"string\">\"engines\"</span>: &#123;<span class=\"string\">\"node\"</span>: <span class=\"string\">\"0.10.x\"</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"bugs\"</span>:&#123;<span class=\"string\">\"url\"</span>:<span class=\"string\">\"http://path/to/bug\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"bug@example.com\"</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"contributors\"</span>:[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"李四\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"lisi@example.com\"</span>&#125;],</span><br><span class=\"line\">    <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"start\"</span>: <span class=\"string\">\"node index.js\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"express\"</span>: <span class=\"string\">\"latest\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"mongoose\"</span>: <span class=\"string\">\"~3.8.3\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"grunt\"</span>: <span class=\"string\">\"~0.4.1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"grunt-contrib-concat\"</span>: <span class=\"string\">\"~0.3.0\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>小标签1：如何为代码选择开源许可证，这是一个问题。<br>世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是阮一峰老师制作的中文版，请点击看大图。<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/license.png\" alt=\"\"></li>\n<li><p>engines</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可选字段。既可以指定node版本:</span><br><span class=\"line\"> &#123; <span class=\"string\">\"engines\"</span> : &#123;<span class=\"string\">\"node\"</span> : <span class=\"string\">\"&gt;=0.10.3 &lt;0.12\"</span> &#125; &#125;</span><br><span class=\"line\">也可以指定npm版本：</span><br><span class=\"line\"> &#123; <span class=\"string\">\"engines\"</span> : &#123;<span class=\"string\">\"npm\"</span> : <span class=\"string\">\"~1.0.20\"</span> &#125; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包.<br>示例如下:</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    “<span class=\"keyword\">install</span>”:<span class=\"string\">\"install.js\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>:<span class=\"string\">\"test.js\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果该字段不存在，则node会检查目录下的index.js，index.node，index.json作为默认入口。</p>\n</li>\n</ol>\n<h3 id=\"使用淘宝-NPM-镜像\"><a href=\"#使用淘宝-NPM-镜像\" class=\"headerlink\" title=\"使用淘宝 NPM 镜像\"></a>使用淘宝 NPM 镜像</h3><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>\n<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>\n<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:<br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> install -g cnpm --registry=https:<span class=\"regexp\">//</span>registry.<span class=\"built_in\">npm</span>.taobao.org</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以使用 cnpm 命令来安装模块了：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm <span class=\"keyword\">install</span> [<span class=\"keyword\">name</span>]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"NPM-常用命令\"><a href=\"#NPM-常用命令\" class=\"headerlink\" title=\"NPM 常用命令\"></a>NPM 常用命令</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NPM提供了很多命令，例如<span class=\"keyword\">install</span>和publish，使用npm <span class=\"keyword\">help</span>可查看所有命令。</span><br><span class=\"line\"></span><br><span class=\"line\">NPM提供了很多命令，例如<span class=\"keyword\">install</span>和publish，使用npm <span class=\"keyword\">help</span>可查看所有命令。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm <span class=\"keyword\">help</span> &lt;command&gt;可查看某条命令的详细帮助，例如npm <span class=\"keyword\">help</span> <span class=\"keyword\">install</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">在package.json所在目录下使用npm <span class=\"keyword\">install</span> . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm <span class=\"keyword\">update</span> &lt;<span class=\"keyword\">package</span>&gt;可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm <span class=\"keyword\">update</span> &lt;<span class=\"keyword\">package</span>&gt; -g可以把全局安装的对应命令行程序更新至最新版。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm <span class=\"keyword\">cache</span> <span class=\"keyword\">clear</span>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm unpublish &lt;<span class=\"keyword\">package</span>&gt;@&lt;<span class=\"keyword\">version</span>&gt;可以撤销发布自己发布过的某个版本代码。</span><br></pre></td></tr></table></figure>\n<p>原文：<br><a href=\"https://segmentfault.com/a/1190000007624021\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007624021</a><br><a href=\"http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a><br><a href=\"https://www.runoob.com/nodejs/nodejs-npm.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/nodejs/nodejs-npm.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>作为前端，因为经常用到gulp，webpack等工具，所以我们最常见到的是npm和package.json，所以先总结一下它们俩的常用命令。</p>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">init</span> <span class=\"comment\">//会询问package.json的各种信息，从而确认</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">init</span> --y <span class=\"comment\">//全部使用默认值,快速生成package.json</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; -g</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save-dev</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">install</span> &lt;pacakage <span class=\"keyword\">name</span>&gt;  <span class=\"comment\">--O //--save-optional  -B: --save-bundle  -E: --save-exact</span></span><br></pre></td></tr></table></figure>\n<p>npm install <package name=\"\"> -g :全局安装，需要注意的是全局模式并不是将一个模块安装包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用，-g的含义是将一个包安装为全局可用的可执行命令,例如gulp，webpack等。</package></p>\n<p>–save与–save-dev的区别 :<br>–save:是生产环境中项目运行需要的依赖,比如代码所依赖的库或框架(Jquery,React等)，安装后被记录在package.json中的dependencies关键字下；<br>–save-dev:开发时候需要的依赖，安装后被记录在devDependencies关键字下。如一些开发时候需要用的gulp，webpack工具。</p>\n<p>同样–O/B/E分别会被记录到对应的关键字下。</p>\n<h3 id=\"更新依赖包\"><a href=\"#更新依赖包\" class=\"headerlink\" title=\"更新依赖包\"></a>更新依赖包</h3><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> update  -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> outdated</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">npm</span> outdated -g</span><br></pre></td></tr></table></figure>\n<p>在项目目录下运行npm update可以升级项目中所用依赖到最新版本，而npm update -g则可以升级全局安装的依赖包到最新版。</p>\n<p>npm outdated用于检查模块是否过时并列出。</p>\n<h3 id=\"卸载依赖\"><a href=\"#卸载依赖\" class=\"headerlink\" title=\"卸载依赖\"></a>卸载依赖</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; -g</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"keyword\">uninstall</span> &lt;<span class=\"keyword\">package</span> <span class=\"keyword\">name</span>&gt; <span class=\"comment\">--save-dev</span></span><br></pre></td></tr></table></figure>\n<p>使用npm uninstall可以卸载依赖，但是卸载后，在package.json中的纪录并不会被删除，要想在卸载依赖的同时删除在package.json中的纪录，需要在卸载的时候使用安装时的所有的选项，例如，如果安装时候使用了npm install <package name=\"\"> –save则卸载的时候，同样使用npm uninstall <pacakage name=\"\"> –save，而如果使用了–save-dev，卸载时候也需要加相同的选项。</pacakage></package></p>\n<h3 id=\"使用自定义npm命令\"><a href=\"#使用自定义npm命令\" class=\"headerlink\" title=\"使用自定义npm命令\"></a>使用自定义npm命令</h3><p>在package.json中，有一个scripts关键字，只需要在该关键字内写入自定义命令以及对应执行的实际命令即可。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"nonde ./test.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"gulp --gulpfile gulpfile-dev.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"gulp --gulpfile gulpfile-build.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的配置中，只要我们在终端运行npm dev就是运行了gulp –gulpfile gulpfile-dev.js，这样就省去了我们在终端输入很长的一段命令，非常方便。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>npm view <pacakage name=\"\">可以查看包的package.json文件，如果只是看包的某个特性，在后面加上相应的key即可，例如npm v zepto version就是查看当前安装的zepto的版本，v是view的简写。</pacakage></p>\n<p>npm ls可以分析出当前当前项目下能够通过模块路径找到的所有包，并生成依赖树。</p>\n<p>npm doc <package name=\"\">可以打开该依赖包的官网，其实就是打开了package.json中的homepage。</package></p>\n<h2 id=\"package-json文件\"><a href=\"#package-json文件\" class=\"headerlink\" title=\"package.json文件\"></a>package.json文件</h2><p>在运行npm init后会生成package.json文件，该文件用于记录项目中所用到的依赖以及项目的配置信息（比如名称、版本、许可证等）。npm install命令根据这个配置文件自动下载项目运行和开发所需要的依赖。<br>一个比较完整的package.json文件如下：<br><figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"project\"</span>, //包名</span><br><span class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>, //版本号</span><br><span class=\"line\">    <span class=\"string\">\"author\"</span>: <span class=\"string\">\"张三\"</span>, //包的作者的名字</span><br><span class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"第一个node.js程序\"</span>,//包的描述</span><br><span class=\"line\">    <span class=\"string\">\"keywords\"</span>:[<span class=\"string\">\"node.js\"</span>,<span class=\"string\">\"javascript\"</span>], //关键字</span><br><span class=\"line\">    <span class=\"string\">\"repository\"</span>: &#123; //包代码存放的地方，可以是git或者svn</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://path/to/url\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"license\"</span>:<span class=\"string\">\"MIT\"</span>,//开源许可证</span><br><span class=\"line\">    <span class=\"string\">\"engines\"</span>: &#123;<span class=\"string\">\"node\"</span>: <span class=\"string\">\"0.10.x\"</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"bugs\"</span>:&#123;<span class=\"string\">\"url\"</span>:<span class=\"string\">\"http://path/to/bug\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"bug@example.com\"</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"contributors\"</span>:[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"李四\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"lisi@example.com\"</span>&#125;],</span><br><span class=\"line\">    <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"start\"</span>: <span class=\"string\">\"node index.js\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"express\"</span>: <span class=\"string\">\"latest\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"mongoose\"</span>: <span class=\"string\">\"~3.8.3\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"grunt\"</span>: <span class=\"string\">\"~0.4.1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"grunt-contrib-concat\"</span>: <span class=\"string\">\"~0.3.0\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>小标签1：如何为代码选择开源许可证，这是一个问题。<br>世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是阮一峰老师制作的中文版，请点击看大图。<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/license.png\" alt=\"\"></li>\n<li><p>engines</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可选字段。既可以指定node版本:</span><br><span class=\"line\"> &#123; <span class=\"string\">\"engines\"</span> : &#123;<span class=\"string\">\"node\"</span> : <span class=\"string\">\"&gt;=0.10.3 &lt;0.12\"</span> &#125; &#125;</span><br><span class=\"line\">也可以指定npm版本：</span><br><span class=\"line\"> &#123; <span class=\"string\">\"engines\"</span> : &#123;<span class=\"string\">\"npm\"</span> : <span class=\"string\">\"~1.0.20\"</span> &#125; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包.<br>示例如下:</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    “<span class=\"keyword\">install</span>”:<span class=\"string\">\"install.js\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>:<span class=\"string\">\"test.js\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果该字段不存在，则node会检查目录下的index.js，index.node，index.json作为默认入口。</p>\n</li>\n</ol>\n<h3 id=\"使用淘宝-NPM-镜像\"><a href=\"#使用淘宝-NPM-镜像\" class=\"headerlink\" title=\"使用淘宝 NPM 镜像\"></a>使用淘宝 NPM 镜像</h3><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>\n<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>\n<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:<br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> install -g cnpm --registry=https:<span class=\"regexp\">//</span>registry.<span class=\"built_in\">npm</span>.taobao.org</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以使用 cnpm 命令来安装模块了：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm <span class=\"keyword\">install</span> [<span class=\"keyword\">name</span>]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"NPM-常用命令\"><a href=\"#NPM-常用命令\" class=\"headerlink\" title=\"NPM 常用命令\"></a>NPM 常用命令</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NPM提供了很多命令，例如<span class=\"keyword\">install</span>和publish，使用npm <span class=\"keyword\">help</span>可查看所有命令。</span><br><span class=\"line\"></span><br><span class=\"line\">NPM提供了很多命令，例如<span class=\"keyword\">install</span>和publish，使用npm <span class=\"keyword\">help</span>可查看所有命令。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm <span class=\"keyword\">help</span> &lt;command&gt;可查看某条命令的详细帮助，例如npm <span class=\"keyword\">help</span> <span class=\"keyword\">install</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">在package.json所在目录下使用npm <span class=\"keyword\">install</span> . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm <span class=\"keyword\">update</span> &lt;<span class=\"keyword\">package</span>&gt;可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm <span class=\"keyword\">update</span> &lt;<span class=\"keyword\">package</span>&gt; -g可以把全局安装的对应命令行程序更新至最新版。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm <span class=\"keyword\">cache</span> <span class=\"keyword\">clear</span>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</span><br><span class=\"line\"></span><br><span class=\"line\">使用npm unpublish &lt;<span class=\"keyword\">package</span>&gt;@&lt;<span class=\"keyword\">version</span>&gt;可以撤销发布自己发布过的某个版本代码。</span><br></pre></td></tr></table></figure>\n<p>原文：<br><a href=\"https://segmentfault.com/a/1190000007624021\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007624021</a><br><a href=\"http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a><br><a href=\"https://www.runoob.com/nodejs/nodejs-npm.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/nodejs/nodejs-npm.html</a></p>\n"},{"title":"React 深入之 diff算法","date":"2018-07-18T16:00:00.000Z","toc":true,"_content":"\n### React diff算法优点在哪？\n计算一棵树形结构转换成另外一棵树结构的最少操作，是一个复杂且值得研究的问题。传统diff算法通过循环递归对子节点进行一次对比，效率低下，算法复杂度达到O(n<sup>3</sup>),其中n是树节点的总数。计算量非常大，所以想要将diff思想引入Virtual Dom，就要设计一种稳定、高效的diff算法。\n\n\n### 每种UI场景中，diff算法是如何进行操作的？\n假设场景：\n![虚拟dom是如何工作的](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff1.jpg)\n当dom从第一个场景变化为第二个场景时，程序是如何自动diff的？\n\n\n采取的是 **广度优先分层比较**：\n拿到前后两个状态的dom树之后，会对他们从上而下进行一层一层的比较，比如图中A和B的位置发生变化，A的子节点类型发生变化等\n1. 从根节点进行比较\n![从根节点进行比较](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff3.jpg)\n发现两个节点是一样的，所以不做任何修改。\n\n2. 属性以及顺序发生变化\n![属性以及顺序发生变化](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff4.jpg)\n程序需要知道A和B的唯一标识，来判断他们是否发生改变，检测到修改后，调换A和B的位置\n\n3. 节点类型发生变化\n![节点类型发生变化](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff5.jpg)\nA下面的节点从F节点变成G节点，节点类型发生变化时，React会直接把F节点删掉，创建新节点然后append到A上面，而不会去管F节点是否被其他地方引用到。\n只会简单的把F删掉，换成G\n\n4. 节点跨层移动（react核心优化的点）\n![节点跨层移动](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/6.jpg)\n\n从图上可以看到B与原来的子元素D中间加了一个元素，然而react并不会这样操作，diff算法会直接从B节点下面把D节点已经D的子元素全部删掉，\n比对到第四层的时候，会再创建一个全新的D节点添加到树上去\n\nReact由于采用了分层比较的方法，把算法复杂度从O(n^3)降低到了O(n)，那么该策略是否会在跟新时有问题呢？\n\n事实证明并不会，因为大多数情况下，我们的dom结构是相对固定的，一般都是dom节点的位置或者属性发生变化，或者新建、删除节点等，真实情况下很少会发生跨层移动的场景，所以舍弃这一层比较，会极大提升react性能而无太大影响\n\n\n### 虚拟DOM基于的两个假设\n1. 组件的 DOM 结构是相对稳定的\n2. 类型相同的兄弟节点可以被唯一标识(key属性不仅被用来消除warning,更是提高性能的一种方式)\n\n\n参考：\n1. https://doc.react-china.org/docs/reconciliation.html\n2. 《深入React技术栈》\n","source":"_posts/React 深入之diff算法.md","raw":"title: React 深入之 diff算法\ndate: 2018/07/19\ncategories:\n  - 库/框架\ntoc: true\ntags:\n  - React\n  - diff算法\n---\n\n### React diff算法优点在哪？\n计算一棵树形结构转换成另外一棵树结构的最少操作，是一个复杂且值得研究的问题。传统diff算法通过循环递归对子节点进行一次对比，效率低下，算法复杂度达到O(n<sup>3</sup>),其中n是树节点的总数。计算量非常大，所以想要将diff思想引入Virtual Dom，就要设计一种稳定、高效的diff算法。\n\n\n### 每种UI场景中，diff算法是如何进行操作的？\n假设场景：\n![虚拟dom是如何工作的](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff1.jpg)\n当dom从第一个场景变化为第二个场景时，程序是如何自动diff的？\n\n\n采取的是 **广度优先分层比较**：\n拿到前后两个状态的dom树之后，会对他们从上而下进行一层一层的比较，比如图中A和B的位置发生变化，A的子节点类型发生变化等\n1. 从根节点进行比较\n![从根节点进行比较](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff3.jpg)\n发现两个节点是一样的，所以不做任何修改。\n\n2. 属性以及顺序发生变化\n![属性以及顺序发生变化](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff4.jpg)\n程序需要知道A和B的唯一标识，来判断他们是否发生改变，检测到修改后，调换A和B的位置\n\n3. 节点类型发生变化\n![节点类型发生变化](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff5.jpg)\nA下面的节点从F节点变成G节点，节点类型发生变化时，React会直接把F节点删掉，创建新节点然后append到A上面，而不会去管F节点是否被其他地方引用到。\n只会简单的把F删掉，换成G\n\n4. 节点跨层移动（react核心优化的点）\n![节点跨层移动](https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/6.jpg)\n\n从图上可以看到B与原来的子元素D中间加了一个元素，然而react并不会这样操作，diff算法会直接从B节点下面把D节点已经D的子元素全部删掉，\n比对到第四层的时候，会再创建一个全新的D节点添加到树上去\n\nReact由于采用了分层比较的方法，把算法复杂度从O(n^3)降低到了O(n)，那么该策略是否会在跟新时有问题呢？\n\n事实证明并不会，因为大多数情况下，我们的dom结构是相对固定的，一般都是dom节点的位置或者属性发生变化，或者新建、删除节点等，真实情况下很少会发生跨层移动的场景，所以舍弃这一层比较，会极大提升react性能而无太大影响\n\n\n### 虚拟DOM基于的两个假设\n1. 组件的 DOM 结构是相对稳定的\n2. 类型相同的兄弟节点可以被唯一标识(key属性不仅被用来消除warning,更是提高性能的一种方式)\n\n\n参考：\n1. https://doc.react-china.org/docs/reconciliation.html\n2. 《深入React技术栈》\n","slug":"React 深入之diff算法","published":1,"updated":"2018-07-20T10:25:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uwv000h7q0tmrsfhjtt","content":"<h3 id=\"React-diff算法优点在哪？\"><a href=\"#React-diff算法优点在哪？\" class=\"headerlink\" title=\"React diff算法优点在哪？\"></a>React diff算法优点在哪？</h3><p>计算一棵树形结构转换成另外一棵树结构的最少操作，是一个复杂且值得研究的问题。传统diff算法通过循环递归对子节点进行一次对比，效率低下，算法复杂度达到O(n<sup>3</sup>),其中n是树节点的总数。计算量非常大，所以想要将diff思想引入Virtual Dom，就要设计一种稳定、高效的diff算法。</p>\n<h3 id=\"每种UI场景中，diff算法是如何进行操作的？\"><a href=\"#每种UI场景中，diff算法是如何进行操作的？\" class=\"headerlink\" title=\"每种UI场景中，diff算法是如何进行操作的？\"></a>每种UI场景中，diff算法是如何进行操作的？</h3><p>假设场景：<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff1.jpg\" alt=\"虚拟dom是如何工作的\"><br>当dom从第一个场景变化为第二个场景时，程序是如何自动diff的？</p>\n<p>采取的是 <strong>广度优先分层比较</strong>：<br>拿到前后两个状态的dom树之后，会对他们从上而下进行一层一层的比较，比如图中A和B的位置发生变化，A的子节点类型发生变化等</p>\n<ol>\n<li><p>从根节点进行比较<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff3.jpg\" alt=\"从根节点进行比较\"><br>发现两个节点是一样的，所以不做任何修改。</p>\n</li>\n<li><p>属性以及顺序发生变化<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff4.jpg\" alt=\"属性以及顺序发生变化\"><br>程序需要知道A和B的唯一标识，来判断他们是否发生改变，检测到修改后，调换A和B的位置</p>\n</li>\n<li><p>节点类型发生变化<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff5.jpg\" alt=\"节点类型发生变化\"><br>A下面的节点从F节点变成G节点，节点类型发生变化时，React会直接把F节点删掉，创建新节点然后append到A上面，而不会去管F节点是否被其他地方引用到。<br>只会简单的把F删掉，换成G</p>\n</li>\n<li><p>节点跨层移动（react核心优化的点）<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/6.jpg\" alt=\"节点跨层移动\"></p>\n</li>\n</ol>\n<p>从图上可以看到B与原来的子元素D中间加了一个元素，然而react并不会这样操作，diff算法会直接从B节点下面把D节点已经D的子元素全部删掉，<br>比对到第四层的时候，会再创建一个全新的D节点添加到树上去</p>\n<p>React由于采用了分层比较的方法，把算法复杂度从O(n^3)降低到了O(n)，那么该策略是否会在跟新时有问题呢？</p>\n<p>事实证明并不会，因为大多数情况下，我们的dom结构是相对固定的，一般都是dom节点的位置或者属性发生变化，或者新建、删除节点等，真实情况下很少会发生跨层移动的场景，所以舍弃这一层比较，会极大提升react性能而无太大影响</p>\n<h3 id=\"虚拟DOM基于的两个假设\"><a href=\"#虚拟DOM基于的两个假设\" class=\"headerlink\" title=\"虚拟DOM基于的两个假设\"></a>虚拟DOM基于的两个假设</h3><ol>\n<li>组件的 DOM 结构是相对稳定的</li>\n<li>类型相同的兄弟节点可以被唯一标识(key属性不仅被用来消除warning,更是提高性能的一种方式)</li>\n</ol>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://doc.react-china.org/docs/reconciliation.html\" target=\"_blank\" rel=\"noopener\">https://doc.react-china.org/docs/reconciliation.html</a></li>\n<li>《深入React技术栈》</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"React-diff算法优点在哪？\"><a href=\"#React-diff算法优点在哪？\" class=\"headerlink\" title=\"React diff算法优点在哪？\"></a>React diff算法优点在哪？</h3><p>计算一棵树形结构转换成另外一棵树结构的最少操作，是一个复杂且值得研究的问题。传统diff算法通过循环递归对子节点进行一次对比，效率低下，算法复杂度达到O(n<sup>3</sup>),其中n是树节点的总数。计算量非常大，所以想要将diff思想引入Virtual Dom，就要设计一种稳定、高效的diff算法。</p>\n<h3 id=\"每种UI场景中，diff算法是如何进行操作的？\"><a href=\"#每种UI场景中，diff算法是如何进行操作的？\" class=\"headerlink\" title=\"每种UI场景中，diff算法是如何进行操作的？\"></a>每种UI场景中，diff算法是如何进行操作的？</h3><p>假设场景：<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff1.jpg\" alt=\"虚拟dom是如何工作的\"><br>当dom从第一个场景变化为第二个场景时，程序是如何自动diff的？</p>\n<p>采取的是 <strong>广度优先分层比较</strong>：<br>拿到前后两个状态的dom树之后，会对他们从上而下进行一层一层的比较，比如图中A和B的位置发生变化，A的子节点类型发生变化等</p>\n<ol>\n<li><p>从根节点进行比较<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff3.jpg\" alt=\"从根节点进行比较\"><br>发现两个节点是一样的，所以不做任何修改。</p>\n</li>\n<li><p>属性以及顺序发生变化<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff4.jpg\" alt=\"属性以及顺序发生变化\"><br>程序需要知道A和B的唯一标识，来判断他们是否发生改变，检测到修改后，调换A和B的位置</p>\n</li>\n<li><p>节点类型发生变化<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/diff5.jpg\" alt=\"节点类型发生变化\"><br>A下面的节点从F节点变成G节点，节点类型发生变化时，React会直接把F节点删掉，创建新节点然后append到A上面，而不会去管F节点是否被其他地方引用到。<br>只会简单的把F删掉，换成G</p>\n</li>\n<li><p>节点跨层移动（react核心优化的点）<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/react%20diff%20/6.jpg\" alt=\"节点跨层移动\"></p>\n</li>\n</ol>\n<p>从图上可以看到B与原来的子元素D中间加了一个元素，然而react并不会这样操作，diff算法会直接从B节点下面把D节点已经D的子元素全部删掉，<br>比对到第四层的时候，会再创建一个全新的D节点添加到树上去</p>\n<p>React由于采用了分层比较的方法，把算法复杂度从O(n^3)降低到了O(n)，那么该策略是否会在跟新时有问题呢？</p>\n<p>事实证明并不会，因为大多数情况下，我们的dom结构是相对固定的，一般都是dom节点的位置或者属性发生变化，或者新建、删除节点等，真实情况下很少会发生跨层移动的场景，所以舍弃这一层比较，会极大提升react性能而无太大影响</p>\n<h3 id=\"虚拟DOM基于的两个假设\"><a href=\"#虚拟DOM基于的两个假设\" class=\"headerlink\" title=\"虚拟DOM基于的两个假设\"></a>虚拟DOM基于的两个假设</h3><ol>\n<li>组件的 DOM 结构是相对稳定的</li>\n<li>类型相同的兄弟节点可以被唯一标识(key属性不仅被用来消除warning,更是提高性能的一种方式)</li>\n</ol>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://doc.react-china.org/docs/reconciliation.html\" target=\"_blank\" rel=\"noopener\">https://doc.react-china.org/docs/reconciliation.html</a></li>\n<li>《深入React技术栈》</li>\n</ol>\n"},{"title":"React-Element中的StyleSheet.reset方法为何可以重置样式？","date":"2018-06-12T16:00:00.000Z","_content":"\n在React-Element的Select组件中，一上来就来了行看不懂的代码，\n```\nStyleSheet.reset(`\n  .ishow-select-dropdown {\n    position: absolute !important;\n  }\n`)\n```\n发现该方法可以实现，在当前页面插入带着样式的style标签，来实现对css的覆盖，心生疑虑，这到底是react的API还是es7黑魔法？\n\n而后发现 Style只是从外部引入的一个模块，代码 动态添加了style节点\n\n```\nexports.reset = css => {\n  const style = document.createElement('style'); //通过指定名称创建一个style元素\n\n  style.type = 'text/css';\n  //1.必需的 type 属性规定样式表的 MIME 类型。  2.type 属性指示 <style> 与 </style> 标签之间的内容。 3.值 \"text/css\" 指示内容是标准的 CSS。\n\n  if (style.styleSheet){\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n«»\n  (document.head || document.getElementsByTagName('head')[0]).appendChild(style);\n}\n```\n\n被这波原生js操作晃瞎了眼呀~只好再复习下原生用法\n\n- [style 标签的 type 属性](http://www.w3school.com.cn/tags/att_style_type.asp)\n","source":"_posts/React-Element中的StyleSheet.reset方法为何可以重置样式？.md","raw":"title: React-Element中的StyleSheet.reset方法为何可以重置样式？\ndate: 2018/06/13\ncategories: 十万个为什么\ntags:\n  - Javascript\n  - React\n\n---\n\n在React-Element的Select组件中，一上来就来了行看不懂的代码，\n```\nStyleSheet.reset(`\n  .ishow-select-dropdown {\n    position: absolute !important;\n  }\n`)\n```\n发现该方法可以实现，在当前页面插入带着样式的style标签，来实现对css的覆盖，心生疑虑，这到底是react的API还是es7黑魔法？\n\n而后发现 Style只是从外部引入的一个模块，代码 动态添加了style节点\n\n```\nexports.reset = css => {\n  const style = document.createElement('style'); //通过指定名称创建一个style元素\n\n  style.type = 'text/css';\n  //1.必需的 type 属性规定样式表的 MIME 类型。  2.type 属性指示 <style> 与 </style> 标签之间的内容。 3.值 \"text/css\" 指示内容是标准的 CSS。\n\n  if (style.styleSheet){\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n«»\n  (document.head || document.getElementsByTagName('head')[0]).appendChild(style);\n}\n```\n\n被这波原生js操作晃瞎了眼呀~只好再复习下原生用法\n\n- [style 标签的 type 属性](http://www.w3school.com.cn/tags/att_style_type.asp)\n","slug":"React-Element中的StyleSheet.reset方法为何可以重置样式？","published":1,"updated":"2018-06-13T13:05:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81ux0000l7q0toe4u70xu","content":"<p>在React-Element的Select组件中，一上来就来了行看不懂的代码，<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">StyleSheet</span><span class=\"selector-class\">.reset</span>(`</span><br><span class=\"line\">  <span class=\"selector-class\">.ishow-select-dropdown</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute <span class=\"meta\">!important</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">`)</span><br></pre></td></tr></table></figure></p>\n<p>发现该方法可以实现，在当前页面插入带着样式的style标签，来实现对css的覆盖，心生疑虑，这到底是react的API还是es7黑魔法？</p>\n<p>而后发现 Style只是从外部引入的一个模块，代码 动态添加了style节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.reset = <span class=\"function\"><span class=\"params\">css</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> style = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'style'</span>); <span class=\"comment\">//通过指定名称创建一个style元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">  style.type = <span class=\"string\">'text/css'</span>;</span><br><span class=\"line\">  <span class=\"comment\">//1.必需的 type 属性规定样式表的 MIME 类型。  2.type 属性指示 &lt;style&gt; 与 &lt;/style&gt; 标签之间的内容。 3.值 \"text/css\" 指示内容是标准的 CSS。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (style.styleSheet)&#123;</span><br><span class=\"line\">    style.styleSheet.cssText = css;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    style.appendChild(<span class=\"built_in\">document</span>.createTextNode(css));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">«»</span><br><span class=\"line\">  (<span class=\"built_in\">document</span>.head || <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>]).appendChild(style);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>被这波原生js操作晃瞎了眼呀~只好再复习下原生用法</p>\n<ul>\n<li><a href=\"http://www.w3school.com.cn/tags/att_style_type.asp\" target=\"_blank\" rel=\"noopener\">style 标签的 type 属性</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在React-Element的Select组件中，一上来就来了行看不懂的代码，<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">StyleSheet</span><span class=\"selector-class\">.reset</span>(`</span><br><span class=\"line\">  <span class=\"selector-class\">.ishow-select-dropdown</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute <span class=\"meta\">!important</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">`)</span><br></pre></td></tr></table></figure></p>\n<p>发现该方法可以实现，在当前页面插入带着样式的style标签，来实现对css的覆盖，心生疑虑，这到底是react的API还是es7黑魔法？</p>\n<p>而后发现 Style只是从外部引入的一个模块，代码 动态添加了style节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.reset = <span class=\"function\"><span class=\"params\">css</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> style = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'style'</span>); <span class=\"comment\">//通过指定名称创建一个style元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">  style.type = <span class=\"string\">'text/css'</span>;</span><br><span class=\"line\">  <span class=\"comment\">//1.必需的 type 属性规定样式表的 MIME 类型。  2.type 属性指示 &lt;style&gt; 与 &lt;/style&gt; 标签之间的内容。 3.值 \"text/css\" 指示内容是标准的 CSS。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (style.styleSheet)&#123;</span><br><span class=\"line\">    style.styleSheet.cssText = css;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    style.appendChild(<span class=\"built_in\">document</span>.createTextNode(css));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">«»</span><br><span class=\"line\">  (<span class=\"built_in\">document</span>.head || <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>]).appendChild(style);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>被这波原生js操作晃瞎了眼呀~只好再复习下原生用法</p>\n<ul>\n<li><a href=\"http://www.w3school.com.cn/tags/att_style_type.asp\" target=\"_blank\" rel=\"noopener\">style 标签的 type 属性</a></li>\n</ul>\n"},{"title":"React基础之 React基础之 key的必要性与使用","date":"2018-06-27T16:00:00.000Z","toc":true,"_content":"\n#### 参考资料：\n https://segmentfault.com/a/1190000009149186\n\n#### 总结\n1. **数组数据变更时，不要使用index作为key。**\n\n2. Keys应该是稳定的，可预测的，且唯一的。不稳定的key（类似由Math.random()生成的）将使得大量组件实例和DOM节点进行不必要的重建，使得性能下降并丢失子组件的状态。\n\n  new Date().getTime()好像不太好，但是感觉可以解决问题呢。==\n\n3. key属性是添加到自定义的子组件上，而不是子组件内部的顶层的组件上。\n\n    <MyComponent key={{item.key}}/>\n<!--more-->\n4. key值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。\n\n\n5. 不仅仅在数组生成组件上，其他地方也可以使用key，\n\n    主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例\n#### 具体内容\n1. key的作用\n\n        react利用key来识别组件，它是一种身份标识标识。\n\n        每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。\n\n2. 有了key属性后，就可以与组件建立了一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件。\n\n        A.key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。\n\n        B.key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件（有状态组件的constructor和componentWillUnmount都会执行）\n\n3. key不是用来提升react的性能的，不过用好key对性能是有帮助的。\n\n4. 使用最多的场景\n\n        A.由数组动态创建的子组件的情况，需要为每个子组件添加唯一的key属性值。\n\n        B.为一个有复杂繁琐逻辑的组件添加key后，后续操作可以改变该组件的key属性值，从而达到先销毁之前的组件，再重新创建该组件。\n\n5. index作为key是一种反模式\n\n        A.若数组的内容只是作为纯展示，而不涉及到数组的动态变更，其实是可以使用index作为key的。\n\n        B.若涉及到数组的动态变更，例如数组新增元素、删除元素或者重新排序等，这时index作为key会导致展示错误的数据。\n\n6. 动态数据使用index作为key的问题：\n\n    具体更新过程我们拿key=0的元素来说明， 数组重新排序后：\n\n        A.组件重新render得到新的虚拟dom；\n\n        B.新老两个虚拟dom进行diff，新老版的都有key=0的组件，react认为同一个组件，则只可能更新组件；\n\n        C.然后比较其children，发现内容的文本内容不同（由a--->c)，而input组件并没有变化，这时触发组件的componentWillReceiveProps方法，从而更新其子组件文本内容;\n\n        D.因为组件的children中input组件没有变化，其又与父组件传入的任props没有关联，所以input组件不会更新(即其componentWillReceiveProps方法不会被执行)，导致用户输入的值不会变化。\n","source":"_posts/React基础之 key的必要性与使用.md","raw":"title: React基础之 React基础之 key的必要性与使用\ndate: 2018/06/28\ncategories:\n  - 库/框架\ntoc: true\ntags:\n  - React\n---\n\n#### 参考资料：\n https://segmentfault.com/a/1190000009149186\n\n#### 总结\n1. **数组数据变更时，不要使用index作为key。**\n\n2. Keys应该是稳定的，可预测的，且唯一的。不稳定的key（类似由Math.random()生成的）将使得大量组件实例和DOM节点进行不必要的重建，使得性能下降并丢失子组件的状态。\n\n  new Date().getTime()好像不太好，但是感觉可以解决问题呢。==\n\n3. key属性是添加到自定义的子组件上，而不是子组件内部的顶层的组件上。\n\n    <MyComponent key={{item.key}}/>\n<!--more-->\n4. key值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。\n\n\n5. 不仅仅在数组生成组件上，其他地方也可以使用key，\n\n    主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例\n#### 具体内容\n1. key的作用\n\n        react利用key来识别组件，它是一种身份标识标识。\n\n        每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。\n\n2. 有了key属性后，就可以与组件建立了一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件。\n\n        A.key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。\n\n        B.key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件（有状态组件的constructor和componentWillUnmount都会执行）\n\n3. key不是用来提升react的性能的，不过用好key对性能是有帮助的。\n\n4. 使用最多的场景\n\n        A.由数组动态创建的子组件的情况，需要为每个子组件添加唯一的key属性值。\n\n        B.为一个有复杂繁琐逻辑的组件添加key后，后续操作可以改变该组件的key属性值，从而达到先销毁之前的组件，再重新创建该组件。\n\n5. index作为key是一种反模式\n\n        A.若数组的内容只是作为纯展示，而不涉及到数组的动态变更，其实是可以使用index作为key的。\n\n        B.若涉及到数组的动态变更，例如数组新增元素、删除元素或者重新排序等，这时index作为key会导致展示错误的数据。\n\n6. 动态数据使用index作为key的问题：\n\n    具体更新过程我们拿key=0的元素来说明， 数组重新排序后：\n\n        A.组件重新render得到新的虚拟dom；\n\n        B.新老两个虚拟dom进行diff，新老版的都有key=0的组件，react认为同一个组件，则只可能更新组件；\n\n        C.然后比较其children，发现内容的文本内容不同（由a--->c)，而input组件并没有变化，这时触发组件的componentWillReceiveProps方法，从而更新其子组件文本内容;\n\n        D.因为组件的children中input组件没有变化，其又与父组件传入的任props没有关联，所以input组件不会更新(即其componentWillReceiveProps方法不会被执行)，导致用户输入的值不会变化。\n","slug":"React基础之 key的必要性与使用","published":1,"updated":"2018-07-19T02:53:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81ux1000o7q0t4xvsigns","content":"<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p> <a href=\"https://segmentfault.com/a/1190000009149186\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009149186</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li><p><strong>数组数据变更时，不要使用index作为key。</strong></p>\n</li>\n<li><p>Keys应该是稳定的，可预测的，且唯一的。不稳定的key（类似由Math.random()生成的）将使得大量组件实例和DOM节点进行不必要的重建，使得性能下降并丢失子组件的状态。</p>\n<p>new Date().getTime()好像不太好，但是感觉可以解决问题呢。==</p>\n</li>\n<li><p>key属性是添加到自定义的子组件上，而不是子组件内部的顶层的组件上。</p>\n<p> &lt;MyComponent key=/&gt;</p>\n<a id=\"more\"></a></li>\n<li>key值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。</li>\n</ol>\n<ol start=\"5\">\n<li><p>不仅仅在数组生成组件上，其他地方也可以使用key，</p>\n<p> 主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例</p>\n<h4 id=\"具体内容\"><a href=\"#具体内容\" class=\"headerlink\" title=\"具体内容\"></a>具体内容</h4></li>\n<li><p>key的作用</p>\n<pre><code>react利用key来识别组件，它是一种身份标识标识。\n\n每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。\n</code></pre></li>\n<li><p>有了key属性后，就可以与组件建立了一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件。</p>\n<pre><code>A.key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。\n\nB.key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件（有状态组件的constructor和componentWillUnmount都会执行）\n</code></pre></li>\n<li><p>key不是用来提升react的性能的，不过用好key对性能是有帮助的。</p>\n</li>\n<li><p>使用最多的场景</p>\n<pre><code>A.由数组动态创建的子组件的情况，需要为每个子组件添加唯一的key属性值。\n\nB.为一个有复杂繁琐逻辑的组件添加key后，后续操作可以改变该组件的key属性值，从而达到先销毁之前的组件，再重新创建该组件。\n</code></pre></li>\n<li><p>index作为key是一种反模式</p>\n<pre><code>A.若数组的内容只是作为纯展示，而不涉及到数组的动态变更，其实是可以使用index作为key的。\n\nB.若涉及到数组的动态变更，例如数组新增元素、删除元素或者重新排序等，这时index作为key会导致展示错误的数据。\n</code></pre></li>\n<li><p>动态数据使用index作为key的问题：</p>\n<p> 具体更新过程我们拿key=0的元素来说明， 数组重新排序后：</p>\n<pre><code>A.组件重新render得到新的虚拟dom；\n\nB.新老两个虚拟dom进行diff，新老版的都有key=0的组件，react认为同一个组件，则只可能更新组件；\n\nC.然后比较其children，发现内容的文本内容不同（由a---&gt;c)，而input组件并没有变化，这时触发组件的componentWillReceiveProps方法，从而更新其子组件文本内容;\n\nD.因为组件的children中input组件没有变化，其又与父组件传入的任props没有关联，所以input组件不会更新(即其componentWillReceiveProps方法不会被执行)，导致用户输入的值不会变化。\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p> <a href=\"https://segmentfault.com/a/1190000009149186\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009149186</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li><p><strong>数组数据变更时，不要使用index作为key。</strong></p>\n</li>\n<li><p>Keys应该是稳定的，可预测的，且唯一的。不稳定的key（类似由Math.random()生成的）将使得大量组件实例和DOM节点进行不必要的重建，使得性能下降并丢失子组件的状态。</p>\n<p>new Date().getTime()好像不太好，但是感觉可以解决问题呢。==</p>\n</li>\n<li><p>key属性是添加到自定义的子组件上，而不是子组件内部的顶层的组件上。</p>\n<p> &lt;MyComponent key=/&gt;</p>","more":"</li>\n<li>key值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。</li>\n</ol>\n<ol start=\"5\">\n<li><p>不仅仅在数组生成组件上，其他地方也可以使用key，</p>\n<p> 主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例</p>\n<h4 id=\"具体内容\"><a href=\"#具体内容\" class=\"headerlink\" title=\"具体内容\"></a>具体内容</h4></li>\n<li><p>key的作用</p>\n<pre><code>react利用key来识别组件，它是一种身份标识标识。\n\n每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。\n</code></pre></li>\n<li><p>有了key属性后，就可以与组件建立了一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件。</p>\n<pre><code>A.key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。\n\nB.key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件（有状态组件的constructor和componentWillUnmount都会执行）\n</code></pre></li>\n<li><p>key不是用来提升react的性能的，不过用好key对性能是有帮助的。</p>\n</li>\n<li><p>使用最多的场景</p>\n<pre><code>A.由数组动态创建的子组件的情况，需要为每个子组件添加唯一的key属性值。\n\nB.为一个有复杂繁琐逻辑的组件添加key后，后续操作可以改变该组件的key属性值，从而达到先销毁之前的组件，再重新创建该组件。\n</code></pre></li>\n<li><p>index作为key是一种反模式</p>\n<pre><code>A.若数组的内容只是作为纯展示，而不涉及到数组的动态变更，其实是可以使用index作为key的。\n\nB.若涉及到数组的动态变更，例如数组新增元素、删除元素或者重新排序等，这时index作为key会导致展示错误的数据。\n</code></pre></li>\n<li><p>动态数据使用index作为key的问题：</p>\n<p> 具体更新过程我们拿key=0的元素来说明， 数组重新排序后：</p>\n<pre><code>A.组件重新render得到新的虚拟dom；\n\nB.新老两个虚拟dom进行diff，新老版的都有key=0的组件，react认为同一个组件，则只可能更新组件；\n\nC.然后比较其children，发现内容的文本内容不同（由a---&gt;c)，而input组件并没有变化，这时触发组件的componentWillReceiveProps方法，从而更新其子组件文本内容;\n\nD.因为组件的children中input组件没有变化，其又与父组件传入的任props没有关联，所以input组件不会更新(即其componentWillReceiveProps方法不会被执行)，导致用户输入的值不会变化。\n</code></pre></li>\n</ol>"},{"title":"React基础之 组件生命周期","date":"2018-07-08T16:00:00.000Z","_content":"![](https://raw.githubusercontent.com/shengyur/Images/master/lifecycle.jpg)\n\n<!--more-->\n### constructor\n1. 用于初始化内部状态，很少使用\n2. 唯一可以直接修改state的地方\n\n\n### getDerivedStateFromProps （react 16.3）\n1. 当state需要从props初始化时，使用\n2. **尽量不要使用，维护两者状态一致性会增加复杂度**\n3. 每次render都会调用\n运用场景：表单控件获取默认值\n\n### componentDidMount\n1. ui渲染完之后调用\n2. 只执行一次\n运用场景：获取外部资源\n\n### componentWillUnmount\n1. 组件移除时被调用\n运用场景：资源释放\n\n### getSnapshotBeforeUpdate (react 16.3）\n1. 在页面render之前调用，state已跟新\n运用场景：获取render之前的dom状态\ngetSnapshotBeforeUpdate()在最新的渲染输出提交给DOM前将会立即调用。它让你的组件能在当前的值可能要改变前获得它们。这一生命周期返回的任何值将会作为参数被传递给componentDidUpdate()。\n\n### componentDidUpdate\n1. 每次UI跟新时被调用\n运用场景：页面需要根据props变化重新获取数据\n\n### shouldComponentUpdate\n1. 决定 Virtual Dom是否要重绘\n2. 一般不需要手动调用，可以使用 PureComponent 自动实现\n运用场景：性能优化\n\n[点击查看demo](https://github.com/shengyur/react-demo-code-16.3-)\n\n\n\n\n\n\n\n原文：\n- 图片来自 http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\n- https://www.zhihu.com/question/278328905/answer/399344422\n- react生命周期 https://www.cnblogs.com/yangzhou33/p/8799278.html\n","source":"_posts/React基础之 react生命周期.md","raw":"title: React基础之 组件生命周期\ndate: 2018/07/09\ncategories: 库/框架\ntags:\n  - React\n---\n![](https://raw.githubusercontent.com/shengyur/Images/master/lifecycle.jpg)\n\n<!--more-->\n### constructor\n1. 用于初始化内部状态，很少使用\n2. 唯一可以直接修改state的地方\n\n\n### getDerivedStateFromProps （react 16.3）\n1. 当state需要从props初始化时，使用\n2. **尽量不要使用，维护两者状态一致性会增加复杂度**\n3. 每次render都会调用\n运用场景：表单控件获取默认值\n\n### componentDidMount\n1. ui渲染完之后调用\n2. 只执行一次\n运用场景：获取外部资源\n\n### componentWillUnmount\n1. 组件移除时被调用\n运用场景：资源释放\n\n### getSnapshotBeforeUpdate (react 16.3）\n1. 在页面render之前调用，state已跟新\n运用场景：获取render之前的dom状态\ngetSnapshotBeforeUpdate()在最新的渲染输出提交给DOM前将会立即调用。它让你的组件能在当前的值可能要改变前获得它们。这一生命周期返回的任何值将会作为参数被传递给componentDidUpdate()。\n\n### componentDidUpdate\n1. 每次UI跟新时被调用\n运用场景：页面需要根据props变化重新获取数据\n\n### shouldComponentUpdate\n1. 决定 Virtual Dom是否要重绘\n2. 一般不需要手动调用，可以使用 PureComponent 自动实现\n运用场景：性能优化\n\n[点击查看demo](https://github.com/shengyur/react-demo-code-16.3-)\n\n\n\n\n\n\n\n原文：\n- 图片来自 http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\n- https://www.zhihu.com/question/278328905/answer/399344422\n- react生命周期 https://www.cnblogs.com/yangzhou33/p/8799278.html\n","slug":"React基础之 react生命周期","published":1,"updated":"2018-07-18T17:05:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81ux4000t7q0t0m9wifwl","content":"<p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/lifecycle.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><ol>\n<li>用于初始化内部状态，很少使用</li>\n<li>唯一可以直接修改state的地方</li>\n</ol>\n<h3 id=\"getDerivedStateFromProps-（react-16-3）\"><a href=\"#getDerivedStateFromProps-（react-16-3）\" class=\"headerlink\" title=\"getDerivedStateFromProps （react 16.3）\"></a>getDerivedStateFromProps （react 16.3）</h3><ol>\n<li>当state需要从props初始化时，使用</li>\n<li><strong>尽量不要使用，维护两者状态一致性会增加复杂度</strong></li>\n<li>每次render都会调用<br>运用场景：表单控件获取默认值</li>\n</ol>\n<h3 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h3><ol>\n<li>ui渲染完之后调用</li>\n<li>只执行一次<br>运用场景：获取外部资源</li>\n</ol>\n<h3 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h3><ol>\n<li>组件移除时被调用<br>运用场景：资源释放</li>\n</ol>\n<h3 id=\"getSnapshotBeforeUpdate-react-16-3）\"><a href=\"#getSnapshotBeforeUpdate-react-16-3）\" class=\"headerlink\" title=\"getSnapshotBeforeUpdate (react 16.3）\"></a>getSnapshotBeforeUpdate (react 16.3）</h3><ol>\n<li>在页面render之前调用，state已跟新<br>运用场景：获取render之前的dom状态<br>getSnapshotBeforeUpdate()在最新的渲染输出提交给DOM前将会立即调用。它让你的组件能在当前的值可能要改变前获得它们。这一生命周期返回的任何值将会作为参数被传递给componentDidUpdate()。</li>\n</ol>\n<h3 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a>componentDidUpdate</h3><ol>\n<li>每次UI跟新时被调用<br>运用场景：页面需要根据props变化重新获取数据</li>\n</ol>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><ol>\n<li>决定 Virtual Dom是否要重绘</li>\n<li>一般不需要手动调用，可以使用 PureComponent 自动实现<br>运用场景：性能优化</li>\n</ol>\n<p><a href=\"https://github.com/shengyur/react-demo-code-16.3-\" target=\"_blank\" rel=\"noopener\">点击查看demo</a></p>\n<p>原文：</p>\n<ul>\n<li>图片来自 <a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" rel=\"noopener\">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></li>\n<li><a href=\"https://www.zhihu.com/question/278328905/answer/399344422\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/278328905/answer/399344422</a></li>\n<li>react生命周期 <a href=\"https://www.cnblogs.com/yangzhou33/p/8799278.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yangzhou33/p/8799278.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/lifecycle.jpg\" alt=\"\"></p>","more":"<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><ol>\n<li>用于初始化内部状态，很少使用</li>\n<li>唯一可以直接修改state的地方</li>\n</ol>\n<h3 id=\"getDerivedStateFromProps-（react-16-3）\"><a href=\"#getDerivedStateFromProps-（react-16-3）\" class=\"headerlink\" title=\"getDerivedStateFromProps （react 16.3）\"></a>getDerivedStateFromProps （react 16.3）</h3><ol>\n<li>当state需要从props初始化时，使用</li>\n<li><strong>尽量不要使用，维护两者状态一致性会增加复杂度</strong></li>\n<li>每次render都会调用<br>运用场景：表单控件获取默认值</li>\n</ol>\n<h3 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h3><ol>\n<li>ui渲染完之后调用</li>\n<li>只执行一次<br>运用场景：获取外部资源</li>\n</ol>\n<h3 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h3><ol>\n<li>组件移除时被调用<br>运用场景：资源释放</li>\n</ol>\n<h3 id=\"getSnapshotBeforeUpdate-react-16-3）\"><a href=\"#getSnapshotBeforeUpdate-react-16-3）\" class=\"headerlink\" title=\"getSnapshotBeforeUpdate (react 16.3）\"></a>getSnapshotBeforeUpdate (react 16.3）</h3><ol>\n<li>在页面render之前调用，state已跟新<br>运用场景：获取render之前的dom状态<br>getSnapshotBeforeUpdate()在最新的渲染输出提交给DOM前将会立即调用。它让你的组件能在当前的值可能要改变前获得它们。这一生命周期返回的任何值将会作为参数被传递给componentDidUpdate()。</li>\n</ol>\n<h3 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a>componentDidUpdate</h3><ol>\n<li>每次UI跟新时被调用<br>运用场景：页面需要根据props变化重新获取数据</li>\n</ol>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><ol>\n<li>决定 Virtual Dom是否要重绘</li>\n<li>一般不需要手动调用，可以使用 PureComponent 自动实现<br>运用场景：性能优化</li>\n</ol>\n<p><a href=\"https://github.com/shengyur/react-demo-code-16.3-\" target=\"_blank\" rel=\"noopener\">点击查看demo</a></p>\n<p>原文：</p>\n<ul>\n<li>图片来自 <a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" rel=\"noopener\">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></li>\n<li><a href=\"https://www.zhihu.com/question/278328905/answer/399344422\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/278328905/answer/399344422</a></li>\n<li>react生命周期 <a href=\"https://www.cnblogs.com/yangzhou33/p/8799278.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yangzhou33/p/8799278.html</a></li>\n</ul>"},{"title":"React基础之 父组件调用子组件的方法","date":"2018-06-01T16:00:00.000Z","_content":"直接上代码~~\n```\nexport default class Parent extends Component {\n     render() {\n         return(\n             <div>\n                 <Child alias={this.doSth} /><br/>\n                 <button onClick={this.click} >父组件click</button>\n             </div>\n         )\n     }\n\n     doSth = (ref) => {    //获取子组件的作用域\n         this.anything = ref\n     }\n\n     click = (e) => {\n         this.anything.myName()\n     }\n\n }\n\n class Child extends Component {\n     componentDidMount(){\n         this.props.alias(this)  //子组件中的this作为参数传入\n     }\n\n     myName = () => alert('click me ')\n\n     render() {\n         return ('我是子组件')\n     }\n }\n```\n\n简化下代码：\n```\n\nexport default class Parent extends Component {\n  render() {\n      return(\n          <div>\n              <Child alias={(ref)=>{this.anything = ref}}/><br/>\n              <button onClick={()=>{this.anything.myName()}} >父组件click</button>\n          </div>\n      )\n  }\n}\n\nclass Child extends Component {\n  componentDidMount(){\n      this.props.alias(this)\n  }\n\n  myName = () => alert('click me ')\n\n  render() {\n      return ('我是子组件')\n  }\n}\n```\n\n\n上面点击按钮,会弹出子组件的输出\n\n原文：\nhttps://blog.csdn.net/hesonggg/article/details/79373565\n","source":"_posts/React基础之 父组件如何调用子组件中的方法.md","raw":"title: React基础之 父组件调用子组件的方法\ndate: 2018/06/02\ncategories: 库/框架\ntags:\n  - React\n---\n直接上代码~~\n```\nexport default class Parent extends Component {\n     render() {\n         return(\n             <div>\n                 <Child alias={this.doSth} /><br/>\n                 <button onClick={this.click} >父组件click</button>\n             </div>\n         )\n     }\n\n     doSth = (ref) => {    //获取子组件的作用域\n         this.anything = ref\n     }\n\n     click = (e) => {\n         this.anything.myName()\n     }\n\n }\n\n class Child extends Component {\n     componentDidMount(){\n         this.props.alias(this)  //子组件中的this作为参数传入\n     }\n\n     myName = () => alert('click me ')\n\n     render() {\n         return ('我是子组件')\n     }\n }\n```\n\n简化下代码：\n```\n\nexport default class Parent extends Component {\n  render() {\n      return(\n          <div>\n              <Child alias={(ref)=>{this.anything = ref}}/><br/>\n              <button onClick={()=>{this.anything.myName()}} >父组件click</button>\n          </div>\n      )\n  }\n}\n\nclass Child extends Component {\n  componentDidMount(){\n      this.props.alias(this)\n  }\n\n  myName = () => alert('click me ')\n\n  render() {\n      return ('我是子组件')\n  }\n}\n```\n\n\n上面点击按钮,会弹出子组件的输出\n\n原文：\nhttps://blog.csdn.net/hesonggg/article/details/79373565\n","slug":"React基础之 父组件如何调用子组件中的方法","published":1,"updated":"2018-06-02T12:00:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81ux6000u7q0tjiv13yab","content":"<p>直接上代码~~<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">     render() &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span>(</span><br><span class=\"line\">             &lt;div&gt;</span><br><span class=\"line\">                 &lt;<span class=\"type\">Child</span> alias=&#123;<span class=\"keyword\">this</span>.doSth&#125; /&gt;&lt;br/&gt;</span><br><span class=\"line\">                 &lt;button onClick=&#123;<span class=\"keyword\">this</span>.click&#125; &gt;父组件click&lt;/button&gt;</span><br><span class=\"line\">             &lt;/div&gt;</span><br><span class=\"line\">         )</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     doSth = (ref) =&gt; &#123;    <span class=\"comment\">//获取子组件的作用域</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.anything = ref</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     click = (e) =&gt; &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.anything.myName()</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">     componentDidMount()&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.props.alias(<span class=\"keyword\">this</span>)  <span class=\"comment\">//子组件中的this作为参数传入</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     myName = () =&gt; alert(<span class=\"symbol\">'click</span> me ')</span><br><span class=\"line\"></span><br><span class=\"line\">     render() &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> ('我是子组件')</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>简化下代码：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>(</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">              &lt;<span class=\"type\">Child</span> alias=&#123;(ref)=&gt;&#123;<span class=\"keyword\">this</span>.anything = ref&#125;&#125;/&gt;&lt;br/&gt;</span><br><span class=\"line\">              &lt;button onClick=&#123;()=&gt;&#123;<span class=\"keyword\">this</span>.anything.myName()&#125;&#125; &gt;父组件click&lt;/button&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.alias(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  myName = () =&gt; alert(<span class=\"symbol\">'click</span> me ')</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ('我是子组件')</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面点击按钮,会弹出子组件的输出</p>\n<p>原文：<br><a href=\"https://blog.csdn.net/hesonggg/article/details/79373565\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hesonggg/article/details/79373565</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>直接上代码~~<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">     render() &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span>(</span><br><span class=\"line\">             &lt;div&gt;</span><br><span class=\"line\">                 &lt;<span class=\"type\">Child</span> alias=&#123;<span class=\"keyword\">this</span>.doSth&#125; /&gt;&lt;br/&gt;</span><br><span class=\"line\">                 &lt;button onClick=&#123;<span class=\"keyword\">this</span>.click&#125; &gt;父组件click&lt;/button&gt;</span><br><span class=\"line\">             &lt;/div&gt;</span><br><span class=\"line\">         )</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     doSth = (ref) =&gt; &#123;    <span class=\"comment\">//获取子组件的作用域</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.anything = ref</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     click = (e) =&gt; &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.anything.myName()</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">     componentDidMount()&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.props.alias(<span class=\"keyword\">this</span>)  <span class=\"comment\">//子组件中的this作为参数传入</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     myName = () =&gt; alert(<span class=\"symbol\">'click</span> me ')</span><br><span class=\"line\"></span><br><span class=\"line\">     render() &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> ('我是子组件')</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>简化下代码：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>(</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">              &lt;<span class=\"type\">Child</span> alias=&#123;(ref)=&gt;&#123;<span class=\"keyword\">this</span>.anything = ref&#125;&#125;/&gt;&lt;br/&gt;</span><br><span class=\"line\">              &lt;button onClick=&#123;()=&gt;&#123;<span class=\"keyword\">this</span>.anything.myName()&#125;&#125; &gt;父组件click&lt;/button&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.alias(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  myName = () =&gt; alert(<span class=\"symbol\">'click</span> me ')</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ('我是子组件')</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面点击按钮,会弹出子组件的输出</p>\n<p>原文：<br><a href=\"https://blog.csdn.net/hesonggg/article/details/79373565\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hesonggg/article/details/79373565</a></p>\n"},{"title":"React基础之 使用排坑指南","date":"2018-07-12T16:00:00.000Z","toc":true,"_content":"\n### state(状态) 更新可能是异步的\n\nReact 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。\n\n**因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。**\n\n例如, 以下代码可能导致 counter(计数器)更新失败：\n```\n// 错误\nthis.setState({\n  counter: this.state.counter + this.props.increment,\n});\n```\n要弥补这个问题，需要使用另一种 setState() 的形式，**它接受一个函数,而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数：**\n```\n// 正确\nthis.setState((prevState, props) => ({\n  //prevState:更新之前的状态state值\n  //props:更新之前的props\n  counter: prevState.counter + props.increment\n}));\n```\n我们在上面使用了一个箭头函数，但是也可以使用一个常规的函数：\n```\n// 正确\nthis.setState(function(prevState, props) {\n  return {\n    counter: prevState.counter + props.increment\n  };\n});\n```\n\n### Props 是只读的,声明组件的函数必须是纯函数\n\n无论你用函数或类的方法来声明组件, 它都无法修改其自身 props. 思考下列 sum (求和)函数:\n```\nfunction sum(a, b) {\n  return a + b;\n}\n```\n这种函数称为 **“纯函数”** ，因为它们不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。\n反之， 以下是非纯函数， 因为它改变了自身的输入值：\n```\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n所有 React 组件都必须是纯函数，并禁止修改其自身 props 。\n\n### 单向数据流(数据向下流动）\n\nstate(状态)经常被称为 本地状态 或 封装状态，是因为它不能 被拥有并设置它的组件以外的任何组件 访问。\n一个组件可以选择将state向下传递，作为其子组件的props属性：\n```\n<h2>it is {this.state.date.toLocalTimeString()}</h2>\n```\n同样适用于用户定义组件：\n```\n<Formatte date={this.state.date}>\n```\nFormatte组件通过props属性接受了date的值，但它仍任然不能获知该值是来自于哪。\n\n这通常称为\"从上而下\"，或者单项数据流。任何state始终由某个特定组件所有，并且从该state导出的任何数据 或 UI只能影响树种 \"下方\"的组件。\n\n### Refs\n\nReact支持一个可以附加到任何组件的特殊属性ref。ref属性可以是一个字符串或一个回调函数。\n当ref属性是一个回调函数时，函数接收底层DOM元素或类实例（取决于元素的类型）作为参数。这使你可以直接访问DOM元素或组件实例。\n\n### 理解JSX\n直接在js代码中书写html标记，JSX的本质就是动态创建组件的语法糖\n```\nconst name= 'shengyu';\nconst element = <h1>hello,{name}</h1>;\n```\n也可以表示为\n```\nconst name='shengyu';\nconst element = React.createElement(\n  'h1', //标签名\n  null, //属性\n  'hello,', //内容\n  name //内容\n  );\n```\n优点：无需多学习一门模板语言，用js就可以动态创建UI\n\n核心概念：在JSX中使用表达式\n\n1. JSX本身也是表达式\n```\nconst ele=<h1>Hello,world!</h1>;\n```\n\n2. 在属性中使用表达式\n```\n<MyCompnonent yee={1+2+3+5} >\n```\n\n3. 延展属性\n```\nconst props = {firstName:'Ben',lastName:'Hector'};\nconst greeting =<Greeting {...props} >\n```\n解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值(数组，对象，函数)，那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n```\nlet obj = {a:{b:1}}\nlet {...x} = obj;\nobj.a.b = 2;\nx.a.b // 2;\n```\n4. 表达式作为子元素\n```\nconst ele=<li>{props.xxx}</li>\n```\n\n\n### React生命周期 以及使用场景\nhttps://www.cnblogs.com/yangzhou33/p/8799278.html\n\n\n### 项目经验\n\n1. 以组件方式考虑UI的构建\n\n2. 理解React状态机 （props + state ==> view ）\n  - React组件一般不提供方法，而是某种状态机\n  - React组件可以理解为一个纯函数\n  - 单项数据绑定\n\n3. 创建组件的步骤\n  - 创建静态ui\n  - 考虑组件的状态组成\n  - 考虑组件的交互方式\n\n4. 受控组件 vs 非受控组件\n  受控组件：表单元素的状态由使用者维护\n  非受控组件：表单元素状态DOM自身维护\n\n5. 如何创建组件？\n- 单一责任原则\n  1.每个组件只做一件事\n  2.如果组件变的复杂，那么应该拆分成小组件\n\n6. 数据状态管理:DRY（Don't repeat yourself）原则\n  1.能计算得到的状态就不要单独存储\n  2.组件尽量无状态，所需数据通过props获取\n\n\n\n\n### 实际开发中遇到的问题\n\n1. render()里面只能return一个JSX，\n\n   因此在使用数组的.map()方法时，每次循环都要return一个JSX。\n\n2. 在使用数组的.map()方法时，建议使用ES6的箭头函数，避免出现this指向的问题。\n```\n\t\toneArray.map((item,index)=>{\n\t\t\treturn (\n\t\t\t\t<a onClick={this.play.bind(this)}>test</a>\n\t\t\t)\n\t\t})\n```\n3. 在写一个onClick的时候，如果这个function中没有用到this.state或者this.props时，\n\n\t建议不要使用this.test.bind(this)这种形式的写法，因为都要重新渲染组件，影响性能。\n\n\t常用的几种写法有:\n```\n\t\t(1)没有入参时\n\t\t\tonClick={this.test}\n\n\t\t(2)有入参时\n\t\t\tonClick={this.test('1')}\n\n\t\t(3)语句很少时\n\t\t\tonClick={() => this.state.triggle = !this.state.triggle}\n```\n4. 父组件调用子组件的方法：\n\t[父组件调用子组件的方法](https://shengyur.github.io/2018/06/02/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/)\n\n5. es6中，寻找数组中是否包含某个元素，\n  ```\n  \tlet arr = [1,2,3,-5]\n  \tarr.find((n) => n<0)  //-5\n  \tarr.findIndex((n) => n<0)  //3\n  ```\n\t注意:indexOf方法无法识别数组的NaN成员，但是findIndex可以通过Object.is方法做到。\n  ```\n\t  [NaN].findIndex(y => Object.is(NaN,y))\n  ```\n6. 使用this.forceUpdate()来更新当前组件的render()方法。\n\n7. 如果两个兄弟组件A和B，A想调用B组件的方法，必须通过两兄弟的父组件C来调用。\n\n\n8. 将一个形如\"a:b:c\"的字符串转换成数组，其中a、b、c为整型，转换后的数组内也是整数。\n```\n  Array.from(\"1:3:5\".split(\":\"),(value) => Number(value))\n```\n9. 代码优化：\n```\n  let {store,onChange,disabled} = this.props;\n  相当于\n  let store = this.props.store;\n  let onChange = this.props.onChange;\n  let disabled = this.props.disabled;\n```\n10. 回调方法：\n```\n  callback && typeof (callback) == 'function' && callback();\n```\n11. render中的双重循环：\n```\n  <Form.Item label=\"出游人群\" labelWidth=\"120px\">\n    {   \n      tabAttrObj.touristType.length ?\n        this.touristTypeList.map((allType,key) => {\n          return(\n            tabAttrObj.touristType.map((type, index) => {\n              return <div>111</div>\n            })\n          )                                     \n        })\n      :''\n    }\n  </Form.Item>\n```\n12. 传入子组件的代码优化：\n```\n  <CollectMethod {...this.props}  />\n  相当于\n  <AddInput store={this.props.store}\n              basicListIndex={this.props.basicListIndex}\n              tabAttrObj={this.props.tabAttrObj}\n  />\n```\n13. class 的取值函数（getter）和存值函数（setter）\n```\n  class MyClass {\n    constructor() {\n      // ...\n    }\n    get prop() {\n      return 'getter';\n    }\n    set prop(value) {\n      console.log('setter: '+value);\n    }\n\n    render(){\n      return <div>{this.prop}</div>\n    }\n  }\n```\n14. 复制数组，修改a2的值，并不会影响a1的值。\n```\n  const a1 = [1, 2];\n  const a2 = [...a1];\n```\n\n参考：\n- [React中文文档](http://www.css88.com/react/docs/handling-events.html)\n- [王老师的积累](https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.md)\n","source":"_posts/React基础之 排坑日常.md","raw":"title: React基础之 使用排坑指南\ndate: 2018/07/13\ncategories:\n  - 库/框架\ntoc: true\ntags:\n  - React\n---\n\n### state(状态) 更新可能是异步的\n\nReact 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。\n\n**因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。**\n\n例如, 以下代码可能导致 counter(计数器)更新失败：\n```\n// 错误\nthis.setState({\n  counter: this.state.counter + this.props.increment,\n});\n```\n要弥补这个问题，需要使用另一种 setState() 的形式，**它接受一个函数,而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数：**\n```\n// 正确\nthis.setState((prevState, props) => ({\n  //prevState:更新之前的状态state值\n  //props:更新之前的props\n  counter: prevState.counter + props.increment\n}));\n```\n我们在上面使用了一个箭头函数，但是也可以使用一个常规的函数：\n```\n// 正确\nthis.setState(function(prevState, props) {\n  return {\n    counter: prevState.counter + props.increment\n  };\n});\n```\n\n### Props 是只读的,声明组件的函数必须是纯函数\n\n无论你用函数或类的方法来声明组件, 它都无法修改其自身 props. 思考下列 sum (求和)函数:\n```\nfunction sum(a, b) {\n  return a + b;\n}\n```\n这种函数称为 **“纯函数”** ，因为它们不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。\n反之， 以下是非纯函数， 因为它改变了自身的输入值：\n```\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n所有 React 组件都必须是纯函数，并禁止修改其自身 props 。\n\n### 单向数据流(数据向下流动）\n\nstate(状态)经常被称为 本地状态 或 封装状态，是因为它不能 被拥有并设置它的组件以外的任何组件 访问。\n一个组件可以选择将state向下传递，作为其子组件的props属性：\n```\n<h2>it is {this.state.date.toLocalTimeString()}</h2>\n```\n同样适用于用户定义组件：\n```\n<Formatte date={this.state.date}>\n```\nFormatte组件通过props属性接受了date的值，但它仍任然不能获知该值是来自于哪。\n\n这通常称为\"从上而下\"，或者单项数据流。任何state始终由某个特定组件所有，并且从该state导出的任何数据 或 UI只能影响树种 \"下方\"的组件。\n\n### Refs\n\nReact支持一个可以附加到任何组件的特殊属性ref。ref属性可以是一个字符串或一个回调函数。\n当ref属性是一个回调函数时，函数接收底层DOM元素或类实例（取决于元素的类型）作为参数。这使你可以直接访问DOM元素或组件实例。\n\n### 理解JSX\n直接在js代码中书写html标记，JSX的本质就是动态创建组件的语法糖\n```\nconst name= 'shengyu';\nconst element = <h1>hello,{name}</h1>;\n```\n也可以表示为\n```\nconst name='shengyu';\nconst element = React.createElement(\n  'h1', //标签名\n  null, //属性\n  'hello,', //内容\n  name //内容\n  );\n```\n优点：无需多学习一门模板语言，用js就可以动态创建UI\n\n核心概念：在JSX中使用表达式\n\n1. JSX本身也是表达式\n```\nconst ele=<h1>Hello,world!</h1>;\n```\n\n2. 在属性中使用表达式\n```\n<MyCompnonent yee={1+2+3+5} >\n```\n\n3. 延展属性\n```\nconst props = {firstName:'Ben',lastName:'Hector'};\nconst greeting =<Greeting {...props} >\n```\n解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值(数组，对象，函数)，那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n```\nlet obj = {a:{b:1}}\nlet {...x} = obj;\nobj.a.b = 2;\nx.a.b // 2;\n```\n4. 表达式作为子元素\n```\nconst ele=<li>{props.xxx}</li>\n```\n\n\n### React生命周期 以及使用场景\nhttps://www.cnblogs.com/yangzhou33/p/8799278.html\n\n\n### 项目经验\n\n1. 以组件方式考虑UI的构建\n\n2. 理解React状态机 （props + state ==> view ）\n  - React组件一般不提供方法，而是某种状态机\n  - React组件可以理解为一个纯函数\n  - 单项数据绑定\n\n3. 创建组件的步骤\n  - 创建静态ui\n  - 考虑组件的状态组成\n  - 考虑组件的交互方式\n\n4. 受控组件 vs 非受控组件\n  受控组件：表单元素的状态由使用者维护\n  非受控组件：表单元素状态DOM自身维护\n\n5. 如何创建组件？\n- 单一责任原则\n  1.每个组件只做一件事\n  2.如果组件变的复杂，那么应该拆分成小组件\n\n6. 数据状态管理:DRY（Don't repeat yourself）原则\n  1.能计算得到的状态就不要单独存储\n  2.组件尽量无状态，所需数据通过props获取\n\n\n\n\n### 实际开发中遇到的问题\n\n1. render()里面只能return一个JSX，\n\n   因此在使用数组的.map()方法时，每次循环都要return一个JSX。\n\n2. 在使用数组的.map()方法时，建议使用ES6的箭头函数，避免出现this指向的问题。\n```\n\t\toneArray.map((item,index)=>{\n\t\t\treturn (\n\t\t\t\t<a onClick={this.play.bind(this)}>test</a>\n\t\t\t)\n\t\t})\n```\n3. 在写一个onClick的时候，如果这个function中没有用到this.state或者this.props时，\n\n\t建议不要使用this.test.bind(this)这种形式的写法，因为都要重新渲染组件，影响性能。\n\n\t常用的几种写法有:\n```\n\t\t(1)没有入参时\n\t\t\tonClick={this.test}\n\n\t\t(2)有入参时\n\t\t\tonClick={this.test('1')}\n\n\t\t(3)语句很少时\n\t\t\tonClick={() => this.state.triggle = !this.state.triggle}\n```\n4. 父组件调用子组件的方法：\n\t[父组件调用子组件的方法](https://shengyur.github.io/2018/06/02/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/)\n\n5. es6中，寻找数组中是否包含某个元素，\n  ```\n  \tlet arr = [1,2,3,-5]\n  \tarr.find((n) => n<0)  //-5\n  \tarr.findIndex((n) => n<0)  //3\n  ```\n\t注意:indexOf方法无法识别数组的NaN成员，但是findIndex可以通过Object.is方法做到。\n  ```\n\t  [NaN].findIndex(y => Object.is(NaN,y))\n  ```\n6. 使用this.forceUpdate()来更新当前组件的render()方法。\n\n7. 如果两个兄弟组件A和B，A想调用B组件的方法，必须通过两兄弟的父组件C来调用。\n\n\n8. 将一个形如\"a:b:c\"的字符串转换成数组，其中a、b、c为整型，转换后的数组内也是整数。\n```\n  Array.from(\"1:3:5\".split(\":\"),(value) => Number(value))\n```\n9. 代码优化：\n```\n  let {store,onChange,disabled} = this.props;\n  相当于\n  let store = this.props.store;\n  let onChange = this.props.onChange;\n  let disabled = this.props.disabled;\n```\n10. 回调方法：\n```\n  callback && typeof (callback) == 'function' && callback();\n```\n11. render中的双重循环：\n```\n  <Form.Item label=\"出游人群\" labelWidth=\"120px\">\n    {   \n      tabAttrObj.touristType.length ?\n        this.touristTypeList.map((allType,key) => {\n          return(\n            tabAttrObj.touristType.map((type, index) => {\n              return <div>111</div>\n            })\n          )                                     \n        })\n      :''\n    }\n  </Form.Item>\n```\n12. 传入子组件的代码优化：\n```\n  <CollectMethod {...this.props}  />\n  相当于\n  <AddInput store={this.props.store}\n              basicListIndex={this.props.basicListIndex}\n              tabAttrObj={this.props.tabAttrObj}\n  />\n```\n13. class 的取值函数（getter）和存值函数（setter）\n```\n  class MyClass {\n    constructor() {\n      // ...\n    }\n    get prop() {\n      return 'getter';\n    }\n    set prop(value) {\n      console.log('setter: '+value);\n    }\n\n    render(){\n      return <div>{this.prop}</div>\n    }\n  }\n```\n14. 复制数组，修改a2的值，并不会影响a1的值。\n```\n  const a1 = [1, 2];\n  const a2 = [...a1];\n```\n\n参考：\n- [React中文文档](http://www.css88.com/react/docs/handling-events.html)\n- [王老师的积累](https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.md)\n","slug":"React基础之 排坑日常","published":1,"updated":"2018-07-14T02:07:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81ux8000x7q0tajp0z6jz","content":"<h3 id=\"state-状态-更新可能是异步的\"><a href=\"#state-状态-更新可能是异步的\" class=\"headerlink\" title=\"state(状态) 更新可能是异步的\"></a>state(状态) 更新可能是异步的</h3><p>React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。</p>\n<p><strong>因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。</strong></p>\n<p>例如, 以下代码可能导致 counter(计数器)更新失败：<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">  counter: <span class=\"keyword\">this</span>.state.counter + <span class=\"keyword\">this</span>.props.increment,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>要弥补这个问题，需要使用另一种 setState() 的形式，<strong>它接受一个函数,而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(<span class=\"function\">(<span class=\"params\">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"comment\">//prevState:更新之前的状态state值</span></span><br><span class=\"line\">  <span class=\"comment\">//props:更新之前的props</span></span><br><span class=\"line\">  counter: prevState.counter + props.increment</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>我们在上面使用了一个箭头函数，但是也可以使用一个常规的函数：<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(prevState, props)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: prevState.counter + props.increment</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Props-是只读的-声明组件的函数必须是纯函数\"><a href=\"#Props-是只读的-声明组件的函数必须是纯函数\" class=\"headerlink\" title=\"Props 是只读的,声明组件的函数必须是纯函数\"></a>Props 是只读的,声明组件的函数必须是纯函数</h3><p>无论你用函数或类的方法来声明组件, 它都无法修改其自身 props. 思考下列 sum (求和)函数:<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(a, b) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">a</span> + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种函数称为 <strong>“纯函数”</strong> ，因为它们不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。<br>反之， 以下是非纯函数， 因为它改变了自身的输入值：<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span><span class=\"params\">(account, amount)</span> </span>&#123;</span><br><span class=\"line\">  account.total -= amount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所有 React 组件都必须是纯函数，并禁止修改其自身 props 。</p>\n<h3 id=\"单向数据流-数据向下流动）\"><a href=\"#单向数据流-数据向下流动）\" class=\"headerlink\" title=\"单向数据流(数据向下流动）\"></a>单向数据流(数据向下流动）</h3><p>state(状态)经常被称为 本地状态 或 封装状态，是因为它不能 被拥有并设置它的组件以外的任何组件 访问。<br>一个组件可以选择将state向下传递，作为其子组件的props属性：<br><figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">&lt;h2&gt;</span>it is &#123;this.<span class=\"keyword\">state</span>.date.<span class=\"keyword\">to</span>LocalTimeString()&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure></p>\n<p>同样适用于用户定义组件：<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Formatte <span class=\"keyword\">date</span>=&#123;<span class=\"keyword\">this</span>.state.<span class=\"keyword\">date</span>&#125;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>Formatte组件通过props属性接受了date的值，但它仍任然不能获知该值是来自于哪。</p>\n<p>这通常称为”从上而下”，或者单项数据流。任何state始终由某个特定组件所有，并且从该state导出的任何数据 或 UI只能影响树种 “下方”的组件。</p>\n<h3 id=\"Refs\"><a href=\"#Refs\" class=\"headerlink\" title=\"Refs\"></a>Refs</h3><p>React支持一个可以附加到任何组件的特殊属性ref。ref属性可以是一个字符串或一个回调函数。<br>当ref属性是一个回调函数时，函数接收底层DOM元素或类实例（取决于元素的类型）作为参数。这使你可以直接访问DOM元素或组件实例。</p>\n<h3 id=\"理解JSX\"><a href=\"#理解JSX\" class=\"headerlink\" title=\"理解JSX\"></a>理解JSX</h3><p>直接在js代码中书写html标记，JSX的本质就是动态创建组件的语法糖<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name= <span class=\"string\">'shengyu'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello,&#123;name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>也可以表示为<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">name</span>=<span class=\"string\">'shengyu'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">'h1'</span>, <span class=\"comment\">//标签名</span></span><br><span class=\"line\">  null, <span class=\"comment\">//属性</span></span><br><span class=\"line\">  <span class=\"string\">'hello,'</span>, <span class=\"comment\">//内容</span></span><br><span class=\"line\">  <span class=\"keyword\">name</span> <span class=\"comment\">//内容</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure></p>\n<p>优点：无需多学习一门模板语言，用js就可以动态创建UI</p>\n<p>核心概念：在JSX中使用表达式</p>\n<ol>\n<li><p>JSX本身也是表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ele=<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello,world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在属性中使用表达式</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MyCompnonent yee=&#123;<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">5</span>&#125; &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>延展属性</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">const props</span> = &#123;firstName:<span class=\"string\">'Ben'</span>,lastName:<span class=\"string\">'Hector'</span>&#125;;</span><br><span class=\"line\"><span class=\"attribute\">const greeting</span> =&lt;Greeting &#123;...props&#125; &gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值(数组，对象，函数)，那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;a:&#123;b:<span class=\"number\">1</span>&#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;...x&#125; = obj;</span><br><span class=\"line\">obj.a.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">x.a.b // <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"4\">\n<li>表达式作为子元素<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ele=<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;props.xxx&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"React生命周期-以及使用场景\"><a href=\"#React生命周期-以及使用场景\" class=\"headerlink\" title=\"React生命周期 以及使用场景\"></a>React生命周期 以及使用场景</h3><p><a href=\"https://www.cnblogs.com/yangzhou33/p/8799278.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yangzhou33/p/8799278.html</a></p>\n<h3 id=\"项目经验\"><a href=\"#项目经验\" class=\"headerlink\" title=\"项目经验\"></a>项目经验</h3><ol>\n<li><p>以组件方式考虑UI的构建</p>\n</li>\n<li><p>理解React状态机 （props + state ==&gt; view ）</p>\n<ul>\n<li>React组件一般不提供方法，而是某种状态机</li>\n<li>React组件可以理解为一个纯函数</li>\n<li>单项数据绑定</li>\n</ul>\n</li>\n<li><p>创建组件的步骤</p>\n<ul>\n<li>创建静态ui</li>\n<li>考虑组件的状态组成</li>\n<li>考虑组件的交互方式</li>\n</ul>\n</li>\n<li><p>受控组件 vs 非受控组件<br>受控组件：表单元素的状态由使用者维护<br>非受控组件：表单元素状态DOM自身维护</p>\n</li>\n<li><p>如何创建组件？</p>\n</li>\n</ol>\n<ul>\n<li>单一责任原则<br>1.每个组件只做一件事<br>2.如果组件变的复杂，那么应该拆分成小组件</li>\n</ul>\n<ol start=\"6\">\n<li>数据状态管理:DRY（Don’t repeat yourself）原则<br>1.能计算得到的状态就不要单独存储<br>2.组件尽量无状态，所需数据通过props获取</li>\n</ol>\n<h3 id=\"实际开发中遇到的问题\"><a href=\"#实际开发中遇到的问题\" class=\"headerlink\" title=\"实际开发中遇到的问题\"></a>实际开发中遇到的问题</h3><ol>\n<li><p>render()里面只能return一个JSX，</p>\n<p>因此在使用数组的.map()方法时，每次循环都要return一个JSX。</p>\n</li>\n<li><p>在使用数组的.map()方法时，建议使用ES6的箭头函数，避免出现this指向的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oneArray.map(<span class=\"function\">(<span class=\"params\">item,index</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t&lt;a onClick=&#123;<span class=\"keyword\">this</span>.play.bind(<span class=\"keyword\">this</span>)&#125;&gt;test&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t)</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在写一个onClick的时候，如果这个function中没有用到this.state或者this.props时，</p>\n<p> 建议不要使用this.test.bind(this)这种形式的写法，因为都要重新渲染组件，影响性能。</p>\n<p> 常用的几种写法有:</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)没有入参时</span><br><span class=\"line\">\t<span class=\"keyword\">on</span>Click=&#123;this.test&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">2</span>)有入参时</span><br><span class=\"line\">\t<span class=\"keyword\">on</span>Click=&#123;this.test('<span class=\"number\">1</span>')&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">3</span>)语句很少时</span><br><span class=\"line\">\t<span class=\"keyword\">on</span>Click=&#123;() =&gt; this.<span class=\"keyword\">state</span>.triggle = !this.<span class=\"keyword\">state</span>.triggle&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>父组件调用子组件的方法：<br> <a href=\"https://shengyur.github.io/2018/06/02/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">父组件调用子组件的方法</a></p>\n</li>\n<li><p>es6中，寻找数组中是否包含某个元素，</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">-5</span>]</span><br><span class=\"line\">arr.find((n) =&gt; n&lt;<span class=\"number\">0</span>)  <span class=\"comment\">//-5</span></span><br><span class=\"line\">arr.findIndex((n) =&gt; n&lt;<span class=\"number\">0</span>)  <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<p> 注意:indexOf方法无法识别数组的NaN成员，但是findIndex可以通过Object.is方法做到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"literal\">NaN</span>].findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>,y))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用this.forceUpdate()来更新当前组件的render()方法。</p>\n</li>\n<li><p>如果两个兄弟组件A和B，A想调用B组件的方法，必须通过两兄弟的父组件C来调用。</p>\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>将一个形如”a:b:c”的字符串转换成数组，其中a、b、c为整型，转换后的数组内也是整数。</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.<span class=\"keyword\">from</span>(<span class=\"string\">\"1:3:5\"</span>.split(<span class=\"string\">\":\"</span>),<span class=\"function\"><span class=\"params\">(value)</span> =&gt;</span> Number(value))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码优化：</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;store,onChange,disabled&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">相当于</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = <span class=\"keyword\">this</span>.props.store;</span><br><span class=\"line\"><span class=\"keyword\">let</span> onChange = <span class=\"keyword\">this</span>.props.onChange;</span><br><span class=\"line\"><span class=\"keyword\">let</span> disabled = <span class=\"keyword\">this</span>.props.disabled;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>回调方法：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">callback</span> &amp;&amp; typeof (callback) == 'function' &amp;&amp; callback();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>render中的双重循环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Form.Item label=<span class=\"string\">\"出游人群\"</span> labelWidth=<span class=\"string\">\"120px\"</span>&gt;</span><br><span class=\"line\">  &#123;   </span><br><span class=\"line\">    tabAttrObj.touristType.length ?</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.touristTypeList.map(<span class=\"function\">(<span class=\"params\">allType,key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(</span><br><span class=\"line\">          tabAttrObj.touristType.map(<span class=\"function\">(<span class=\"params\">type, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>111<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )                                     </span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    :<span class=\"string\">''</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Form.Item&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传入子组件的代码优化：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CollectMethod &#123;..<span class=\"selector-class\">.this</span><span class=\"selector-class\">.props</span>&#125;  /&gt;</span><br><span class=\"line\">相当于</span><br><span class=\"line\">&lt;AddInput store=&#123;this<span class=\"selector-class\">.props</span><span class=\"selector-class\">.store</span>&#125;</span><br><span class=\"line\">            basicListIndex=&#123;this<span class=\"selector-class\">.props</span><span class=\"selector-class\">.basicListIndex</span>&#125;</span><br><span class=\"line\">            tabAttrObj=&#123;this<span class=\"selector-class\">.props</span><span class=\"selector-class\">.tabAttrObj</span>&#125;</span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>class 的取值函数（getter）和存值函数（setter）</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">get</span> <span class=\"title\">prop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">set</span> <span class=\"title\">prop</span>(<span class=\"params\"><span class=\"keyword\">value</span></span>) </span>&#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'setter: '</span>+<span class=\"keyword\">value</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;&#123;<span class=\"keyword\">this</span>.prop&#125;&lt;/div&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>复制数组，修改a2的值，并不会影响a1的值。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"built_in\">a1</span> = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]<span class=\"comment\">;</span></span><br><span class=\"line\">const <span class=\"built_in\">a2</span> = [...a1]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.css88.com/react/docs/handling-events.html\" target=\"_blank\" rel=\"noopener\">React中文文档</a></li>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.md\" target=\"_blank\" rel=\"noopener\">王老师的积累</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"state-状态-更新可能是异步的\"><a href=\"#state-状态-更新可能是异步的\" class=\"headerlink\" title=\"state(状态) 更新可能是异步的\"></a>state(状态) 更新可能是异步的</h3><p>React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。</p>\n<p><strong>因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。</strong></p>\n<p>例如, 以下代码可能导致 counter(计数器)更新失败：<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">  counter: <span class=\"keyword\">this</span>.state.counter + <span class=\"keyword\">this</span>.props.increment,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>要弥补这个问题，需要使用另一种 setState() 的形式，<strong>它接受一个函数,而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(<span class=\"function\">(<span class=\"params\">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"comment\">//prevState:更新之前的状态state值</span></span><br><span class=\"line\">  <span class=\"comment\">//props:更新之前的props</span></span><br><span class=\"line\">  counter: prevState.counter + props.increment</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>我们在上面使用了一个箭头函数，但是也可以使用一个常规的函数：<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(prevState, props)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: prevState.counter + props.increment</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Props-是只读的-声明组件的函数必须是纯函数\"><a href=\"#Props-是只读的-声明组件的函数必须是纯函数\" class=\"headerlink\" title=\"Props 是只读的,声明组件的函数必须是纯函数\"></a>Props 是只读的,声明组件的函数必须是纯函数</h3><p>无论你用函数或类的方法来声明组件, 它都无法修改其自身 props. 思考下列 sum (求和)函数:<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(a, b) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">a</span> + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种函数称为 <strong>“纯函数”</strong> ，因为它们不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。<br>反之， 以下是非纯函数， 因为它改变了自身的输入值：<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span><span class=\"params\">(account, amount)</span> </span>&#123;</span><br><span class=\"line\">  account.total -= amount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所有 React 组件都必须是纯函数，并禁止修改其自身 props 。</p>\n<h3 id=\"单向数据流-数据向下流动）\"><a href=\"#单向数据流-数据向下流动）\" class=\"headerlink\" title=\"单向数据流(数据向下流动）\"></a>单向数据流(数据向下流动）</h3><p>state(状态)经常被称为 本地状态 或 封装状态，是因为它不能 被拥有并设置它的组件以外的任何组件 访问。<br>一个组件可以选择将state向下传递，作为其子组件的props属性：<br><figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">&lt;h2&gt;</span>it is &#123;this.<span class=\"keyword\">state</span>.date.<span class=\"keyword\">to</span>LocalTimeString()&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure></p>\n<p>同样适用于用户定义组件：<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Formatte <span class=\"keyword\">date</span>=&#123;<span class=\"keyword\">this</span>.state.<span class=\"keyword\">date</span>&#125;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>Formatte组件通过props属性接受了date的值，但它仍任然不能获知该值是来自于哪。</p>\n<p>这通常称为”从上而下”，或者单项数据流。任何state始终由某个特定组件所有，并且从该state导出的任何数据 或 UI只能影响树种 “下方”的组件。</p>\n<h3 id=\"Refs\"><a href=\"#Refs\" class=\"headerlink\" title=\"Refs\"></a>Refs</h3><p>React支持一个可以附加到任何组件的特殊属性ref。ref属性可以是一个字符串或一个回调函数。<br>当ref属性是一个回调函数时，函数接收底层DOM元素或类实例（取决于元素的类型）作为参数。这使你可以直接访问DOM元素或组件实例。</p>\n<h3 id=\"理解JSX\"><a href=\"#理解JSX\" class=\"headerlink\" title=\"理解JSX\"></a>理解JSX</h3><p>直接在js代码中书写html标记，JSX的本质就是动态创建组件的语法糖<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name= <span class=\"string\">'shengyu'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello,&#123;name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>也可以表示为<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">name</span>=<span class=\"string\">'shengyu'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">'h1'</span>, <span class=\"comment\">//标签名</span></span><br><span class=\"line\">  null, <span class=\"comment\">//属性</span></span><br><span class=\"line\">  <span class=\"string\">'hello,'</span>, <span class=\"comment\">//内容</span></span><br><span class=\"line\">  <span class=\"keyword\">name</span> <span class=\"comment\">//内容</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure></p>\n<p>优点：无需多学习一门模板语言，用js就可以动态创建UI</p>\n<p>核心概念：在JSX中使用表达式</p>\n<ol>\n<li><p>JSX本身也是表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ele=<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello,world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在属性中使用表达式</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MyCompnonent yee=&#123;<span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">5</span>&#125; &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>延展属性</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">const props</span> = &#123;firstName:<span class=\"string\">'Ben'</span>,lastName:<span class=\"string\">'Hector'</span>&#125;;</span><br><span class=\"line\"><span class=\"attribute\">const greeting</span> =&lt;Greeting &#123;...props&#125; &gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值(数组，对象，函数)，那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;a:&#123;b:<span class=\"number\">1</span>&#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;...x&#125; = obj;</span><br><span class=\"line\">obj.a.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">x.a.b // <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"4\">\n<li>表达式作为子元素<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ele=<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;props.xxx&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"React生命周期-以及使用场景\"><a href=\"#React生命周期-以及使用场景\" class=\"headerlink\" title=\"React生命周期 以及使用场景\"></a>React生命周期 以及使用场景</h3><p><a href=\"https://www.cnblogs.com/yangzhou33/p/8799278.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yangzhou33/p/8799278.html</a></p>\n<h3 id=\"项目经验\"><a href=\"#项目经验\" class=\"headerlink\" title=\"项目经验\"></a>项目经验</h3><ol>\n<li><p>以组件方式考虑UI的构建</p>\n</li>\n<li><p>理解React状态机 （props + state ==&gt; view ）</p>\n<ul>\n<li>React组件一般不提供方法，而是某种状态机</li>\n<li>React组件可以理解为一个纯函数</li>\n<li>单项数据绑定</li>\n</ul>\n</li>\n<li><p>创建组件的步骤</p>\n<ul>\n<li>创建静态ui</li>\n<li>考虑组件的状态组成</li>\n<li>考虑组件的交互方式</li>\n</ul>\n</li>\n<li><p>受控组件 vs 非受控组件<br>受控组件：表单元素的状态由使用者维护<br>非受控组件：表单元素状态DOM自身维护</p>\n</li>\n<li><p>如何创建组件？</p>\n</li>\n</ol>\n<ul>\n<li>单一责任原则<br>1.每个组件只做一件事<br>2.如果组件变的复杂，那么应该拆分成小组件</li>\n</ul>\n<ol start=\"6\">\n<li>数据状态管理:DRY（Don’t repeat yourself）原则<br>1.能计算得到的状态就不要单独存储<br>2.组件尽量无状态，所需数据通过props获取</li>\n</ol>\n<h3 id=\"实际开发中遇到的问题\"><a href=\"#实际开发中遇到的问题\" class=\"headerlink\" title=\"实际开发中遇到的问题\"></a>实际开发中遇到的问题</h3><ol>\n<li><p>render()里面只能return一个JSX，</p>\n<p>因此在使用数组的.map()方法时，每次循环都要return一个JSX。</p>\n</li>\n<li><p>在使用数组的.map()方法时，建议使用ES6的箭头函数，避免出现this指向的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oneArray.map(<span class=\"function\">(<span class=\"params\">item,index</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t&lt;a onClick=&#123;<span class=\"keyword\">this</span>.play.bind(<span class=\"keyword\">this</span>)&#125;&gt;test&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t)</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在写一个onClick的时候，如果这个function中没有用到this.state或者this.props时，</p>\n<p> 建议不要使用this.test.bind(this)这种形式的写法，因为都要重新渲染组件，影响性能。</p>\n<p> 常用的几种写法有:</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)没有入参时</span><br><span class=\"line\">\t<span class=\"keyword\">on</span>Click=&#123;this.test&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">2</span>)有入参时</span><br><span class=\"line\">\t<span class=\"keyword\">on</span>Click=&#123;this.test('<span class=\"number\">1</span>')&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">3</span>)语句很少时</span><br><span class=\"line\">\t<span class=\"keyword\">on</span>Click=&#123;() =&gt; this.<span class=\"keyword\">state</span>.triggle = !this.<span class=\"keyword\">state</span>.triggle&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>父组件调用子组件的方法：<br> <a href=\"https://shengyur.github.io/2018/06/02/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">父组件调用子组件的方法</a></p>\n</li>\n<li><p>es6中，寻找数组中是否包含某个元素，</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">-5</span>]</span><br><span class=\"line\">arr.find((n) =&gt; n&lt;<span class=\"number\">0</span>)  <span class=\"comment\">//-5</span></span><br><span class=\"line\">arr.findIndex((n) =&gt; n&lt;<span class=\"number\">0</span>)  <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<p> 注意:indexOf方法无法识别数组的NaN成员，但是findIndex可以通过Object.is方法做到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"literal\">NaN</span>].findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>,y))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用this.forceUpdate()来更新当前组件的render()方法。</p>\n</li>\n<li><p>如果两个兄弟组件A和B，A想调用B组件的方法，必须通过两兄弟的父组件C来调用。</p>\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>将一个形如”a:b:c”的字符串转换成数组，其中a、b、c为整型，转换后的数组内也是整数。</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.<span class=\"keyword\">from</span>(<span class=\"string\">\"1:3:5\"</span>.split(<span class=\"string\">\":\"</span>),<span class=\"function\"><span class=\"params\">(value)</span> =&gt;</span> Number(value))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码优化：</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;store,onChange,disabled&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">相当于</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = <span class=\"keyword\">this</span>.props.store;</span><br><span class=\"line\"><span class=\"keyword\">let</span> onChange = <span class=\"keyword\">this</span>.props.onChange;</span><br><span class=\"line\"><span class=\"keyword\">let</span> disabled = <span class=\"keyword\">this</span>.props.disabled;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>回调方法：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">callback</span> &amp;&amp; typeof (callback) == 'function' &amp;&amp; callback();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>render中的双重循环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Form.Item label=<span class=\"string\">\"出游人群\"</span> labelWidth=<span class=\"string\">\"120px\"</span>&gt;</span><br><span class=\"line\">  &#123;   </span><br><span class=\"line\">    tabAttrObj.touristType.length ?</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.touristTypeList.map(<span class=\"function\">(<span class=\"params\">allType,key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(</span><br><span class=\"line\">          tabAttrObj.touristType.map(<span class=\"function\">(<span class=\"params\">type, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>111<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )                                     </span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    :<span class=\"string\">''</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Form.Item&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传入子组件的代码优化：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CollectMethod &#123;..<span class=\"selector-class\">.this</span><span class=\"selector-class\">.props</span>&#125;  /&gt;</span><br><span class=\"line\">相当于</span><br><span class=\"line\">&lt;AddInput store=&#123;this<span class=\"selector-class\">.props</span><span class=\"selector-class\">.store</span>&#125;</span><br><span class=\"line\">            basicListIndex=&#123;this<span class=\"selector-class\">.props</span><span class=\"selector-class\">.basicListIndex</span>&#125;</span><br><span class=\"line\">            tabAttrObj=&#123;this<span class=\"selector-class\">.props</span><span class=\"selector-class\">.tabAttrObj</span>&#125;</span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>class 的取值函数（getter）和存值函数（setter）</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">get</span> <span class=\"title\">prop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">set</span> <span class=\"title\">prop</span>(<span class=\"params\"><span class=\"keyword\">value</span></span>) </span>&#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'setter: '</span>+<span class=\"keyword\">value</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;&#123;<span class=\"keyword\">this</span>.prop&#125;&lt;/div&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>复制数组，修改a2的值，并不会影响a1的值。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"built_in\">a1</span> = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]<span class=\"comment\">;</span></span><br><span class=\"line\">const <span class=\"built_in\">a2</span> = [...a1]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.css88.com/react/docs/handling-events.html\" target=\"_blank\" rel=\"noopener\">React中文文档</a></li>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.md\" target=\"_blank\" rel=\"noopener\">王老师的积累</a></li>\n</ul>\n"},{"title":"React进阶之 React性能优化","date":"2018-05-20T16:00:00.000Z","_content":"\n### react性能查看工具\n\n### react组件的性能优化（渲染角度优化）\n\n\n\n### 利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\n\n\n### 谈一谈创建React Component的几种方式\n\n\n### React PureComponent 使用指南\n\n原文：\nhttps://www.cnblogs.com/penghuwan/p/6707254.html\nhttps://www.cnblogs.com/Unknw/p/6431375.html\nhttp://www.wulv.site/2017-05-31/react-purecomponent.html\nhttps://www.jianshu.com/p/333f390f2e84\n","source":"_posts/React进阶之 React性能优化.md","raw":"title: React进阶之 React性能优化\ndate: 2018/05/21\ncategories: 库/框架\ntags:\n  - React\n---\n\n### react性能查看工具\n\n### react组件的性能优化（渲染角度优化）\n\n\n\n### 利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\n\n\n### 谈一谈创建React Component的几种方式\n\n\n### React PureComponent 使用指南\n\n原文：\nhttps://www.cnblogs.com/penghuwan/p/6707254.html\nhttps://www.cnblogs.com/Unknw/p/6431375.html\nhttp://www.wulv.site/2017-05-31/react-purecomponent.html\nhttps://www.jianshu.com/p/333f390f2e84\n","slug":"React进阶之 React性能优化","published":1,"updated":"2018-07-08T15:18:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81ux900107q0t8guvkqhq","content":"<h3 id=\"react性能查看工具\"><a href=\"#react性能查看工具\" class=\"headerlink\" title=\"react性能查看工具\"></a>react性能查看工具</h3><h3 id=\"react组件的性能优化（渲染角度优化）\"><a href=\"#react组件的性能优化（渲染角度优化）\" class=\"headerlink\" title=\"react组件的性能优化（渲染角度优化）\"></a>react组件的性能优化（渲染角度优化）</h3><h3 id=\"利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\"><a href=\"#利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\" class=\"headerlink\" title=\"利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\"></a>利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性</h3><h3 id=\"谈一谈创建React-Component的几种方式\"><a href=\"#谈一谈创建React-Component的几种方式\" class=\"headerlink\" title=\"谈一谈创建React Component的几种方式\"></a>谈一谈创建React Component的几种方式</h3><h3 id=\"React-PureComponent-使用指南\"><a href=\"#React-PureComponent-使用指南\" class=\"headerlink\" title=\"React PureComponent 使用指南\"></a>React PureComponent 使用指南</h3><p>原文：<br><a href=\"https://www.cnblogs.com/penghuwan/p/6707254.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/penghuwan/p/6707254.html</a><br><a href=\"https://www.cnblogs.com/Unknw/p/6431375.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Unknw/p/6431375.html</a><br><a href=\"http://www.wulv.site/2017-05-31/react-purecomponent.html\" target=\"_blank\" rel=\"noopener\">http://www.wulv.site/2017-05-31/react-purecomponent.html</a><br><a href=\"https://www.jianshu.com/p/333f390f2e84\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/333f390f2e84</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"react性能查看工具\"><a href=\"#react性能查看工具\" class=\"headerlink\" title=\"react性能查看工具\"></a>react性能查看工具</h3><h3 id=\"react组件的性能优化（渲染角度优化）\"><a href=\"#react组件的性能优化（渲染角度优化）\" class=\"headerlink\" title=\"react组件的性能优化（渲染角度优化）\"></a>react组件的性能优化（渲染角度优化）</h3><h3 id=\"利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\"><a href=\"#利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\" class=\"headerlink\" title=\"利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性\"></a>利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性</h3><h3 id=\"谈一谈创建React-Component的几种方式\"><a href=\"#谈一谈创建React-Component的几种方式\" class=\"headerlink\" title=\"谈一谈创建React Component的几种方式\"></a>谈一谈创建React Component的几种方式</h3><h3 id=\"React-PureComponent-使用指南\"><a href=\"#React-PureComponent-使用指南\" class=\"headerlink\" title=\"React PureComponent 使用指南\"></a>React PureComponent 使用指南</h3><p>原文：<br><a href=\"https://www.cnblogs.com/penghuwan/p/6707254.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/penghuwan/p/6707254.html</a><br><a href=\"https://www.cnblogs.com/Unknw/p/6431375.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Unknw/p/6431375.html</a><br><a href=\"http://www.wulv.site/2017-05-31/react-purecomponent.html\" target=\"_blank\" rel=\"noopener\">http://www.wulv.site/2017-05-31/react-purecomponent.html</a><br><a href=\"https://www.jianshu.com/p/333f390f2e84\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/333f390f2e84</a></p>\n"},{"title":"React进阶之 使用mobx进行状态管理","date":"2018-06-10T16:00:00.000Z","toc":true,"_content":"\n\n\n### mobx解决了什么问题\nreact 关注的状态(state)到视图(view)的问题。而 mobx 关注的是状态仓库（store）到的状态(state)的问题。\n任何源自应用状态的东西都应该自动地获得。\n\n#### 与react的关系\nreact提供了优化UI渲染的机制，这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。mobx提供了优化应用状态与react组件同步的机制，这种机制就是使用响应式虚拟依赖状态图标，它只有在真正需要的时候才更新并且永远保持是最新的。\n\n#### 核心概念\nmobx 最最核心的概念只有2个。 @observable 和 @observer ，它们分别对应的是被观察者和观察者。这是大家常见的观察者模式，不过这里使用了，ES7 中的 装饰器。\n\n##### Observable state（可观察的状态）\n\n 通过使用@observable装饰器来给现有的数据结构（如对象、数组和类实例）添加可观察的功能。\n 注：@observable是es.next的写法，在es5中，使用extendObservable()来实现。\n\n##### Computed values（计算值）\n\n 定义在相关数据发生变化时自动更新的值，可通过@computed 装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用。\n\n##### Reactions（反应）\n- reactions在响应式编程和命令式编程之间建立沟通的桥梁。\n\n- reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新react组件数以修补dom等。\n\n- observer()会将组件转换为它们需要渲染的数据的衍生。\n  import {observer} from 'mobx-react'\n- 自定义reactions：\n  使用autorun、reaction、when函数即可简单的创建自定义reactions，用来满足具体场景。\n##### Actions(动作)\n- 状态应该以某种状态来更新。\n\n#### mobx会对什么作出响应？\n\n会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应。\n\n#### mobx的优点：（简单且可扩展）\n\nA.使用类和真正的引用 B.保证参照完整性 C.更简单的actions更便于维护 D.细粒度的可观测性是高效的 E.易操作性\n\n#### mobx要点 将一个应用变成响应式的步骤\n(1)定义状态并使其可观察\n\n```\nimport {observable} from 'mobx';\nvar appState = observable({ timer: 0 })\n```\n\n(2)创建视图以响应状态的变化\n```\nimport {observer} from 'mobx-react';\n\n @observer class TimerView extends React.Component{\n    render(){\n      return (\n        Seconds passed: {this.props.appState.timer}\n        )\n    }\n\n     onReset(){\n         this.props.appState.resetTimer();\n     }\n }\n\n ReactDOM.render(<TimerView appState={appState} />,document.body);\n ```\n(3)更新状态（mobx帮助你以一种简单直观的方式来完成工作） appState.resetTimer = action(function reset(){ appState.timer = 0; })\n```\n setInterval(action(function tick(){\n     appState.timer += 1;\n ),1000)\n ```\n#### 概念\n\n1. State(状态)\n\n 状态是驱动应用的数据。\n2. Dervations(衍生)\n\n- 任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。\n- 衍生的存在形式：用户界面、衍生数据、后端集成\n- mobx区分了两种类型的衍生：Computed values 和 Reactions\n- 黄金法则：如果想创建一个基于当前状态的值时，使用computed\n3. Actions(动作)\n\n 动作是任一一段可以改变状态的代码。\n#### 原则\n\n- mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。\n\n Action -> State -> Views\n- 当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。\n\n- 所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。\n\n- 计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么他会自动被垃圾回收。\n\n- 所有的计算值都应该是纯净的。它们不应该用来改变状态。\n\n### 实际开发中遇到的问题及解决过程\n\n1.  @observable 数组\n\n A.将数组变成可观察的对象时，map、forEach、indexOf、find等原生数组可用的方法，仍可以使用。\n\n B.在控制台打印这个数组时，已经变成了ObservableArray,并不是Array对象了。\n\n C.可以使用xxx.slice()将其变成原生数组。\n\n原文：\n- [JS 装饰器（Decorator）场景实战](https://juejin.im/post/59f1c484f265da431c6f8940)\n- [王老师的积累](https://github.com/wang-qingqing/accumulate/blob/f5779c2a734420200a34531d2ad7bdcfd91bd0ec/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EMobx.md)\n\n- [mobx中文文档](http://cn.mobx.js.org/)\n\n- [mobx todolist](https://codesandbox.io/s/2vmzpM0wK)\n\n- [mobx 在ReactJS项目中的运用](https://blog.csdn.net/u012125579/article/details/69400169)\n","source":"_posts/React进阶之 使用mobx进行状态管理.md","raw":"title: React进阶之 使用mobx进行状态管理\ndate: 2018/06/11\ncategories: 库/框架\ntoc: true\ntags:\n  - React\n---\n\n\n\n### mobx解决了什么问题\nreact 关注的状态(state)到视图(view)的问题。而 mobx 关注的是状态仓库（store）到的状态(state)的问题。\n任何源自应用状态的东西都应该自动地获得。\n\n#### 与react的关系\nreact提供了优化UI渲染的机制，这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。mobx提供了优化应用状态与react组件同步的机制，这种机制就是使用响应式虚拟依赖状态图标，它只有在真正需要的时候才更新并且永远保持是最新的。\n\n#### 核心概念\nmobx 最最核心的概念只有2个。 @observable 和 @observer ，它们分别对应的是被观察者和观察者。这是大家常见的观察者模式，不过这里使用了，ES7 中的 装饰器。\n\n##### Observable state（可观察的状态）\n\n 通过使用@observable装饰器来给现有的数据结构（如对象、数组和类实例）添加可观察的功能。\n 注：@observable是es.next的写法，在es5中，使用extendObservable()来实现。\n\n##### Computed values（计算值）\n\n 定义在相关数据发生变化时自动更新的值，可通过@computed 装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用。\n\n##### Reactions（反应）\n- reactions在响应式编程和命令式编程之间建立沟通的桥梁。\n\n- reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新react组件数以修补dom等。\n\n- observer()会将组件转换为它们需要渲染的数据的衍生。\n  import {observer} from 'mobx-react'\n- 自定义reactions：\n  使用autorun、reaction、when函数即可简单的创建自定义reactions，用来满足具体场景。\n##### Actions(动作)\n- 状态应该以某种状态来更新。\n\n#### mobx会对什么作出响应？\n\n会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应。\n\n#### mobx的优点：（简单且可扩展）\n\nA.使用类和真正的引用 B.保证参照完整性 C.更简单的actions更便于维护 D.细粒度的可观测性是高效的 E.易操作性\n\n#### mobx要点 将一个应用变成响应式的步骤\n(1)定义状态并使其可观察\n\n```\nimport {observable} from 'mobx';\nvar appState = observable({ timer: 0 })\n```\n\n(2)创建视图以响应状态的变化\n```\nimport {observer} from 'mobx-react';\n\n @observer class TimerView extends React.Component{\n    render(){\n      return (\n        Seconds passed: {this.props.appState.timer}\n        )\n    }\n\n     onReset(){\n         this.props.appState.resetTimer();\n     }\n }\n\n ReactDOM.render(<TimerView appState={appState} />,document.body);\n ```\n(3)更新状态（mobx帮助你以一种简单直观的方式来完成工作） appState.resetTimer = action(function reset(){ appState.timer = 0; })\n```\n setInterval(action(function tick(){\n     appState.timer += 1;\n ),1000)\n ```\n#### 概念\n\n1. State(状态)\n\n 状态是驱动应用的数据。\n2. Dervations(衍生)\n\n- 任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。\n- 衍生的存在形式：用户界面、衍生数据、后端集成\n- mobx区分了两种类型的衍生：Computed values 和 Reactions\n- 黄金法则：如果想创建一个基于当前状态的值时，使用computed\n3. Actions(动作)\n\n 动作是任一一段可以改变状态的代码。\n#### 原则\n\n- mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。\n\n Action -> State -> Views\n- 当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。\n\n- 所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。\n\n- 计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么他会自动被垃圾回收。\n\n- 所有的计算值都应该是纯净的。它们不应该用来改变状态。\n\n### 实际开发中遇到的问题及解决过程\n\n1.  @observable 数组\n\n A.将数组变成可观察的对象时，map、forEach、indexOf、find等原生数组可用的方法，仍可以使用。\n\n B.在控制台打印这个数组时，已经变成了ObservableArray,并不是Array对象了。\n\n C.可以使用xxx.slice()将其变成原生数组。\n\n原文：\n- [JS 装饰器（Decorator）场景实战](https://juejin.im/post/59f1c484f265da431c6f8940)\n- [王老师的积累](https://github.com/wang-qingqing/accumulate/blob/f5779c2a734420200a34531d2ad7bdcfd91bd0ec/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EMobx.md)\n\n- [mobx中文文档](http://cn.mobx.js.org/)\n\n- [mobx todolist](https://codesandbox.io/s/2vmzpM0wK)\n\n- [mobx 在ReactJS项目中的运用](https://blog.csdn.net/u012125579/article/details/69400169)\n","slug":"React进阶之 使用mobx进行状态管理","published":1,"updated":"2018-07-19T14:33:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxb00147q0tn30rnylf","content":"<h3 id=\"mobx解决了什么问题\"><a href=\"#mobx解决了什么问题\" class=\"headerlink\" title=\"mobx解决了什么问题\"></a>mobx解决了什么问题</h3><p>react 关注的状态(state)到视图(view)的问题。而 mobx 关注的是状态仓库（store）到的状态(state)的问题。<br>任何源自应用状态的东西都应该自动地获得。</p>\n<h4 id=\"与react的关系\"><a href=\"#与react的关系\" class=\"headerlink\" title=\"与react的关系\"></a>与react的关系</h4><p>react提供了优化UI渲染的机制，这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。mobx提供了优化应用状态与react组件同步的机制，这种机制就是使用响应式虚拟依赖状态图标，它只有在真正需要的时候才更新并且永远保持是最新的。</p>\n<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><p>mobx 最最核心的概念只有2个。 @observable 和 @observer ，它们分别对应的是被观察者和观察者。这是大家常见的观察者模式，不过这里使用了，ES7 中的 装饰器。</p>\n<h5 id=\"Observable-state（可观察的状态）\"><a href=\"#Observable-state（可观察的状态）\" class=\"headerlink\" title=\"Observable state（可观察的状态）\"></a>Observable state（可观察的状态）</h5><p> 通过使用@observable装饰器来给现有的数据结构（如对象、数组和类实例）添加可观察的功能。<br> 注：@observable是es.next的写法，在es5中，使用extendObservable()来实现。</p>\n<h5 id=\"Computed-values（计算值）\"><a href=\"#Computed-values（计算值）\" class=\"headerlink\" title=\"Computed values（计算值）\"></a>Computed values（计算值）</h5><p> 定义在相关数据发生变化时自动更新的值，可通过@computed 装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用。</p>\n<h5 id=\"Reactions（反应）\"><a href=\"#Reactions（反应）\" class=\"headerlink\" title=\"Reactions（反应）\"></a>Reactions（反应）</h5><ul>\n<li><p>reactions在响应式编程和命令式编程之间建立沟通的桥梁。</p>\n</li>\n<li><p>reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新react组件数以修补dom等。</p>\n</li>\n<li><p>observer()会将组件转换为它们需要渲染的数据的衍生。<br>import {observer} from ‘mobx-react’</p>\n</li>\n<li>自定义reactions：<br>使用autorun、reaction、when函数即可简单的创建自定义reactions，用来满足具体场景。<h5 id=\"Actions-动作\"><a href=\"#Actions-动作\" class=\"headerlink\" title=\"Actions(动作)\"></a>Actions(动作)</h5></li>\n<li>状态应该以某种状态来更新。</li>\n</ul>\n<h4 id=\"mobx会对什么作出响应？\"><a href=\"#mobx会对什么作出响应？\" class=\"headerlink\" title=\"mobx会对什么作出响应？\"></a>mobx会对什么作出响应？</h4><p>会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应。</p>\n<h4 id=\"mobx的优点：（简单且可扩展）\"><a href=\"#mobx的优点：（简单且可扩展）\" class=\"headerlink\" title=\"mobx的优点：（简单且可扩展）\"></a>mobx的优点：（简单且可扩展）</h4><p>A.使用类和真正的引用 B.保证参照完整性 C.更简单的actions更便于维护 D.细粒度的可观测性是高效的 E.易操作性</p>\n<h4 id=\"mobx要点-将一个应用变成响应式的步骤\"><a href=\"#mobx要点-将一个应用变成响应式的步骤\" class=\"headerlink\" title=\"mobx要点 将一个应用变成响应式的步骤\"></a>mobx要点 将一个应用变成响应式的步骤</h4><p>(1)定义状态并使其可观察</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'mobx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> appState = observable(&#123; <span class=\"attr\">timer</span>: <span class=\"number\">0</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>(2)创建视图以响应状态的变化<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;observer&#125; from <span class=\"symbol\">'mobx</span>-react';</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@observer</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"type\">Seconds</span> passed: &#123;<span class=\"keyword\">this</span>.props.appState.timer&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     onReset()&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.props.appState.resetTimer();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">ReactDOM</span>.render(&lt;<span class=\"type\">TimerView</span> appState=&#123;appState&#125; /&gt;,document.body);</span><br></pre></td></tr></table></figure></p>\n<p>(3)更新状态（mobx帮助你以一种简单直观的方式来完成工作） appState.resetTimer = action(function reset(){ appState.timer = 0; })<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(<span class=\"name\">action</span>(<span class=\"name\">function</span> tick()&#123;</span><br><span class=\"line\">    appState.timer += <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">),<span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ol>\n<li><p>State(状态)</p>\n<p>状态是驱动应用的数据。</p>\n</li>\n<li>Dervations(衍生)</li>\n</ol>\n<ul>\n<li>任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。</li>\n<li>衍生的存在形式：用户界面、衍生数据、后端集成</li>\n<li>mobx区分了两种类型的衍生：Computed values 和 Reactions</li>\n<li>黄金法则：如果想创建一个基于当前状态的值时，使用computed</li>\n</ul>\n<ol start=\"3\">\n<li><p>Actions(动作)</p>\n<p>动作是任一一段可以改变状态的代码。</p>\n<h4 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h4></li>\n</ol>\n<ul>\n<li><p>mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。</p>\n<p>Action -&gt; State -&gt; Views</p>\n</li>\n<li><p>当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。</p>\n</li>\n<li><p>所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。</p>\n</li>\n<li><p>计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么他会自动被垃圾回收。</p>\n</li>\n<li><p>所有的计算值都应该是纯净的。它们不应该用来改变状态。</p>\n</li>\n</ul>\n<h3 id=\"实际开发中遇到的问题及解决过程\"><a href=\"#实际开发中遇到的问题及解决过程\" class=\"headerlink\" title=\"实际开发中遇到的问题及解决过程\"></a>实际开发中遇到的问题及解决过程</h3><ol>\n<li><p>@observable 数组</p>\n<p>A.将数组变成可观察的对象时，map、forEach、indexOf、find等原生数组可用的方法，仍可以使用。</p>\n<p>B.在控制台打印这个数组时，已经变成了ObservableArray,并不是Array对象了。</p>\n<p>C.可以使用xxx.slice()将其变成原生数组。</p>\n</li>\n</ol>\n<p>原文：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/59f1c484f265da431c6f8940\" target=\"_blank\" rel=\"noopener\">JS 装饰器（Decorator）场景实战</a></li>\n<li><p><a href=\"https://github.com/wang-qingqing/accumulate/blob/f5779c2a734420200a34531d2ad7bdcfd91bd0ec/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EMobx.md\" target=\"_blank\" rel=\"noopener\">王老师的积累</a></p>\n</li>\n<li><p><a href=\"http://cn.mobx.js.org/\" target=\"_blank\" rel=\"noopener\">mobx中文文档</a></p>\n</li>\n<li><p><a href=\"https://codesandbox.io/s/2vmzpM0wK\" target=\"_blank\" rel=\"noopener\">mobx todolist</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u012125579/article/details/69400169\" target=\"_blank\" rel=\"noopener\">mobx 在ReactJS项目中的运用</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"mobx解决了什么问题\"><a href=\"#mobx解决了什么问题\" class=\"headerlink\" title=\"mobx解决了什么问题\"></a>mobx解决了什么问题</h3><p>react 关注的状态(state)到视图(view)的问题。而 mobx 关注的是状态仓库（store）到的状态(state)的问题。<br>任何源自应用状态的东西都应该自动地获得。</p>\n<h4 id=\"与react的关系\"><a href=\"#与react的关系\" class=\"headerlink\" title=\"与react的关系\"></a>与react的关系</h4><p>react提供了优化UI渲染的机制，这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。mobx提供了优化应用状态与react组件同步的机制，这种机制就是使用响应式虚拟依赖状态图标，它只有在真正需要的时候才更新并且永远保持是最新的。</p>\n<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><p>mobx 最最核心的概念只有2个。 @observable 和 @observer ，它们分别对应的是被观察者和观察者。这是大家常见的观察者模式，不过这里使用了，ES7 中的 装饰器。</p>\n<h5 id=\"Observable-state（可观察的状态）\"><a href=\"#Observable-state（可观察的状态）\" class=\"headerlink\" title=\"Observable state（可观察的状态）\"></a>Observable state（可观察的状态）</h5><p> 通过使用@observable装饰器来给现有的数据结构（如对象、数组和类实例）添加可观察的功能。<br> 注：@observable是es.next的写法，在es5中，使用extendObservable()来实现。</p>\n<h5 id=\"Computed-values（计算值）\"><a href=\"#Computed-values（计算值）\" class=\"headerlink\" title=\"Computed values（计算值）\"></a>Computed values（计算值）</h5><p> 定义在相关数据发生变化时自动更新的值，可通过@computed 装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用。</p>\n<h5 id=\"Reactions（反应）\"><a href=\"#Reactions（反应）\" class=\"headerlink\" title=\"Reactions（反应）\"></a>Reactions（反应）</h5><ul>\n<li><p>reactions在响应式编程和命令式编程之间建立沟通的桥梁。</p>\n</li>\n<li><p>reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新react组件数以修补dom等。</p>\n</li>\n<li><p>observer()会将组件转换为它们需要渲染的数据的衍生。<br>import {observer} from ‘mobx-react’</p>\n</li>\n<li>自定义reactions：<br>使用autorun、reaction、when函数即可简单的创建自定义reactions，用来满足具体场景。<h5 id=\"Actions-动作\"><a href=\"#Actions-动作\" class=\"headerlink\" title=\"Actions(动作)\"></a>Actions(动作)</h5></li>\n<li>状态应该以某种状态来更新。</li>\n</ul>\n<h4 id=\"mobx会对什么作出响应？\"><a href=\"#mobx会对什么作出响应？\" class=\"headerlink\" title=\"mobx会对什么作出响应？\"></a>mobx会对什么作出响应？</h4><p>会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应。</p>\n<h4 id=\"mobx的优点：（简单且可扩展）\"><a href=\"#mobx的优点：（简单且可扩展）\" class=\"headerlink\" title=\"mobx的优点：（简单且可扩展）\"></a>mobx的优点：（简单且可扩展）</h4><p>A.使用类和真正的引用 B.保证参照完整性 C.更简单的actions更便于维护 D.细粒度的可观测性是高效的 E.易操作性</p>\n<h4 id=\"mobx要点-将一个应用变成响应式的步骤\"><a href=\"#mobx要点-将一个应用变成响应式的步骤\" class=\"headerlink\" title=\"mobx要点 将一个应用变成响应式的步骤\"></a>mobx要点 将一个应用变成响应式的步骤</h4><p>(1)定义状态并使其可观察</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'mobx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> appState = observable(&#123; <span class=\"attr\">timer</span>: <span class=\"number\">0</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>(2)创建视图以响应状态的变化<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;observer&#125; from <span class=\"symbol\">'mobx</span>-react';</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@observer</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"type\">Seconds</span> passed: &#123;<span class=\"keyword\">this</span>.props.appState.timer&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     onReset()&#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.props.appState.resetTimer();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">ReactDOM</span>.render(&lt;<span class=\"type\">TimerView</span> appState=&#123;appState&#125; /&gt;,document.body);</span><br></pre></td></tr></table></figure></p>\n<p>(3)更新状态（mobx帮助你以一种简单直观的方式来完成工作） appState.resetTimer = action(function reset(){ appState.timer = 0; })<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(<span class=\"name\">action</span>(<span class=\"name\">function</span> tick()&#123;</span><br><span class=\"line\">    appState.timer += <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">),<span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ol>\n<li><p>State(状态)</p>\n<p>状态是驱动应用的数据。</p>\n</li>\n<li>Dervations(衍生)</li>\n</ol>\n<ul>\n<li>任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。</li>\n<li>衍生的存在形式：用户界面、衍生数据、后端集成</li>\n<li>mobx区分了两种类型的衍生：Computed values 和 Reactions</li>\n<li>黄金法则：如果想创建一个基于当前状态的值时，使用computed</li>\n</ul>\n<ol start=\"3\">\n<li><p>Actions(动作)</p>\n<p>动作是任一一段可以改变状态的代码。</p>\n<h4 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h4></li>\n</ol>\n<ul>\n<li><p>mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。</p>\n<p>Action -&gt; State -&gt; Views</p>\n</li>\n<li><p>当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。</p>\n</li>\n<li><p>所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。</p>\n</li>\n<li><p>计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么他会自动被垃圾回收。</p>\n</li>\n<li><p>所有的计算值都应该是纯净的。它们不应该用来改变状态。</p>\n</li>\n</ul>\n<h3 id=\"实际开发中遇到的问题及解决过程\"><a href=\"#实际开发中遇到的问题及解决过程\" class=\"headerlink\" title=\"实际开发中遇到的问题及解决过程\"></a>实际开发中遇到的问题及解决过程</h3><ol>\n<li><p>@observable 数组</p>\n<p>A.将数组变成可观察的对象时，map、forEach、indexOf、find等原生数组可用的方法，仍可以使用。</p>\n<p>B.在控制台打印这个数组时，已经变成了ObservableArray,并不是Array对象了。</p>\n<p>C.可以使用xxx.slice()将其变成原生数组。</p>\n</li>\n</ol>\n<p>原文：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/59f1c484f265da431c6f8940\" target=\"_blank\" rel=\"noopener\">JS 装饰器（Decorator）场景实战</a></li>\n<li><p><a href=\"https://github.com/wang-qingqing/accumulate/blob/f5779c2a734420200a34531d2ad7bdcfd91bd0ec/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EMobx.md\" target=\"_blank\" rel=\"noopener\">王老师的积累</a></p>\n</li>\n<li><p><a href=\"http://cn.mobx.js.org/\" target=\"_blank\" rel=\"noopener\">mobx中文文档</a></p>\n</li>\n<li><p><a href=\"https://codesandbox.io/s/2vmzpM0wK\" target=\"_blank\" rel=\"noopener\">mobx todolist</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u012125579/article/details/69400169\" target=\"_blank\" rel=\"noopener\">mobx 在ReactJS项目中的运用</a></p>\n</li>\n</ul>\n"},{"title":"盲人阅读网页时使用的读屏技术是怎样的？","date":"2018-07-20T16:00:00.000Z","_content":"\n周末\n\nWAI-ARIA无障碍网页应用属性\n\nhttps://www.zhangxinxu.com/wordpress/2012/03/wai-aria-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%98%85%E8%AF%BB/\n","source":"_posts/WAI-ARIA无障碍网页应用属性.md","raw":"title: 盲人阅读网页时使用的读屏技术是怎样的？\ndate: 2018/07/21\ncategories:\n  - 十万个为什么\ntags:\n  - HTTP\n---\n\n周末\n\nWAI-ARIA无障碍网页应用属性\n\nhttps://www.zhangxinxu.com/wordpress/2012/03/wai-aria-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%98%85%E8%AF%BB/\n","slug":"WAI-ARIA无障碍网页应用属性","published":1,"updated":"2018-07-23T14:54:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxe00177q0t8e33trnr","content":"<p>周末</p>\n<p>WAI-ARIA无障碍网页应用属性</p>\n<p><a href=\"https://www.zhangxinxu.com/wordpress/2012/03/wai-aria-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%98%85%E8%AF%BB/\" target=\"_blank\" rel=\"noopener\">https://www.zhangxinxu.com/wordpress/2012/03/wai-aria-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%98%85%E8%AF%BB/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>周末</p>\n<p>WAI-ARIA无障碍网页应用属性</p>\n<p><a href=\"https://www.zhangxinxu.com/wordpress/2012/03/wai-aria-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%98%85%E8%AF%BB/\" target=\"_blank\" rel=\"noopener\">https://www.zhangxinxu.com/wordpress/2012/03/wai-aria-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%98%85%E8%AF%BB/</a></p>\n"},{"title":"XMLHttpRequest","date":"2018-06-09T16:00:00.000Z","toc":true,"_content":"\n### XMLHttpRequest 是什么？\nXMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。\n\n### 创建 XMLHttpRequest 对象\n所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。\n\n通过一行简单的 JavaScript 代码，我们就可以创建 XMLHttpRequest 对象。\n\n### 创建 XMLHttpRequest 对象的语法\n```\nxmlhttp=new XMLHttpRequest();\n```\n老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象\n```\nxmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n```\n### 使用 XMLHttpRequest 对象\n```\nvar xmlhttp;\nfunction loadXMLDoc(url)\n    {\n    xmlhttp=null;\n    if (window.XMLHttpRequest){// code for all new browsers\n      xmlhttp=new XMLHttpRequest(); //创建xml对象\n      }\n    else if (window.ActiveXObject){// code for IE5 and IE6\n      xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n      }\n    if (xmlhttp!=null){\n          xmlhttp.onreadystatechange=function(){\n              if (xmlhttp.readyState==4){// 4 = \"loaded\" \t整个请求过程已经完毕\n\n                if (xmlhttp.status==200){请求的响应状态码 (例如, 状态码200 表示一个成功的请求).\n                  // ...our code here...TODO\n                  }\n                else{\n                  alert(\"Problem retrieving XML data\");\n                  }\n                }\n          }\n          xmlhttp.open(\"GET\",url,true);\n          xmlhttp.send(null);\n      }\n    else{\n      alert(\"Your browser does not support XMLHTTP.\");\n      }\n    }\n\n```\n\n参考：\n- https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\n- http://www.w3school.com.cn/xml/xml_http.asp\n","source":"_posts/XMLHttpRequest.md","raw":"title: XMLHttpRequest\ndate: 2018/06/10\ncategories: 前端基础\ntoc: true\ntags:\n  - XMLHttpRequest\n---\n\n### XMLHttpRequest 是什么？\nXMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。\n\n### 创建 XMLHttpRequest 对象\n所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。\n\n通过一行简单的 JavaScript 代码，我们就可以创建 XMLHttpRequest 对象。\n\n### 创建 XMLHttpRequest 对象的语法\n```\nxmlhttp=new XMLHttpRequest();\n```\n老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象\n```\nxmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n```\n### 使用 XMLHttpRequest 对象\n```\nvar xmlhttp;\nfunction loadXMLDoc(url)\n    {\n    xmlhttp=null;\n    if (window.XMLHttpRequest){// code for all new browsers\n      xmlhttp=new XMLHttpRequest(); //创建xml对象\n      }\n    else if (window.ActiveXObject){// code for IE5 and IE6\n      xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n      }\n    if (xmlhttp!=null){\n          xmlhttp.onreadystatechange=function(){\n              if (xmlhttp.readyState==4){// 4 = \"loaded\" \t整个请求过程已经完毕\n\n                if (xmlhttp.status==200){请求的响应状态码 (例如, 状态码200 表示一个成功的请求).\n                  // ...our code here...TODO\n                  }\n                else{\n                  alert(\"Problem retrieving XML data\");\n                  }\n                }\n          }\n          xmlhttp.open(\"GET\",url,true);\n          xmlhttp.send(null);\n      }\n    else{\n      alert(\"Your browser does not support XMLHTTP.\");\n      }\n    }\n\n```\n\n参考：\n- https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\n- http://www.w3school.com.cn/xml/xml_http.asp\n","slug":"XMLHttpRequest","published":1,"updated":"2018-07-14T02:30:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxf00197q0tgtfrnf6l","content":"<h3 id=\"XMLHttpRequest-是什么？\"><a href=\"#XMLHttpRequest-是什么？\" class=\"headerlink\" title=\"XMLHttpRequest 是什么？\"></a>XMLHttpRequest 是什么？</h3><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>\n<h3 id=\"创建-XMLHttpRequest-对象\"><a href=\"#创建-XMLHttpRequest-对象\" class=\"headerlink\" title=\"创建 XMLHttpRequest 对象\"></a>创建 XMLHttpRequest 对象</h3><p>所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。</p>\n<p>通过一行简单的 JavaScript 代码，我们就可以创建 XMLHttpRequest 对象。</p>\n<h3 id=\"创建-XMLHttpRequest-对象的语法\"><a href=\"#创建-XMLHttpRequest-对象的语法\" class=\"headerlink\" title=\"创建 XMLHttpRequest 对象的语法\"></a>创建 XMLHttpRequest 对象的语法</h3><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">xmlhttp</span>=new XMLHttpRequest()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象<br><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">xmlhttp</span>=new ActiveXObject(<span class=\"string\">\"Microsoft.XMLHTTP\"</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-XMLHttpRequest-对象\"><a href=\"#使用-XMLHttpRequest-对象\" class=\"headerlink\" title=\"使用 XMLHttpRequest 对象\"></a>使用 XMLHttpRequest 对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xmlhttp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadXMLDoc</span>(<span class=\"params\">url</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    xmlhttp=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest)&#123;<span class=\"comment\">// code for all new browsers</span></span><br><span class=\"line\">      xmlhttp=<span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建xml对象</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.ActiveXObject)&#123;<span class=\"comment\">// code for IE5 and IE6</span></span><br><span class=\"line\">      xmlhttp=<span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">\"Microsoft.XMLHTTP\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">          xmlhttp.onreadystatechange=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (xmlhttp.readyState==<span class=\"number\">4</span>)&#123;<span class=\"comment\">// 4 = \"loaded\" \t整个请求过程已经完毕</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (xmlhttp.status==<span class=\"number\">200</span>)&#123;请求的响应状态码 (例如, 状态码<span class=\"number\">200</span> 表示一个成功的请求).</span><br><span class=\"line\">                  <span class=\"comment\">// ...our code here...TODO</span></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                  alert(<span class=\"string\">\"Problem retrieving XML data\"</span>);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          xmlhttp.open(<span class=\"string\">\"GET\"</span>,url,<span class=\"literal\">true</span>);</span><br><span class=\"line\">          xmlhttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      alert(<span class=\"string\">\"Your browser does not support XMLHTTP.\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a></li>\n<li><a href=\"http://www.w3school.com.cn/xml/xml_http.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/xml/xml_http.asp</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"XMLHttpRequest-是什么？\"><a href=\"#XMLHttpRequest-是什么？\" class=\"headerlink\" title=\"XMLHttpRequest 是什么？\"></a>XMLHttpRequest 是什么？</h3><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>\n<h3 id=\"创建-XMLHttpRequest-对象\"><a href=\"#创建-XMLHttpRequest-对象\" class=\"headerlink\" title=\"创建 XMLHttpRequest 对象\"></a>创建 XMLHttpRequest 对象</h3><p>所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。</p>\n<p>通过一行简单的 JavaScript 代码，我们就可以创建 XMLHttpRequest 对象。</p>\n<h3 id=\"创建-XMLHttpRequest-对象的语法\"><a href=\"#创建-XMLHttpRequest-对象的语法\" class=\"headerlink\" title=\"创建 XMLHttpRequest 对象的语法\"></a>创建 XMLHttpRequest 对象的语法</h3><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">xmlhttp</span>=new XMLHttpRequest()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象<br><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">xmlhttp</span>=new ActiveXObject(<span class=\"string\">\"Microsoft.XMLHTTP\"</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-XMLHttpRequest-对象\"><a href=\"#使用-XMLHttpRequest-对象\" class=\"headerlink\" title=\"使用 XMLHttpRequest 对象\"></a>使用 XMLHttpRequest 对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xmlhttp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadXMLDoc</span>(<span class=\"params\">url</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    xmlhttp=<span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest)&#123;<span class=\"comment\">// code for all new browsers</span></span><br><span class=\"line\">      xmlhttp=<span class=\"keyword\">new</span> XMLHttpRequest(); <span class=\"comment\">//创建xml对象</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.ActiveXObject)&#123;<span class=\"comment\">// code for IE5 and IE6</span></span><br><span class=\"line\">      xmlhttp=<span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">\"Microsoft.XMLHTTP\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">          xmlhttp.onreadystatechange=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (xmlhttp.readyState==<span class=\"number\">4</span>)&#123;<span class=\"comment\">// 4 = \"loaded\" \t整个请求过程已经完毕</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (xmlhttp.status==<span class=\"number\">200</span>)&#123;请求的响应状态码 (例如, 状态码<span class=\"number\">200</span> 表示一个成功的请求).</span><br><span class=\"line\">                  <span class=\"comment\">// ...our code here...TODO</span></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                  alert(<span class=\"string\">\"Problem retrieving XML data\"</span>);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          xmlhttp.open(<span class=\"string\">\"GET\"</span>,url,<span class=\"literal\">true</span>);</span><br><span class=\"line\">          xmlhttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      alert(<span class=\"string\">\"Your browser does not support XMLHTTP.\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a></li>\n<li><a href=\"http://www.w3school.com.cn/xml/xml_http.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/xml/xml_http.asp</a></li>\n</ul>\n"},{"title":"YAML语言入门","date":"2018-06-19T16:00:00.000Z","toc":true,"front-matter":"comments:true","_content":"\n使用场景：\n\n编程免不了要写配置文件，写配置文件的时候，除了json格式，yaml格式的配置文件也很常见。所以决定系统学习一下。\n### 简介\nYAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。\n### YAML的基本语法规范\nYAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。\n<!--more-->\n它的基本语法规则如下：\n```\n1. 大小写敏感\n\n2. 使用缩进表示层级关系\n\n3. 缩进时不允许使用Tab键，只允许使用空格。\n\n4. 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n\n5. #表示注释，从这个字符一直到行尾，都会被解析器忽略。\n```\n\n### YAML支持的数据格式\n\nYAML支持的数据格式有三种。\n```\n1. 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n\n2. 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n\n3. 纯量（scalars）：单个的、不可再分的值\n```\n以下分别介绍这三种数据结构。\n\n### 对象\n对象的一组键值对，使用冒号结构表示。\n\n```\nanimal: pets\n\n转为javascript表示为：\n\n { animal: 'pets' }\n```\n\nYaml 也允许另一种写法，将所有键值对写成一个行内对象。\n```\nhash: { name: Steve, foo: bar }\n\n转为js表示为：\n\n{ hash: { name: 'Steve', foo: 'bar' } }\n\n```\n\n### 数组\n一组连词线开头的行，构成一个数组。\n\n```\n- Cat\n- Dog\n- Goldfish\n```\n转为js表示为\n```\n[ 'Cat', 'Dog', 'Goldfish' ]\n```\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n```\n-\n - Cat\n - Dog\n - Goldfish\n```\n转为 JavaScript 如下。\n```\n[ [ 'Cat', 'Dog', 'Goldfish' ] ]\n```\n数组也可以采用行内表示法。\n```\nanimal: [Cat, Dog]\n```\n转为js表示为：\n```\n{ animal: [ 'Cat', 'Dog' ] }\n```\n\n### 复合结构\n对象和数组可以结合使用，形成复合结构。\n```\nlanguages:\n - Ruby\n - Perl\n - Python\nwebsites:\n YAML: yaml.org\n Ruby: ruby-lang.org\n Python: python.org\n Perl: use.perl.org\n ```\n转为 JavaScript 如下\n```\n{ languages: [ 'Ruby', 'Perl', 'Python' ],\n  websites:\n   { YAML: 'yaml.org',\n     Ruby: 'ruby-lang.org',\n     Python: 'python.org',\n     Perl: 'use.perl.org' } }\n```\n\n### 纯量\n纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。\n```\n字符串\n布尔值\n整数\n浮点数\nNull\n时间\n日期\n```\n注意：\n- null 用 ~ 表示。\n- 时间采用 ISO8601 格式。\n```\n  iso8601: 2001-12-14t21:59:43.10-05:00  \n  (js表示：{ iso8601: new Date('2001-12-14t21:59:43.10-05:00') })\n```\n- 日期采用复合 iso8601 格式的年、月、日表示。\n```\n  date: 1976-07-31\n\n  转为 JavaScript 如下。\n  { date: new Date('1976-07-31') }\n\n```\n- YAML 允许使用两个感叹号，强制转换数据类型。\n```\ne: !!str 123\nf: !!str true\n\n转为 JavaScript 如下。\n{ e: '123', f: 'true' }\n```\n\n未完待续。。。\n\n\n\n\n\n\n\n\n\n\n参考：\n- http://www.ruanyifeng.com/blog/2016/07/yaml.html\n","source":"_posts/YAML语言入门.md","raw":"title: YAML语言入门\ndate: 2018/06/20\ncategories: 效率工具\ntoc: true\nfront-matter:\n  comments:true\ntags:\n  - YAML\n---\n\n使用场景：\n\n编程免不了要写配置文件，写配置文件的时候，除了json格式，yaml格式的配置文件也很常见。所以决定系统学习一下。\n### 简介\nYAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。\n### YAML的基本语法规范\nYAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。\n<!--more-->\n它的基本语法规则如下：\n```\n1. 大小写敏感\n\n2. 使用缩进表示层级关系\n\n3. 缩进时不允许使用Tab键，只允许使用空格。\n\n4. 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n\n5. #表示注释，从这个字符一直到行尾，都会被解析器忽略。\n```\n\n### YAML支持的数据格式\n\nYAML支持的数据格式有三种。\n```\n1. 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n\n2. 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n\n3. 纯量（scalars）：单个的、不可再分的值\n```\n以下分别介绍这三种数据结构。\n\n### 对象\n对象的一组键值对，使用冒号结构表示。\n\n```\nanimal: pets\n\n转为javascript表示为：\n\n { animal: 'pets' }\n```\n\nYaml 也允许另一种写法，将所有键值对写成一个行内对象。\n```\nhash: { name: Steve, foo: bar }\n\n转为js表示为：\n\n{ hash: { name: 'Steve', foo: 'bar' } }\n\n```\n\n### 数组\n一组连词线开头的行，构成一个数组。\n\n```\n- Cat\n- Dog\n- Goldfish\n```\n转为js表示为\n```\n[ 'Cat', 'Dog', 'Goldfish' ]\n```\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n```\n-\n - Cat\n - Dog\n - Goldfish\n```\n转为 JavaScript 如下。\n```\n[ [ 'Cat', 'Dog', 'Goldfish' ] ]\n```\n数组也可以采用行内表示法。\n```\nanimal: [Cat, Dog]\n```\n转为js表示为：\n```\n{ animal: [ 'Cat', 'Dog' ] }\n```\n\n### 复合结构\n对象和数组可以结合使用，形成复合结构。\n```\nlanguages:\n - Ruby\n - Perl\n - Python\nwebsites:\n YAML: yaml.org\n Ruby: ruby-lang.org\n Python: python.org\n Perl: use.perl.org\n ```\n转为 JavaScript 如下\n```\n{ languages: [ 'Ruby', 'Perl', 'Python' ],\n  websites:\n   { YAML: 'yaml.org',\n     Ruby: 'ruby-lang.org',\n     Python: 'python.org',\n     Perl: 'use.perl.org' } }\n```\n\n### 纯量\n纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。\n```\n字符串\n布尔值\n整数\n浮点数\nNull\n时间\n日期\n```\n注意：\n- null 用 ~ 表示。\n- 时间采用 ISO8601 格式。\n```\n  iso8601: 2001-12-14t21:59:43.10-05:00  \n  (js表示：{ iso8601: new Date('2001-12-14t21:59:43.10-05:00') })\n```\n- 日期采用复合 iso8601 格式的年、月、日表示。\n```\n  date: 1976-07-31\n\n  转为 JavaScript 如下。\n  { date: new Date('1976-07-31') }\n\n```\n- YAML 允许使用两个感叹号，强制转换数据类型。\n```\ne: !!str 123\nf: !!str true\n\n转为 JavaScript 如下。\n{ e: '123', f: 'true' }\n```\n\n未完待续。。。\n\n\n\n\n\n\n\n\n\n\n参考：\n- http://www.ruanyifeng.com/blog/2016/07/yaml.html\n","slug":"YAML语言入门","published":1,"updated":"2018-06-20T13:22:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxm001d7q0tocrtihh0","content":"<p>使用场景：</p>\n<p>编程免不了要写配置文件，写配置文件的时候，除了json格式，yaml格式的配置文件也很常见。所以决定系统学习一下。</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。</p>\n<h3 id=\"YAML的基本语法规范\"><a href=\"#YAML的基本语法规范\" class=\"headerlink\" title=\"YAML的基本语法规范\"></a>YAML的基本语法规范</h3><p>YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。<br><a id=\"more\"></a><br>它的基本语法规则如下：<br><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1. </span>大小写敏感</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">2. </span>使用缩进表示层级关系</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">3. </span>缩进时不允许使用Tab键，只允许使用空格。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">4. </span>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">5. </span>#表示注释，从这个字符一直到行尾，都会被解析器忽略。</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"YAML支持的数据格式\"><a href=\"#YAML支持的数据格式\" class=\"headerlink\" title=\"YAML支持的数据格式\"></a>YAML支持的数据格式</h3><p>YAML支持的数据格式有三种。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 数组：一组按次序排列的值，又称为序列（sequence） / 列表（<span class=\"type\">list</span>）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> 纯量（scalars）：单个的、不可再分的值</span><br></pre></td></tr></table></figure></p>\n<p>以下分别介绍这三种数据结构。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对象的一组键值对，使用冒号结构表示。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animal</span>: pets</span><br><span class=\"line\"></span><br><span class=\"line\">转为javascript表示为：</span><br><span class=\"line\"></span><br><span class=\"line\"> &#123; animal: 'pets' &#125;</span><br></pre></td></tr></table></figure>\n<p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">hash</span>: &#123; <span class=\"attribute\">name</span>: Steve, foo: bar &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">转为<span class=\"selector-tag\">js</span>表示为：</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; <span class=\"attribute\">hash</span>: &#123; name: <span class=\"string\">'Steve'</span>, foo: <span class=\"string\">'bar'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>一组连词线开头的行，构成一个数组。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\"> Cat</span></span><br><span class=\"line\"><span class=\"ruby\">- Dog</span></span><br><span class=\"line\"><span class=\"ruby\">- Goldfish</span></span><br></pre></td></tr></table></figure>\n<p>转为js表示为<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"symbol\">'Cat</span>', <span class=\"symbol\">'Dog</span>', <span class=\"symbol\">'Goldfish</span>' ]</span><br></pre></td></tr></table></figure></p>\n<p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。<br><figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\"></span></span><br><span class=\"line\"><span class=\"ruby\"> - Cat</span></span><br><span class=\"line\"><span class=\"ruby\"> - Dog</span></span><br><span class=\"line\"><span class=\"ruby\"> - Goldfish</span></span><br></pre></td></tr></table></figure></p>\n<p>转为 JavaScript 如下。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ [ <span class=\"symbol\">'Cat</span>', <span class=\"symbol\">'Dog</span>', <span class=\"symbol\">'Goldfish</span>' ] ]</span><br></pre></td></tr></table></figure></p>\n<p>数组也可以采用行内表示法。<br><figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">animal</span>: <span class=\"comment\">[Cat, Dog]</span></span><br></pre></td></tr></table></figure></p>\n<p>转为js表示为：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attribute\">animal</span>: [ <span class=\"string\">'Cat'</span>, <span class=\"string\">'Dog'</span> ] &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"复合结构\"><a href=\"#复合结构\" class=\"headerlink\" title=\"复合结构\"></a>复合结构</h3><p>对象和数组可以结合使用，形成复合结构。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">languages:</span><br><span class=\"line\"> - Ruby</span><br><span class=\"line\"> - Perl</span><br><span class=\"line\"> - Python</span><br><span class=\"line\">websites:</span><br><span class=\"line\"> YAML: yaml.org</span><br><span class=\"line\"> Ruby: ruby-lang.org</span><br><span class=\"line\"> Python: python.org</span><br><span class=\"line\"> Perl: use<span class=\"selector-class\">.perl</span><span class=\"selector-class\">.org</span></span><br></pre></td></tr></table></figure></p>\n<p>转为 JavaScript 如下<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attribute\">languages</span>: [ <span class=\"string\">'Ruby'</span>, <span class=\"string\">'Perl'</span>, <span class=\"string\">'Python'</span> ],</span><br><span class=\"line\">  <span class=\"attribute\">websites</span>:</span><br><span class=\"line\">   &#123; <span class=\"attribute\">YAML</span>: <span class=\"string\">'yaml.org'</span>,</span><br><span class=\"line\">     <span class=\"attribute\">Ruby</span>: <span class=\"string\">'ruby-lang.org'</span>,</span><br><span class=\"line\">     <span class=\"attribute\">Python</span>: <span class=\"string\">'python.org'</span>,</span><br><span class=\"line\">     <span class=\"attribute\">Perl</span>: <span class=\"string\">'use.perl.org'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"纯量\"><a href=\"#纯量\" class=\"headerlink\" title=\"纯量\"></a>纯量</h3><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">字符串</span></span><br><span class=\"line\"><span class=\"string\">布尔值</span></span><br><span class=\"line\"><span class=\"string\">整数</span></span><br><span class=\"line\"><span class=\"string\">浮点数</span></span><br><span class=\"line\"><span class=\"literal\">Null</span></span><br><span class=\"line\"><span class=\"string\">时间</span></span><br><span class=\"line\"><span class=\"string\">日期</span></span><br></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ul>\n<li>null 用 ~ 表示。</li>\n<li><p>时间采用 ISO8601 格式。</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iso8601: 2001<span class=\"string\">-12</span><span class=\"string\">-14</span>t21:59:43.10<span class=\"string\">-05</span>:00  </span><br><span class=\"line\">(js表示：&#123; iso8601: new Date('2001<span class=\"string\">-12</span><span class=\"string\">-14</span>t21:59:43.10<span class=\"string\">-05</span>:00') &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>日期采用复合 iso8601 格式的年、月、日表示。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">date</span>: 1976-07-31</span><br><span class=\"line\"></span><br><span class=\"line\">转为 JavaScript 如下。</span><br><span class=\"line\">&#123; date: new Date('1976-07-31') &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>YAML 允许使用两个感叹号，强制转换数据类型。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">e</span>: !!str 123</span><br><span class=\"line\"><span class=\"attribute\">f</span>: !!str true</span><br><span class=\"line\"></span><br><span class=\"line\">转为 JavaScript 如下。</span><br><span class=\"line\">&#123; e: '123', f: 'true' &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>未完待续。。。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>使用场景：</p>\n<p>编程免不了要写配置文件，写配置文件的时候，除了json格式，yaml格式的配置文件也很常见。所以决定系统学习一下。</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。</p>\n<h3 id=\"YAML的基本语法规范\"><a href=\"#YAML的基本语法规范\" class=\"headerlink\" title=\"YAML的基本语法规范\"></a>YAML的基本语法规范</h3><p>YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。<br>","more":"<br>它的基本语法规则如下：<br><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1. </span>大小写敏感</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">2. </span>使用缩进表示层级关系</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">3. </span>缩进时不允许使用Tab键，只允许使用空格。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">4. </span>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">5. </span>#表示注释，从这个字符一直到行尾，都会被解析器忽略。</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"YAML支持的数据格式\"><a href=\"#YAML支持的数据格式\" class=\"headerlink\" title=\"YAML支持的数据格式\"></a>YAML支持的数据格式</h3><p>YAML支持的数据格式有三种。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 数组：一组按次序排列的值，又称为序列（sequence） / 列表（<span class=\"type\">list</span>）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> 纯量（scalars）：单个的、不可再分的值</span><br></pre></td></tr></table></figure></p>\n<p>以下分别介绍这三种数据结构。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对象的一组键值对，使用冒号结构表示。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animal</span>: pets</span><br><span class=\"line\"></span><br><span class=\"line\">转为javascript表示为：</span><br><span class=\"line\"></span><br><span class=\"line\"> &#123; animal: 'pets' &#125;</span><br></pre></td></tr></table></figure>\n<p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">hash</span>: &#123; <span class=\"attribute\">name</span>: Steve, foo: bar &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">转为<span class=\"selector-tag\">js</span>表示为：</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; <span class=\"attribute\">hash</span>: &#123; name: <span class=\"string\">'Steve'</span>, foo: <span class=\"string\">'bar'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>一组连词线开头的行，构成一个数组。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\"> Cat</span></span><br><span class=\"line\"><span class=\"ruby\">- Dog</span></span><br><span class=\"line\"><span class=\"ruby\">- Goldfish</span></span><br></pre></td></tr></table></figure>\n<p>转为js表示为<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"symbol\">'Cat</span>', <span class=\"symbol\">'Dog</span>', <span class=\"symbol\">'Goldfish</span>' ]</span><br></pre></td></tr></table></figure></p>\n<p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。<br><figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\"></span></span><br><span class=\"line\"><span class=\"ruby\"> - Cat</span></span><br><span class=\"line\"><span class=\"ruby\"> - Dog</span></span><br><span class=\"line\"><span class=\"ruby\"> - Goldfish</span></span><br></pre></td></tr></table></figure></p>\n<p>转为 JavaScript 如下。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ [ <span class=\"symbol\">'Cat</span>', <span class=\"symbol\">'Dog</span>', <span class=\"symbol\">'Goldfish</span>' ] ]</span><br></pre></td></tr></table></figure></p>\n<p>数组也可以采用行内表示法。<br><figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">animal</span>: <span class=\"comment\">[Cat, Dog]</span></span><br></pre></td></tr></table></figure></p>\n<p>转为js表示为：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attribute\">animal</span>: [ <span class=\"string\">'Cat'</span>, <span class=\"string\">'Dog'</span> ] &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"复合结构\"><a href=\"#复合结构\" class=\"headerlink\" title=\"复合结构\"></a>复合结构</h3><p>对象和数组可以结合使用，形成复合结构。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">languages:</span><br><span class=\"line\"> - Ruby</span><br><span class=\"line\"> - Perl</span><br><span class=\"line\"> - Python</span><br><span class=\"line\">websites:</span><br><span class=\"line\"> YAML: yaml.org</span><br><span class=\"line\"> Ruby: ruby-lang.org</span><br><span class=\"line\"> Python: python.org</span><br><span class=\"line\"> Perl: use<span class=\"selector-class\">.perl</span><span class=\"selector-class\">.org</span></span><br></pre></td></tr></table></figure></p>\n<p>转为 JavaScript 如下<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attribute\">languages</span>: [ <span class=\"string\">'Ruby'</span>, <span class=\"string\">'Perl'</span>, <span class=\"string\">'Python'</span> ],</span><br><span class=\"line\">  <span class=\"attribute\">websites</span>:</span><br><span class=\"line\">   &#123; <span class=\"attribute\">YAML</span>: <span class=\"string\">'yaml.org'</span>,</span><br><span class=\"line\">     <span class=\"attribute\">Ruby</span>: <span class=\"string\">'ruby-lang.org'</span>,</span><br><span class=\"line\">     <span class=\"attribute\">Python</span>: <span class=\"string\">'python.org'</span>,</span><br><span class=\"line\">     <span class=\"attribute\">Perl</span>: <span class=\"string\">'use.perl.org'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"纯量\"><a href=\"#纯量\" class=\"headerlink\" title=\"纯量\"></a>纯量</h3><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">字符串</span></span><br><span class=\"line\"><span class=\"string\">布尔值</span></span><br><span class=\"line\"><span class=\"string\">整数</span></span><br><span class=\"line\"><span class=\"string\">浮点数</span></span><br><span class=\"line\"><span class=\"literal\">Null</span></span><br><span class=\"line\"><span class=\"string\">时间</span></span><br><span class=\"line\"><span class=\"string\">日期</span></span><br></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ul>\n<li>null 用 ~ 表示。</li>\n<li><p>时间采用 ISO8601 格式。</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iso8601: 2001<span class=\"string\">-12</span><span class=\"string\">-14</span>t21:59:43.10<span class=\"string\">-05</span>:00  </span><br><span class=\"line\">(js表示：&#123; iso8601: new Date('2001<span class=\"string\">-12</span><span class=\"string\">-14</span>t21:59:43.10<span class=\"string\">-05</span>:00') &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>日期采用复合 iso8601 格式的年、月、日表示。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">date</span>: 1976-07-31</span><br><span class=\"line\"></span><br><span class=\"line\">转为 JavaScript 如下。</span><br><span class=\"line\">&#123; date: new Date('1976-07-31') &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>YAML 允许使用两个感叹号，强制转换数据类型。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">e</span>: !!str 123</span><br><span class=\"line\"><span class=\"attribute\">f</span>: !!str true</span><br><span class=\"line\"></span><br><span class=\"line\">转为 JavaScript 如下。</span><br><span class=\"line\">&#123; e: '123', f: 'true' &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>未完待续。。。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a></li>\n</ul>"},{"title":"axios常用攻略","date":"2018-06-13T16:00:00.000Z","toc":true,"_content":"\n\n\n### 安装\nnpm install axios\n\n**axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。**\n\n<!--more-->\n\n### 常见用法\n\n1. 执行get请求\n\n```\n        // 向具有指定ID的用户发出请求\n        axios.get('/user?ID=12345')\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n\n\n\n        // 也可以通过 params 对象传递参数\n        axios.get('/user', {\n            params: {\n            ID: 12345\n            }\n        })\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n```\n\n2. 执行post请求\n\n```\n    axios.post('/user', {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    })\n    .then(function (response) {\n        console.log(response);\n    })\n    .catch(function (error) {\n        console.log(error);\n    });\n```\n\n3. 执行多个并发请求\n\n```\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    //两个请求现已完成\n  }));\n```\n\n\n更多可参考：\nhttps://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/\n","source":"_posts/axios常用攻略.md","raw":"title: axios常用攻略\ndate: 2018/06/14\ncategories: 库/框架\ntags:\n  - axios\ntoc: true\n---\n\n\n\n### 安装\nnpm install axios\n\n**axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。**\n\n<!--more-->\n\n### 常见用法\n\n1. 执行get请求\n\n```\n        // 向具有指定ID的用户发出请求\n        axios.get('/user?ID=12345')\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n\n\n\n        // 也可以通过 params 对象传递参数\n        axios.get('/user', {\n            params: {\n            ID: 12345\n            }\n        })\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n```\n\n2. 执行post请求\n\n```\n    axios.post('/user', {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    })\n    .then(function (response) {\n        console.log(response);\n    })\n    .catch(function (error) {\n        console.log(error);\n    });\n```\n\n3. 执行多个并发请求\n\n```\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    //两个请求现已完成\n  }));\n```\n\n\n更多可参考：\nhttps://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/\n","slug":"axios常用攻略","published":1,"updated":"2018-06-14T15:04:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxn001e7q0t9l9tiq07","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>npm install axios</p>\n<p><strong>axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。</strong></p>\n<a id=\"more\"></a>\n<h3 id=\"常见用法\"><a href=\"#常见用法\" class=\"headerlink\" title=\"常见用法\"></a>常见用法</h3><ol>\n<li>执行get请求</li>\n</ol>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向具有指定ID的用户发出请求</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以通过 params 对象传递参数</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">    ID: <span class=\"number\">12345</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>执行post请求</li>\n</ol>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>执行多个并发请求</li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAccount</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">axios.get('/user/12345')</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">axios.get('/user/12345/permissions')</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.<span class=\"keyword\">all</span>([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(axios.spread(<span class=\"keyword\">function</span> <span class=\"title\"></span>(acct, perms) &#123;</span><br><span class=\"line\">    //两个请求现已完成</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure>\n<p>更多可参考：<br><a href=\"https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/\" target=\"_blank\" rel=\"noopener\">https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>npm install axios</p>\n<p><strong>axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。</strong></p>","more":"<h3 id=\"常见用法\"><a href=\"#常见用法\" class=\"headerlink\" title=\"常见用法\"></a>常见用法</h3><ol>\n<li>执行get请求</li>\n</ol>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向具有指定ID的用户发出请求</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以通过 params 对象传递参数</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">    ID: <span class=\"number\">12345</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>执行post请求</li>\n</ol>\n<figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Flintstone'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> &#123;</span></span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>执行多个并发请求</li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAccount</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">axios.get('/user/12345')</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">axios.get('/user/12345/permissions')</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.<span class=\"keyword\">all</span>([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .<span class=\"keyword\">then</span>(axios.spread(<span class=\"keyword\">function</span> <span class=\"title\"></span>(acct, perms) &#123;</span><br><span class=\"line\">    //两个请求现已完成</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure>\n<p>更多可参考：<br><a href=\"https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/\" target=\"_blank\" rel=\"noopener\">https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/</a></p>"},{"title":"chrome原生input框的自动补全如何关闭？","date":"2018-08-19T16:00:00.000Z","_content":"\n在input框中进行第二次输入时，会自动出现以前填写过的信息下拉autocomplete，然而用在 **输入验证码的输入框的场景** 下时，由于验证码两次肯定不会重复，\n应该关掉改功能。\n<!--more-->\n\n可以使用 autocomplete = \"off\" 来进行取消。\n\n提示项被选中时，背景会变成黄色，使用\n```CSS\ninput:-webkit-autofill{\n -webkit-box-shadow:inset 0 0 0 1000px #fff;\nbackground-color:transpatent;\n}\n```\n可以修成白色。\n\n参考：\nhttp://www.w3school.com.cn/tiy/t.asp?f=html5_input_autocomplete\n","source":"_posts/chrome原生input框的自动补全如何关闭？.md","raw":"title: chrome原生input框的自动补全如何关闭？\ndate: 2018/08/20\ncategories:\n  - 十万个为什么\ntags:\n  - HTML\n---\n\n在input框中进行第二次输入时，会自动出现以前填写过的信息下拉autocomplete，然而用在 **输入验证码的输入框的场景** 下时，由于验证码两次肯定不会重复，\n应该关掉改功能。\n<!--more-->\n\n可以使用 autocomplete = \"off\" 来进行取消。\n\n提示项被选中时，背景会变成黄色，使用\n```CSS\ninput:-webkit-autofill{\n -webkit-box-shadow:inset 0 0 0 1000px #fff;\nbackground-color:transpatent;\n}\n```\n可以修成白色。\n\n参考：\nhttp://www.w3school.com.cn/tiy/t.asp?f=html5_input_autocomplete\n","slug":"chrome原生input框的自动补全如何关闭？","published":1,"updated":"2018-08-20T00:15:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxp001i7q0t59m5oc0s","content":"<p>在input框中进行第二次输入时，会自动出现以前填写过的信息下拉autocomplete，然而用在 <strong>输入验证码的输入框的场景</strong> 下时，由于验证码两次肯定不会重复，<br>应该关掉改功能。<br><a id=\"more\"></a></p>\n<p>可以使用 autocomplete = “off” 来进行取消。</p>\n<p>提示项被选中时，背景会变成黄色，使用<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:-webkit-autofill</span>&#123;</span><br><span class=\"line\"> <span class=\"attribute\">-webkit-box-shadow</span>:inset <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1000px</span> <span class=\"number\">#fff</span>;</span><br><span class=\"line\"><span class=\"attribute\">background-color</span>:transpatent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以修成白色。</p>\n<p>参考：<br><a href=\"http://www.w3school.com.cn/tiy/t.asp?f=html5_input_autocomplete\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/tiy/t.asp?f=html5_input_autocomplete</a></p>\n","site":{"data":{}},"excerpt":"<p>在input框中进行第二次输入时，会自动出现以前填写过的信息下拉autocomplete，然而用在 <strong>输入验证码的输入框的场景</strong> 下时，由于验证码两次肯定不会重复，<br>应该关掉改功能。<br>","more":"</p>\n<p>可以使用 autocomplete = “off” 来进行取消。</p>\n<p>提示项被选中时，背景会变成黄色，使用<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:-webkit-autofill</span>&#123;</span><br><span class=\"line\"> <span class=\"attribute\">-webkit-box-shadow</span>:inset <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1000px</span> <span class=\"number\">#fff</span>;</span><br><span class=\"line\"><span class=\"attribute\">background-color</span>:transpatent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以修成白色。</p>\n<p>参考：<br><a href=\"http://www.w3school.com.cn/tiy/t.asp?f=html5_input_autocomplete\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/tiy/t.asp?f=html5_input_autocomplete</a></p>"},{"title":"curl命令是怎么使用的？","date":"2018-07-20T16:00:00.000Z","_content":"\n在了解http请求的过程中，发现除了可以通过chrome控制台调试工具，也可以直接在mac(内置Linux)命令行中，使用curl命令,并且在很多命令行操作中，会返回curl的报错提示，已经错误码。\n\n经了解，curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是 综合传输工具 ，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。\n\n\n语法：\n\n```\ncurl(选项)(参数)\n```\n\n功能强大，不过目前比较常用的是 只打印响应头部信息 的功能，**通过-I或者-head可以只打印出HTTP头部信息**,来快速分析常见的http请求头\n\n![curl --head xxx](https://raw.githubusercontent.com/shengyur/Images/master/curl.jpg)\n\n\n原文：\n[curl命令们](http://man.linuxde.net/curl)\n[curl文档](https://curl.haxx.se/docs/manpage.html)\n","source":"_posts/curl命令怎么使用的？.md","raw":"title: curl命令是怎么使用的？\ndate: 2018/07/21\ncategories:\n  - 十万个为什么\ntags:\n  - HTTP\n---\n\n在了解http请求的过程中，发现除了可以通过chrome控制台调试工具，也可以直接在mac(内置Linux)命令行中，使用curl命令,并且在很多命令行操作中，会返回curl的报错提示，已经错误码。\n\n经了解，curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是 综合传输工具 ，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。\n\n\n语法：\n\n```\ncurl(选项)(参数)\n```\n\n功能强大，不过目前比较常用的是 只打印响应头部信息 的功能，**通过-I或者-head可以只打印出HTTP头部信息**,来快速分析常见的http请求头\n\n![curl --head xxx](https://raw.githubusercontent.com/shengyur/Images/master/curl.jpg)\n\n\n原文：\n[curl命令们](http://man.linuxde.net/curl)\n[curl文档](https://curl.haxx.se/docs/manpage.html)\n","slug":"curl命令怎么使用的？","published":1,"updated":"2018-07-26T14:52:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxq001l7q0tpchyngqd","content":"<p>在了解http请求的过程中，发现除了可以通过chrome控制台调试工具，也可以直接在mac(内置Linux)命令行中，使用curl命令,并且在很多命令行操作中，会返回curl的报错提示，已经错误码。</p>\n<p>经了解，curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是 综合传输工具 ，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。</p>\n<p>语法：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">curl</span><span class=\"params\">(选项)</span><span class=\"params\">(参数)</span></span></span><br></pre></td></tr></table></figure>\n<p>功能强大，不过目前比较常用的是 只打印响应头部信息 的功能，<strong>通过-I或者-head可以只打印出HTTP头部信息</strong>,来快速分析常见的http请求头</p>\n<p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/curl.jpg\" alt=\"curl --head xxx\"></p>\n<p>原文：<br><a href=\"http://man.linuxde.net/curl\" target=\"_blank\" rel=\"noopener\">curl命令们</a><br><a href=\"https://curl.haxx.se/docs/manpage.html\" target=\"_blank\" rel=\"noopener\">curl文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在了解http请求的过程中，发现除了可以通过chrome控制台调试工具，也可以直接在mac(内置Linux)命令行中，使用curl命令,并且在很多命令行操作中，会返回curl的报错提示，已经错误码。</p>\n<p>经了解，curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是 综合传输工具 ，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。</p>\n<p>语法：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">curl</span><span class=\"params\">(选项)</span><span class=\"params\">(参数)</span></span></span><br></pre></td></tr></table></figure>\n<p>功能强大，不过目前比较常用的是 只打印响应头部信息 的功能，<strong>通过-I或者-head可以只打印出HTTP头部信息</strong>,来快速分析常见的http请求头</p>\n<p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/curl.jpg\" alt=\"curl --head xxx\"></p>\n<p>原文：<br><a href=\"http://man.linuxde.net/curl\" target=\"_blank\" rel=\"noopener\">curl命令们</a><br><a href=\"https://curl.haxx.se/docs/manpage.html\" target=\"_blank\" rel=\"noopener\">curl文档</a></p>\n"},{"title":"git常用基本命令","date":"2018-04-16T16:00:00.000Z","_content":"\n### 必须记住的六条命令\n1. cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。\n2. git status .：查看当前路径下的的状态。git下最最常用的一个命令。\n3. git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。\n4. git commit -m \"提交时说明信息\": 更进一步提交，并说明提交log。\n5. git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)\n6. git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)\n<!--more-->\n### 当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\n1. 建立git仓库\ncd到你的本地项目根目录下，执行git命令，此命令会在当前目录下创建一个.git文件夹。\ngit init\n\n2. 将项目的所有文件添加到仓库中\ngit add .\n这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可\n\n3. 将add的文件commit到仓库\ngit commit -m \"注释语句\"\n\n4. 去github上创建自己的Repository，点击NewRepository。\n点击Create repository，拿到创建的仓库的https地址\n\n5. 将本地的仓库关联到github上\ngit remote add origin https://自己的仓库url地址\n\n6. 上传代码到github远程仓库\ngit push -u origin master\n\n7. 执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了.\n\n### git如何全局设置用户名及邮箱：\ngit config user.name \"Your Name\"\ngit config user.email you@example.com\n\n### 当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:\n1. git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可）\n2. git commit -m \"提交时说明信息\"\n3. git push\n4. 当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull\n\n### 这三条命令建议记住\n1. git log:查看提交历史，与各次的提交说明。\n2. git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。\n3. git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。\n\n### 其他问题\n- 操作时 双击tab键的自动提示/补全功能。\n- q或者:q等命令代表退出(quit)。\n- ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页\n\n# 正文部分\n\n## 理解几个概念\n工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.\n\n*服务器*:概念已经清楚了。叫做 中央服务器/远程服务器都行。\n*工作区*:就是你电脑的工作目录\n*版本库*:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。\n\n## 为什么存在一个 版本库？\n我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。\n\n## .gitignore文件是干啥的?\n工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。\n\n## .gitignore文件的使用\n```\n1）/mtk/               过滤整个文件夹\n2）*.zip                过滤所有.zip文件\n3）/mtk/do.c         过滤某个具体文件\n```\n被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。\n需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：\n```\n1）!*.zip\n2）!/mtk/one.txt\n```\n唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。\n为什么要有两种规则呢？想象一个场景： **假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理** ，那么我们就需要使用：\n```\n1）/mtk/\n2）!/mtk/one.txt\n```\n假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！\n\n配置语法：\n以斜杠“/”开头表示目录；\n以星号通配多个字符；\n以问号“?”通配单个字符\n以方括号“[]”包含单个字符的匹配列表；\n以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；\n\n### 待补充\ngit config 文件配置项\n\n- 参考：\n- 小白教程：https://www.cnblogs.com/yaoxiaowen/p/8227873.html\n- 秒秒钟入门markdown语法：https://www.jianshu.com/p/q81RER\n- Git忽略规则.gitignore梳理:https://www.cnblogs.com/kevingrace/p/5690241.html\n- 王老师的博客:https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\n- git config https://blog.csdn.net/gaochenchen/article/details/76187480\n","source":"_posts/git常用基本命令.md","raw":"title: git常用基本命令\ndate: 2018/4/17\ncategories: 效率工具\ntags:\n  - git\n---\n\n### 必须记住的六条命令\n1. cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。\n2. git status .：查看当前路径下的的状态。git下最最常用的一个命令。\n3. git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。\n4. git commit -m \"提交时说明信息\": 更进一步提交，并说明提交log。\n5. git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)\n6. git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)\n<!--more-->\n### 当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\n1. 建立git仓库\ncd到你的本地项目根目录下，执行git命令，此命令会在当前目录下创建一个.git文件夹。\ngit init\n\n2. 将项目的所有文件添加到仓库中\ngit add .\n这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可\n\n3. 将add的文件commit到仓库\ngit commit -m \"注释语句\"\n\n4. 去github上创建自己的Repository，点击NewRepository。\n点击Create repository，拿到创建的仓库的https地址\n\n5. 将本地的仓库关联到github上\ngit remote add origin https://自己的仓库url地址\n\n6. 上传代码到github远程仓库\ngit push -u origin master\n\n7. 执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了.\n\n### git如何全局设置用户名及邮箱：\ngit config user.name \"Your Name\"\ngit config user.email you@example.com\n\n### 当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:\n1. git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可）\n2. git commit -m \"提交时说明信息\"\n3. git push\n4. 当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull\n\n### 这三条命令建议记住\n1. git log:查看提交历史，与各次的提交说明。\n2. git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。\n3. git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。\n\n### 其他问题\n- 操作时 双击tab键的自动提示/补全功能。\n- q或者:q等命令代表退出(quit)。\n- ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页\n\n# 正文部分\n\n## 理解几个概念\n工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.\n\n*服务器*:概念已经清楚了。叫做 中央服务器/远程服务器都行。\n*工作区*:就是你电脑的工作目录\n*版本库*:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。\n\n## 为什么存在一个 版本库？\n我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。\n\n## .gitignore文件是干啥的?\n工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。\n\n## .gitignore文件的使用\n```\n1）/mtk/               过滤整个文件夹\n2）*.zip                过滤所有.zip文件\n3）/mtk/do.c         过滤某个具体文件\n```\n被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。\n需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：\n```\n1）!*.zip\n2）!/mtk/one.txt\n```\n唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。\n为什么要有两种规则呢？想象一个场景： **假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理** ，那么我们就需要使用：\n```\n1）/mtk/\n2）!/mtk/one.txt\n```\n假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！\n\n配置语法：\n以斜杠“/”开头表示目录；\n以星号通配多个字符；\n以问号“?”通配单个字符\n以方括号“[]”包含单个字符的匹配列表；\n以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；\n\n### 待补充\ngit config 文件配置项\n\n- 参考：\n- 小白教程：https://www.cnblogs.com/yaoxiaowen/p/8227873.html\n- 秒秒钟入门markdown语法：https://www.jianshu.com/p/q81RER\n- Git忽略规则.gitignore梳理:https://www.cnblogs.com/kevingrace/p/5690241.html\n- 王老师的博客:https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\n- git config https://blog.csdn.net/gaochenchen/article/details/76187480\n","slug":"git常用基本命令","published":1,"updated":"2018-07-09T15:57:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxt001p7q0ta9y7tqeb","content":"<h3 id=\"必须记住的六条命令\"><a href=\"#必须记住的六条命令\" class=\"headerlink\" title=\"必须记住的六条命令\"></a>必须记住的六条命令</h3><ol>\n<li>cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。</li>\n<li>git status .：查看当前路径下的的状态。git下最最常用的一个命令。</li>\n<li>git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。</li>\n<li>git commit -m “提交时说明信息”: 更进一步提交，并说明提交log。</li>\n<li>git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)</li>\n<li>git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)<a id=\"more\"></a>\n<h3 id=\"当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\"><a href=\"#当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\" class=\"headerlink\" title=\"当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\"></a>当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：</h3></li>\n<li><p>建立git仓库<br>cd到你的本地项目根目录下，执行git命令，此命令会在当前目录下创建一个.git文件夹。<br>git init</p>\n</li>\n<li><p>将项目的所有文件添加到仓库中<br>git add .<br>这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可</p>\n</li>\n<li><p>将add的文件commit到仓库<br>git commit -m “注释语句”</p>\n</li>\n<li><p>去github上创建自己的Repository，点击NewRepository。<br>点击Create repository，拿到创建的仓库的https地址</p>\n</li>\n<li><p>将本地的仓库关联到github上<br>git remote add origin https://自己的仓库url地址</p>\n</li>\n<li><p>上传代码到github远程仓库<br>git push -u origin master</p>\n</li>\n<li><p>执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了.</p>\n</li>\n</ol>\n<h3 id=\"git如何全局设置用户名及邮箱：\"><a href=\"#git如何全局设置用户名及邮箱：\" class=\"headerlink\" title=\"git如何全局设置用户名及邮箱：\"></a>git如何全局设置用户名及邮箱：</h3><p>git config user.name “Your Name”<br>git config user.email <a href=\"mailto:you@example.com\" target=\"_blank\" rel=\"noopener\">you@example.com</a></p>\n<h3 id=\"当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下\"><a href=\"#当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下\" class=\"headerlink\" title=\"当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:\"></a>当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:</h3><ol>\n<li>git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可）</li>\n<li>git commit -m “提交时说明信息”</li>\n<li>git push</li>\n<li>当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull</li>\n</ol>\n<h3 id=\"这三条命令建议记住\"><a href=\"#这三条命令建议记住\" class=\"headerlink\" title=\"这三条命令建议记住\"></a>这三条命令建议记住</h3><ol>\n<li>git log:查看提交历史，与各次的提交说明。</li>\n<li>git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。</li>\n<li>git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。</li>\n</ol>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><ul>\n<li>操作时 双击tab键的自动提示/补全功能。</li>\n<li>q或者:q等命令代表退出(quit)。</li>\n<li>ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页</li>\n</ul>\n<h1 id=\"正文部分\"><a href=\"#正文部分\" class=\"headerlink\" title=\"正文部分\"></a>正文部分</h1><h2 id=\"理解几个概念\"><a href=\"#理解几个概念\" class=\"headerlink\" title=\"理解几个概念\"></a>理解几个概念</h2><p>工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.</p>\n<p><em>服务器</em>:概念已经清楚了。叫做 中央服务器/远程服务器都行。<br><em>工作区</em>:就是你电脑的工作目录<br><em>版本库</em>:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。</p>\n<h2 id=\"为什么存在一个-版本库？\"><a href=\"#为什么存在一个-版本库？\" class=\"headerlink\" title=\"为什么存在一个 版本库？\"></a>为什么存在一个 版本库？</h2><p>我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。</p>\n<h2 id=\"gitignore文件是干啥的\"><a href=\"#gitignore文件是干啥的\" class=\"headerlink\" title=\".gitignore文件是干啥的?\"></a>.gitignore文件是干啥的?</h2><p>工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。</p>\n<h2 id=\"gitignore文件的使用\"><a href=\"#gitignore文件的使用\" class=\"headerlink\" title=\".gitignore文件的使用\"></a>.gitignore文件的使用</h2><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）<span class=\"string\">/mtk/</span>               过滤整个文件夹</span><br><span class=\"line\">2）*<span class=\"string\">.zip</span>                过滤所有<span class=\"string\">.zip</span>文件</span><br><span class=\"line\">3）<span class=\"string\">/mtk/do.c</span>         过滤某个具体文件</span><br></pre></td></tr></table></figure>\n<p>被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。<br>需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：<br><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）!*.zip</span><br><span class=\"line\"><span class=\"number\">2</span>）!/mtk/one.txt</span><br></pre></td></tr></table></figure></p>\n<p>唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。<br>为什么要有两种规则呢？想象一个场景： <strong>假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理</strong> ，那么我们就需要使用：<br><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）<span class=\"regexp\">/mtk/</span></span><br><span class=\"line\"><span class=\"number\">2</span>）!<span class=\"regexp\">/mtk/</span>one.txt</span><br></pre></td></tr></table></figure></p>\n<p>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</p>\n<p>配置语法：<br>以斜杠“/”开头表示目录；<br>以星号通配多个字符；<br>以问号“?”通配单个字符<br>以方括号“[]”包含单个字符的匹配列表；<br>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</p>\n<h3 id=\"待补充\"><a href=\"#待补充\" class=\"headerlink\" title=\"待补充\"></a>待补充</h3><p>git config 文件配置项</p>\n<ul>\n<li>参考：</li>\n<li>小白教程：<a href=\"https://www.cnblogs.com/yaoxiaowen/p/8227873.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yaoxiaowen/p/8227873.html</a></li>\n<li>秒秒钟入门markdown语法：<a href=\"https://www.jianshu.com/p/q81RER\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/q81RER</a></li>\n<li>Git忽略规则.gitignore梳理:<a href=\"https://www.cnblogs.com/kevingrace/p/5690241.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kevingrace/p/5690241.html</a></li>\n<li>王老师的博客:<a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\" target=\"_blank\" rel=\"noopener\">https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md</a></li>\n<li>git config <a href=\"https://blog.csdn.net/gaochenchen/article/details/76187480\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gaochenchen/article/details/76187480</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"必须记住的六条命令\"><a href=\"#必须记住的六条命令\" class=\"headerlink\" title=\"必须记住的六条命令\"></a>必须记住的六条命令</h3><ol>\n<li>cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。</li>\n<li>git status .：查看当前路径下的的状态。git下最最常用的一个命令。</li>\n<li>git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。</li>\n<li>git commit -m “提交时说明信息”: 更进一步提交，并说明提交log。</li>\n<li>git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)</li>\n<li>git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)","more":"<h3 id=\"当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\"><a href=\"#当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\" class=\"headerlink\" title=\"当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：\"></a>当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：</h3></li>\n<li><p>建立git仓库<br>cd到你的本地项目根目录下，执行git命令，此命令会在当前目录下创建一个.git文件夹。<br>git init</p>\n</li>\n<li><p>将项目的所有文件添加到仓库中<br>git add .<br>这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可</p>\n</li>\n<li><p>将add的文件commit到仓库<br>git commit -m “注释语句”</p>\n</li>\n<li><p>去github上创建自己的Repository，点击NewRepository。<br>点击Create repository，拿到创建的仓库的https地址</p>\n</li>\n<li><p>将本地的仓库关联到github上<br>git remote add origin https://自己的仓库url地址</p>\n</li>\n<li><p>上传代码到github远程仓库<br>git push -u origin master</p>\n</li>\n<li><p>执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了.</p>\n</li>\n</ol>\n<h3 id=\"git如何全局设置用户名及邮箱：\"><a href=\"#git如何全局设置用户名及邮箱：\" class=\"headerlink\" title=\"git如何全局设置用户名及邮箱：\"></a>git如何全局设置用户名及邮箱：</h3><p>git config user.name “Your Name”<br>git config user.email <a href=\"mailto:you@example.com\" target=\"_blank\" rel=\"noopener\">you@example.com</a></p>\n<h3 id=\"当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下\"><a href=\"#当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下\" class=\"headerlink\" title=\"当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:\"></a>当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:</h3><ol>\n<li>git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可）</li>\n<li>git commit -m “提交时说明信息”</li>\n<li>git push</li>\n<li>当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull</li>\n</ol>\n<h3 id=\"这三条命令建议记住\"><a href=\"#这三条命令建议记住\" class=\"headerlink\" title=\"这三条命令建议记住\"></a>这三条命令建议记住</h3><ol>\n<li>git log:查看提交历史，与各次的提交说明。</li>\n<li>git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。</li>\n<li>git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。</li>\n</ol>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><ul>\n<li>操作时 双击tab键的自动提示/补全功能。</li>\n<li>q或者:q等命令代表退出(quit)。</li>\n<li>ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页</li>\n</ul>\n<h1 id=\"正文部分\"><a href=\"#正文部分\" class=\"headerlink\" title=\"正文部分\"></a>正文部分</h1><h2 id=\"理解几个概念\"><a href=\"#理解几个概念\" class=\"headerlink\" title=\"理解几个概念\"></a>理解几个概念</h2><p>工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.</p>\n<p><em>服务器</em>:概念已经清楚了。叫做 中央服务器/远程服务器都行。<br><em>工作区</em>:就是你电脑的工作目录<br><em>版本库</em>:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。</p>\n<h2 id=\"为什么存在一个-版本库？\"><a href=\"#为什么存在一个-版本库？\" class=\"headerlink\" title=\"为什么存在一个 版本库？\"></a>为什么存在一个 版本库？</h2><p>我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。</p>\n<h2 id=\"gitignore文件是干啥的\"><a href=\"#gitignore文件是干啥的\" class=\"headerlink\" title=\".gitignore文件是干啥的?\"></a>.gitignore文件是干啥的?</h2><p>工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。</p>\n<h2 id=\"gitignore文件的使用\"><a href=\"#gitignore文件的使用\" class=\"headerlink\" title=\".gitignore文件的使用\"></a>.gitignore文件的使用</h2><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）<span class=\"string\">/mtk/</span>               过滤整个文件夹</span><br><span class=\"line\">2）*<span class=\"string\">.zip</span>                过滤所有<span class=\"string\">.zip</span>文件</span><br><span class=\"line\">3）<span class=\"string\">/mtk/do.c</span>         过滤某个具体文件</span><br></pre></td></tr></table></figure>\n<p>被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。<br>需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：<br><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）!*.zip</span><br><span class=\"line\"><span class=\"number\">2</span>）!/mtk/one.txt</span><br></pre></td></tr></table></figure></p>\n<p>唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。<br>为什么要有两种规则呢？想象一个场景： <strong>假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理</strong> ，那么我们就需要使用：<br><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）<span class=\"regexp\">/mtk/</span></span><br><span class=\"line\"><span class=\"number\">2</span>）!<span class=\"regexp\">/mtk/</span>one.txt</span><br></pre></td></tr></table></figure></p>\n<p>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</p>\n<p>配置语法：<br>以斜杠“/”开头表示目录；<br>以星号通配多个字符；<br>以问号“?”通配单个字符<br>以方括号“[]”包含单个字符的匹配列表；<br>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</p>\n<h3 id=\"待补充\"><a href=\"#待补充\" class=\"headerlink\" title=\"待补充\"></a>待补充</h3><p>git config 文件配置项</p>\n<ul>\n<li>参考：</li>\n<li>小白教程：<a href=\"https://www.cnblogs.com/yaoxiaowen/p/8227873.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yaoxiaowen/p/8227873.html</a></li>\n<li>秒秒钟入门markdown语法：<a href=\"https://www.jianshu.com/p/q81RER\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/q81RER</a></li>\n<li>Git忽略规则.gitignore梳理:<a href=\"https://www.cnblogs.com/kevingrace/p/5690241.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kevingrace/p/5690241.html</a></li>\n<li>王老师的博客:<a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\" target=\"_blank\" rel=\"noopener\">https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md</a></li>\n<li>git config <a href=\"https://blog.csdn.net/gaochenchen/article/details/76187480\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gaochenchen/article/details/76187480</a></li>\n</ul>"},{"title":"git菜鸟踩坑日常","date":"2018-06-19T16:00:00.000Z","_content":"\n在工作中使用的代码管理工具之前一直是svn，最近接触了几个使用git管理代码的项目，记录下踩坑日常，避免重蹈覆辙~\n<!--more-->\n\n### 权限已经开，但是git clone提示找不到该路径?\n1. 首先，确定权限已经是开好\n2. 回忆了一下公司的代码仓库，猜测可能是用户名与自己本地默认的自己github的账号密码不一样\n3. 查看当前用户的配置\n```\ngit config --global  --list\n```\n4. 发现显示的用户名果然与公司的域账号用户名密码不一致，每次拉代码也没让输用户名密码，怕不是默认记住密码了？？?\n```\ngit config --system --list\n```\n- 查看系统config文件中，对是否记住密码的配置，果然有记住密码的配置\n```\ncredential helper== credential helper\n```\n5. 清除保存的用户名密码\n```\ngit credential-manager delete\n\n或者\n\ngit credential-manager remove [--path <installion_path>] [--passive] [--force]   //停止使用管理工具[中括号选填]\n```\n6. 重新拉取代码，提示输入用户名密码，切换账户后问题解决\n\n### git clone 默认的是master分支，如何切换到branch分支？\n\ngit初始化一般是这样。\n```\ngit init\n\ngit clone .git地址\n```\n之后重点来了，因为clone下来的一般为master分支，有可能不是想拉下来的分支。可以使用以下的方法\n```\ngit branch -a 先查看当前远端分支情况\n\ngit  checkout origin/xxx  选择远端xxx分支\n\ngit branch xxx  创建本地xxx分支\n\ngit checkout xxx  选择新创建的分支就可以了。\n```\n当然还有更简单的方法。\n```\n直接指定clone某个分支即可：\n\ngit clone -b xxx .git地址\n```\n\n\n### tuniu内部的代码npm install报错？\n\n先安装[cnpm](https://www.npmjs.com/package/cnpm)：\n ```\n npm i cnpm -g\n ```\n 设置公司内部镜像：\n ```\n cnpm set registry http://10.40.189.154:7001\n```\n不报错的话，就设置好了，使用命令检查一下：\n```\ncnpm config get registry //看下是否返回 http://10.40.189.154:7001\n```\n是的话,再\n```\ncnpm i\n```\n安装依赖就行了。\n\n\n\n参考：\nhttps://segmentfault.com/q/1010000007962678\nhttps://blog.csdn.net/yun__yang/article/details/74466059\n","source":"_posts/git踩坑小记录.md","raw":"title: git菜鸟踩坑日常\ndate: 2018/06/20\ncategories: 效率工具\ntags:\n  - git\n---\n\n在工作中使用的代码管理工具之前一直是svn，最近接触了几个使用git管理代码的项目，记录下踩坑日常，避免重蹈覆辙~\n<!--more-->\n\n### 权限已经开，但是git clone提示找不到该路径?\n1. 首先，确定权限已经是开好\n2. 回忆了一下公司的代码仓库，猜测可能是用户名与自己本地默认的自己github的账号密码不一样\n3. 查看当前用户的配置\n```\ngit config --global  --list\n```\n4. 发现显示的用户名果然与公司的域账号用户名密码不一致，每次拉代码也没让输用户名密码，怕不是默认记住密码了？？?\n```\ngit config --system --list\n```\n- 查看系统config文件中，对是否记住密码的配置，果然有记住密码的配置\n```\ncredential helper== credential helper\n```\n5. 清除保存的用户名密码\n```\ngit credential-manager delete\n\n或者\n\ngit credential-manager remove [--path <installion_path>] [--passive] [--force]   //停止使用管理工具[中括号选填]\n```\n6. 重新拉取代码，提示输入用户名密码，切换账户后问题解决\n\n### git clone 默认的是master分支，如何切换到branch分支？\n\ngit初始化一般是这样。\n```\ngit init\n\ngit clone .git地址\n```\n之后重点来了，因为clone下来的一般为master分支，有可能不是想拉下来的分支。可以使用以下的方法\n```\ngit branch -a 先查看当前远端分支情况\n\ngit  checkout origin/xxx  选择远端xxx分支\n\ngit branch xxx  创建本地xxx分支\n\ngit checkout xxx  选择新创建的分支就可以了。\n```\n当然还有更简单的方法。\n```\n直接指定clone某个分支即可：\n\ngit clone -b xxx .git地址\n```\n\n\n### tuniu内部的代码npm install报错？\n\n先安装[cnpm](https://www.npmjs.com/package/cnpm)：\n ```\n npm i cnpm -g\n ```\n 设置公司内部镜像：\n ```\n cnpm set registry http://10.40.189.154:7001\n```\n不报错的话，就设置好了，使用命令检查一下：\n```\ncnpm config get registry //看下是否返回 http://10.40.189.154:7001\n```\n是的话,再\n```\ncnpm i\n```\n安装依赖就行了。\n\n\n\n参考：\nhttps://segmentfault.com/q/1010000007962678\nhttps://blog.csdn.net/yun__yang/article/details/74466059\n","slug":"git踩坑小记录","published":1,"updated":"2018-07-18T17:33:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxv001s7q0ts8ukj2sq","content":"<p>在工作中使用的代码管理工具之前一直是svn，最近接触了几个使用git管理代码的项目，记录下踩坑日常，避免重蹈覆辙~<br><a id=\"more\"></a></p>\n<h3 id=\"权限已经开，但是git-clone提示找不到该路径\"><a href=\"#权限已经开，但是git-clone提示找不到该路径\" class=\"headerlink\" title=\"权限已经开，但是git clone提示找不到该路径?\"></a>权限已经开，但是git clone提示找不到该路径?</h3><ol>\n<li>首先，确定权限已经是开好</li>\n<li>回忆了一下公司的代码仓库，猜测可能是用户名与自己本地默认的自己github的账号密码不一样</li>\n<li><p>查看当前用户的配置</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--global  --list</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发现显示的用户名果然与公司的域账号用户名密码不一致，每次拉代码也没让输用户名密码，怕不是默认记住密码了？？?</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--system --list</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>查看系统config文件中，对是否记住密码的配置，果然有记住密码的配置<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">credential <span class=\"keyword\">helper</span>== credential <span class=\"keyword\">helper</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>清除保存的用户名密码</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git credential-manager delete</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"></span><br><span class=\"line\">git credential-manager remove <span class=\"string\">[--path &lt;installion_path&gt;]</span> <span class=\"string\">[--passive]</span> <span class=\"string\">[--force]</span>   //停止使用管理工具<span class=\"string\">[中括号选填]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新拉取代码，提示输入用户名密码，切换账户后问题解决</p>\n</li>\n</ol>\n<h3 id=\"git-clone-默认的是master分支，如何切换到branch分支？\"><a href=\"#git-clone-默认的是master分支，如何切换到branch分支？\" class=\"headerlink\" title=\"git clone 默认的是master分支，如何切换到branch分支？\"></a>git clone 默认的是master分支，如何切换到branch分支？</h3><p>git初始化一般是这样。<br><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">clone</span> <span class=\"title\">.git</span>地址</span><br></pre></td></tr></table></figure></p>\n<p>之后重点来了，因为clone下来的一般为master分支，有可能不是想拉下来的分支。可以使用以下的方法<br><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">branch </span>-a 先查看当前远端分支情况</span><br><span class=\"line\"></span><br><span class=\"line\">git  checkout <span class=\"keyword\">origin/xxx </span> 选择远端xxx分支</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">branch </span>xxx  创建本地xxx分支</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout xxx  选择新创建的分支就可以了。</span><br></pre></td></tr></table></figure></p>\n<p>当然还有更简单的方法。<br><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">直接指定clone某个分支即可：</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">clone</span> <span class=\"title\">-b</span> xxx .git地址</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"tuniu内部的代码npm-install报错？\"><a href=\"#tuniu内部的代码npm-install报错？\" class=\"headerlink\" title=\"tuniu内部的代码npm install报错？\"></a>tuniu内部的代码npm install报错？</h3><p>先安装<a href=\"https://www.npmjs.com/package/cnpm\" target=\"_blank\" rel=\"noopener\">cnpm</a>：<br> <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"selector-tag\">i</span> cnpm -g</span><br></pre></td></tr></table></figure></p>\n<p> 设置公司内部镜像：<br> <figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm <span class=\"keyword\">set</span> registry <span class=\"comment\">http:</span>//<span class=\"comment\">10.40.189.154:7001</span></span><br></pre></td></tr></table></figure></p>\n<p>不报错的话，就设置好了，使用命令检查一下：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm <span class=\"built_in\">config</span> <span class=\"built_in\">get</span> registry <span class=\"comment\">//看下是否返回 http://10.40.189.154:7001</span></span><br></pre></td></tr></table></figure></p>\n<p>是的话,再<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">cnpm i</span></span><br></pre></td></tr></table></figure></p>\n<p>安装依赖就行了。</p>\n<p>参考：<br><a href=\"https://segmentfault.com/q/1010000007962678\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000007962678</a><br><a href=\"https://blog.csdn.net/yun__yang/article/details/74466059\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yun__yang/article/details/74466059</a></p>\n","site":{"data":{}},"excerpt":"<p>在工作中使用的代码管理工具之前一直是svn，最近接触了几个使用git管理代码的项目，记录下踩坑日常，避免重蹈覆辙~<br>","more":"</p>\n<h3 id=\"权限已经开，但是git-clone提示找不到该路径\"><a href=\"#权限已经开，但是git-clone提示找不到该路径\" class=\"headerlink\" title=\"权限已经开，但是git clone提示找不到该路径?\"></a>权限已经开，但是git clone提示找不到该路径?</h3><ol>\n<li>首先，确定权限已经是开好</li>\n<li>回忆了一下公司的代码仓库，猜测可能是用户名与自己本地默认的自己github的账号密码不一样</li>\n<li><p>查看当前用户的配置</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--global  --list</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发现显示的用户名果然与公司的域账号用户名密码不一致，每次拉代码也没让输用户名密码，怕不是默认记住密码了？？?</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--system --list</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>查看系统config文件中，对是否记住密码的配置，果然有记住密码的配置<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">credential <span class=\"keyword\">helper</span>== credential <span class=\"keyword\">helper</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>清除保存的用户名密码</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git credential-manager delete</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"></span><br><span class=\"line\">git credential-manager remove <span class=\"string\">[--path &lt;installion_path&gt;]</span> <span class=\"string\">[--passive]</span> <span class=\"string\">[--force]</span>   //停止使用管理工具<span class=\"string\">[中括号选填]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新拉取代码，提示输入用户名密码，切换账户后问题解决</p>\n</li>\n</ol>\n<h3 id=\"git-clone-默认的是master分支，如何切换到branch分支？\"><a href=\"#git-clone-默认的是master分支，如何切换到branch分支？\" class=\"headerlink\" title=\"git clone 默认的是master分支，如何切换到branch分支？\"></a>git clone 默认的是master分支，如何切换到branch分支？</h3><p>git初始化一般是这样。<br><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">clone</span> <span class=\"title\">.git</span>地址</span><br></pre></td></tr></table></figure></p>\n<p>之后重点来了，因为clone下来的一般为master分支，有可能不是想拉下来的分支。可以使用以下的方法<br><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">branch </span>-a 先查看当前远端分支情况</span><br><span class=\"line\"></span><br><span class=\"line\">git  checkout <span class=\"keyword\">origin/xxx </span> 选择远端xxx分支</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">branch </span>xxx  创建本地xxx分支</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout xxx  选择新创建的分支就可以了。</span><br></pre></td></tr></table></figure></p>\n<p>当然还有更简单的方法。<br><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">直接指定clone某个分支即可：</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">clone</span> <span class=\"title\">-b</span> xxx .git地址</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"tuniu内部的代码npm-install报错？\"><a href=\"#tuniu内部的代码npm-install报错？\" class=\"headerlink\" title=\"tuniu内部的代码npm install报错？\"></a>tuniu内部的代码npm install报错？</h3><p>先安装<a href=\"https://www.npmjs.com/package/cnpm\" target=\"_blank\" rel=\"noopener\">cnpm</a>：<br> <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"selector-tag\">i</span> cnpm -g</span><br></pre></td></tr></table></figure></p>\n<p> 设置公司内部镜像：<br> <figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm <span class=\"keyword\">set</span> registry <span class=\"comment\">http:</span>//<span class=\"comment\">10.40.189.154:7001</span></span><br></pre></td></tr></table></figure></p>\n<p>不报错的话，就设置好了，使用命令检查一下：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm <span class=\"built_in\">config</span> <span class=\"built_in\">get</span> registry <span class=\"comment\">//看下是否返回 http://10.40.189.154:7001</span></span><br></pre></td></tr></table></figure></p>\n<p>是的话,再<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">cnpm i</span></span><br></pre></td></tr></table></figure></p>\n<p>安装依赖就行了。</p>\n<p>参考：<br><a href=\"https://segmentfault.com/q/1010000007962678\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000007962678</a><br><a href=\"https://blog.csdn.net/yun__yang/article/details/74466059\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yun__yang/article/details/74466059</a></p>"},{"title":"Github+Hexo+Maupassant 搭建个人博客教程","date":"2018-04-17T16:00:00.000Z","toc":true,"_content":"\n![](http://7xqdjc.com1.z0.glb.clouddn.com/blog_c2a91a3b4a43d03bf967dda7c7425506.png)\n\n\n\n<!--more-->\n### 安装Node.js\n    用来生成静态页面。移步Node.js官网\n### 安装hexo\n    mac下输入以下命令安装:\n```\nsudo npm install -g hexo\n```\n#### *避坑指南*\n- 输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)\n- Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。\n\n\n### 初始化\n    终端cd到一个你选定的目录，执行hexo init命令：\n```\nhexo init blog\n```\n    blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：\n```\nnpm install\n```\n    执行如下命令,**开启hexo服务器**\n```\nhexo s\n```\n此时，浏览器中打开网址[http://localhost:4000](http://localhost:4000)，能看到如下页面：\n![HEXO初始化](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png)\n至此，跟新博客的本地环境就搭好了！\n\n### 关联Github\n- 创建仓库\n    登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg)\n\n    本地的blog文件夹下内容为：\n\n```\n_config.yml\ndb.json\nnode_modules\npackage.json\nscaffolds\nsource\nthemes\n```\n\n- 终端cd到blog文件夹下，打开_config.yml，命令如下：\n\n```\nopen _config.yml\n```\n\n- 查看文件最后，修改deploy为：\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/shengyur/shengyur.github.io.git\n  branch: master\n```\n- 然后将repo后面的地址中的 shengyur 换成你自己的用户名\n\n#### *避坑指南二*\n在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。\n在blog文件夹目录下执行**生成静态页面命令**：\n```\nhexo generate     简写：hexo g  \n```\n此时若出现如下报错：\n\n```\nERROR Local hexo not found in ~/blog\nERROR Try runing: 'npm install hexo --save'\n```\n\n则执行命令：\n\n```\nnpm install hexo --save\n```\n\n再执行**配置命令**：\n```\nhexo deploy       简写：hexo d\n```\n#### *避坑指南三*\n若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装[hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git)：\n\n\n```\nnpm install hexo-deployer-git --save      \n```\n\n再次执行hexo generate和hexo deploy命令。\n若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即\n\n```\nUsername for 'https://github.com':\nPassword for 'https://github.com':\n```\n\nhexo deploy命令执行成功后，浏览器中打开网址[http://shengyur.github.io](http://shengyur.github.io),\n将shengyur换成你的用户名,就能能看到和打开 [http://localhost:4000](http://localhost:4000) 时一样的页面了。\n\n### 添加ssh key到Github\n#### 检查SSH keys是否存在Github\n执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。\n\n```\nls -al ~/.ssh\n```\n\n#### 生成新的ssh key\n执行如下命令生成public/private rsa key pair，注意将your_email@example.com换成你自己注册Github的邮箱地址。\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。\n\n#### 将ssh key添加到Github中\n- Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。\n\n- 进入Github --> Settings --> SSH keys --> add SSH key:\n\n- Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。\n\n### 发布文章\n终端cd到blog文件夹下，执行如下命令**新建文章**：\n\n```\nhexo new \"postName\"\n```\n\n名为postName.md的文件会建在目录 /blog/source/\\_posts 下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。\n文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：\n\n```\nhexo generate                 //生成静态页面\n\nhexo deploy                   //将文章部署到Github\n```\n\n至此，Mac上搭建基于Github的Hexo博客就大功告成了！\n\n### 跟换博客主题\n如果不喜欢官网默认主题的话，以到[Hexo官网主题页](https://hexo.io/themes/)去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~\n\n\n\n参考：\n- https://blog.csdn.net/yanzi1225627/article/details/54566792\n- https://www.jianshu.com/p/13e64c9e2295\n","source":"_posts/hexo+github+Maupassant搭建博客.md","raw":"title: Github+Hexo+Maupassant 搭建个人博客教程\ndate: 2018/4/18\ncategories: 效率工具\ntoc: true\ntags:\n  - Hexo\n---\n\n![](http://7xqdjc.com1.z0.glb.clouddn.com/blog_c2a91a3b4a43d03bf967dda7c7425506.png)\n\n\n\n<!--more-->\n### 安装Node.js\n    用来生成静态页面。移步Node.js官网\n### 安装hexo\n    mac下输入以下命令安装:\n```\nsudo npm install -g hexo\n```\n#### *避坑指南*\n- 输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)\n- Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。\n\n\n### 初始化\n    终端cd到一个你选定的目录，执行hexo init命令：\n```\nhexo init blog\n```\n    blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：\n```\nnpm install\n```\n    执行如下命令,**开启hexo服务器**\n```\nhexo s\n```\n此时，浏览器中打开网址[http://localhost:4000](http://localhost:4000)，能看到如下页面：\n![HEXO初始化](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png)\n至此，跟新博客的本地环境就搭好了！\n\n### 关联Github\n- 创建仓库\n    登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg)\n\n    本地的blog文件夹下内容为：\n\n```\n_config.yml\ndb.json\nnode_modules\npackage.json\nscaffolds\nsource\nthemes\n```\n\n- 终端cd到blog文件夹下，打开_config.yml，命令如下：\n\n```\nopen _config.yml\n```\n\n- 查看文件最后，修改deploy为：\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/shengyur/shengyur.github.io.git\n  branch: master\n```\n- 然后将repo后面的地址中的 shengyur 换成你自己的用户名\n\n#### *避坑指南二*\n在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。\n在blog文件夹目录下执行**生成静态页面命令**：\n```\nhexo generate     简写：hexo g  \n```\n此时若出现如下报错：\n\n```\nERROR Local hexo not found in ~/blog\nERROR Try runing: 'npm install hexo --save'\n```\n\n则执行命令：\n\n```\nnpm install hexo --save\n```\n\n再执行**配置命令**：\n```\nhexo deploy       简写：hexo d\n```\n#### *避坑指南三*\n若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装[hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git)：\n\n\n```\nnpm install hexo-deployer-git --save      \n```\n\n再次执行hexo generate和hexo deploy命令。\n若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即\n\n```\nUsername for 'https://github.com':\nPassword for 'https://github.com':\n```\n\nhexo deploy命令执行成功后，浏览器中打开网址[http://shengyur.github.io](http://shengyur.github.io),\n将shengyur换成你的用户名,就能能看到和打开 [http://localhost:4000](http://localhost:4000) 时一样的页面了。\n\n### 添加ssh key到Github\n#### 检查SSH keys是否存在Github\n执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。\n\n```\nls -al ~/.ssh\n```\n\n#### 生成新的ssh key\n执行如下命令生成public/private rsa key pair，注意将your_email@example.com换成你自己注册Github的邮箱地址。\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。\n\n#### 将ssh key添加到Github中\n- Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。\n\n- 进入Github --> Settings --> SSH keys --> add SSH key:\n\n- Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。\n\n### 发布文章\n终端cd到blog文件夹下，执行如下命令**新建文章**：\n\n```\nhexo new \"postName\"\n```\n\n名为postName.md的文件会建在目录 /blog/source/\\_posts 下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。\n文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：\n\n```\nhexo generate                 //生成静态页面\n\nhexo deploy                   //将文章部署到Github\n```\n\n至此，Mac上搭建基于Github的Hexo博客就大功告成了！\n\n### 跟换博客主题\n如果不喜欢官网默认主题的话，以到[Hexo官网主题页](https://hexo.io/themes/)去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~\n\n\n\n参考：\n- https://blog.csdn.net/yanzi1225627/article/details/54566792\n- https://www.jianshu.com/p/13e64c9e2295\n","slug":"hexo+github+Maupassant搭建博客","published":1,"updated":"2018-08-20T00:26:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxx001x7q0te3pwx02a","content":"<p><img src=\"http://7xqdjc.com1.z0.glb.clouddn.com/blog_c2a91a3b4a43d03bf967dda7c7425506.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><pre><code>用来生成静态页面。移步Node.js官网\n</code></pre><h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><pre><code>mac下输入以下命令安装:\n</code></pre><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm <span class=\"keyword\">install</span> -g hexo</span><br></pre></td></tr></table></figure>\n<h4 id=\"避坑指南\"><a href=\"#避坑指南\" class=\"headerlink\" title=\"避坑指南\"></a><em>避坑指南</em></h4><ul>\n<li>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)</li>\n<li>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。</li>\n</ul>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><pre><code>终端cd到一个你选定的目录，执行hexo init命令：\n</code></pre><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo init blog</span></span><br></pre></td></tr></table></figure>\n<pre><code>blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：\n</code></pre><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span></span><br></pre></td></tr></table></figure>\n<pre><code>执行如下命令,**开启hexo服务器**\n</code></pre><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo s</span></span><br></pre></td></tr></table></figure>\n<p>此时，浏览器中打开网址<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a>，能看到如下页面：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png\" alt=\"HEXO初始化\"><br>至此，跟新博客的本地环境就搭好了！</p>\n<h3 id=\"关联Github\"><a href=\"#关联Github\" class=\"headerlink\" title=\"关联Github\"></a>关联Github</h3><ul>\n<li><p>创建仓库<br>  登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg\" alt=\"\"></p>\n<p>  本地的blog文件夹下内容为：</p>\n</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml</span><br><span class=\"line\">db.json</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">package.json</span><br><span class=\"line\">scaffolds</span><br><span class=\"line\">source</span><br><span class=\"line\">themes</span><br></pre></td></tr></table></figure>\n<ul>\n<li>终端cd到blog文件夹下，打开_config.yml，命令如下：</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">open</span> _config.yml</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看文件最后，修改deploy为：</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/shengyur/shengyur.github.io.git</span></span><br><span class=\"line\">  <span class=\"attribute\">branch</span>: master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>然后将repo后面的地址中的 shengyur 换成你自己的用户名</li>\n</ul>\n<h4 id=\"避坑指南二\"><a href=\"#避坑指南二\" class=\"headerlink\" title=\"避坑指南二\"></a><em>避坑指南二</em></h4><p>在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。<br>在blog文件夹目录下执行<strong>生成静态页面命令</strong>：<br><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">generate</span>     简写：hexo g</span><br></pre></td></tr></table></figure></p>\n<p>此时若出现如下报错：</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ERROR </span>Local hexo not found in ~/blog</span><br><span class=\"line\"><span class=\"keyword\">ERROR </span>Try runing: 'npm install hexo --save'</span><br></pre></td></tr></table></figure>\n<p>则执行命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> hexo <span class=\"comment\">--save</span></span><br></pre></td></tr></table></figure>\n<p>再执行<strong>配置命令</strong>：<br><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">deploy</span>       简写：hexo d</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"避坑指南三\"><a href=\"#避坑指南三\" class=\"headerlink\" title=\"避坑指南三\"></a><em>避坑指南三</em></h4><p>若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装<a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"noopener\">hexo-deployer-git</a>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> hexo-deployer-git <span class=\"comment\">--save</span></span><br></pre></td></tr></table></figure>\n<p>再次执行hexo generate和hexo deploy命令。<br>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Username <span class=\"keyword\">for</span> <span class=\"symbol\">'https</span>:<span class=\"comment\">//github.com':</span></span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"symbol\">'https</span>:<span class=\"comment\">//github.com':</span></span><br></pre></td></tr></table></figure>\n<p>hexo deploy命令执行成功后，浏览器中打开网址<a href=\"http://shengyur.github.io\" target=\"_blank\" rel=\"noopener\">http://shengyur.github.io</a>,<br>将shengyur换成你的用户名,就能能看到和打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 时一样的页面了。</p>\n<h3 id=\"添加ssh-key到Github\"><a href=\"#添加ssh-key到Github\" class=\"headerlink\" title=\"添加ssh key到Github\"></a>添加ssh key到Github</h3><h4 id=\"检查SSH-keys是否存在Github\"><a href=\"#检查SSH-keys是否存在Github\" class=\"headerlink\" title=\"检查SSH keys是否存在Github\"></a>检查SSH keys是否存在Github</h4><p>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ls</span> -al ~<span class=\"string\">/.ssh</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"生成新的ssh-key\"><a href=\"#生成新的ssh-key\" class=\"headerlink\" title=\"生成新的ssh key\"></a>生成新的ssh key</h4><p>执行如下命令生成public/private rsa key pair，注意将<a href=\"mailto:your_email@example.com\" target=\"_blank\" rel=\"noopener\">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ssh-keygen</span> <span class=\"selector-tag\">-t</span> <span class=\"selector-tag\">rsa</span> <span class=\"selector-tag\">-C</span> \"<span class=\"selector-tag\">your_email</span>@<span class=\"keyword\">example</span>.<span class=\"keyword\">com</span>\"</span><br></pre></td></tr></table></figure>\n<p>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。</p>\n<h4 id=\"将ssh-key添加到Github中\"><a href=\"#将ssh-key添加到Github中\" class=\"headerlink\" title=\"将ssh key添加到Github中\"></a>将ssh key添加到Github中</h4><ul>\n<li><p>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p>\n</li>\n<li><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p>\n</li>\n<li><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p>\n</li>\n</ul>\n<h3 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h3><p>终端cd到blog文件夹下，执行如下命令<strong>新建文章</strong>：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> <span class=\"string\">\"postName\"</span></span><br></pre></td></tr></table></figure>\n<p>名为postName.md的文件会建在目录 /blog/source/_posts 下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。<br>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">generate</span>                 <span class=\"comment\">//生成静态页面</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo deploy                   <span class=\"comment\">//将文章部署到Github</span></span><br></pre></td></tr></table></figure>\n<p>至此，Mac上搭建基于Github的Hexo博客就大功告成了！</p>\n<h3 id=\"跟换博客主题\"><a href=\"#跟换博客主题\" class=\"headerlink\" title=\"跟换博客主题\"></a>跟换博客主题</h3><p>如果不喜欢官网默认主题的话，以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo官网主题页</a>去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanzi1225627/article/details/54566792\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yanzi1225627/article/details/54566792</a></li>\n<li><a href=\"https://www.jianshu.com/p/13e64c9e2295\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/13e64c9e2295</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://7xqdjc.com1.z0.glb.clouddn.com/blog_c2a91a3b4a43d03bf967dda7c7425506.png\" alt=\"\"></p>","more":"<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><pre><code>用来生成静态页面。移步Node.js官网\n</code></pre><h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><pre><code>mac下输入以下命令安装:\n</code></pre><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm <span class=\"keyword\">install</span> -g hexo</span><br></pre></td></tr></table></figure>\n<h4 id=\"避坑指南\"><a href=\"#避坑指南\" class=\"headerlink\" title=\"避坑指南\"></a><em>避坑指南</em></h4><ul>\n<li>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)</li>\n<li>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。</li>\n</ul>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><pre><code>终端cd到一个你选定的目录，执行hexo init命令：\n</code></pre><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo init blog</span></span><br></pre></td></tr></table></figure>\n<pre><code>blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：\n</code></pre><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span></span><br></pre></td></tr></table></figure>\n<pre><code>执行如下命令,**开启hexo服务器**\n</code></pre><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo s</span></span><br></pre></td></tr></table></figure>\n<p>此时，浏览器中打开网址<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a>，能看到如下页面：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png\" alt=\"HEXO初始化\"><br>至此，跟新博客的本地环境就搭好了！</p>\n<h3 id=\"关联Github\"><a href=\"#关联Github\" class=\"headerlink\" title=\"关联Github\"></a>关联Github</h3><ul>\n<li><p>创建仓库<br>  登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg\" alt=\"\"></p>\n<p>  本地的blog文件夹下内容为：</p>\n</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml</span><br><span class=\"line\">db.json</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">package.json</span><br><span class=\"line\">scaffolds</span><br><span class=\"line\">source</span><br><span class=\"line\">themes</span><br></pre></td></tr></table></figure>\n<ul>\n<li>终端cd到blog文件夹下，打开_config.yml，命令如下：</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">open</span> _config.yml</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看文件最后，修改deploy为：</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/shengyur/shengyur.github.io.git</span></span><br><span class=\"line\">  <span class=\"attribute\">branch</span>: master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>然后将repo后面的地址中的 shengyur 换成你自己的用户名</li>\n</ul>\n<h4 id=\"避坑指南二\"><a href=\"#避坑指南二\" class=\"headerlink\" title=\"避坑指南二\"></a><em>避坑指南二</em></h4><p>在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。<br>在blog文件夹目录下执行<strong>生成静态页面命令</strong>：<br><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">generate</span>     简写：hexo g</span><br></pre></td></tr></table></figure></p>\n<p>此时若出现如下报错：</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ERROR </span>Local hexo not found in ~/blog</span><br><span class=\"line\"><span class=\"keyword\">ERROR </span>Try runing: 'npm install hexo --save'</span><br></pre></td></tr></table></figure>\n<p>则执行命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> hexo <span class=\"comment\">--save</span></span><br></pre></td></tr></table></figure>\n<p>再执行<strong>配置命令</strong>：<br><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">deploy</span>       简写：hexo d</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"避坑指南三\"><a href=\"#避坑指南三\" class=\"headerlink\" title=\"避坑指南三\"></a><em>避坑指南三</em></h4><p>若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装<a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"noopener\">hexo-deployer-git</a>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> hexo-deployer-git <span class=\"comment\">--save</span></span><br></pre></td></tr></table></figure>\n<p>再次执行hexo generate和hexo deploy命令。<br>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Username <span class=\"keyword\">for</span> <span class=\"symbol\">'https</span>:<span class=\"comment\">//github.com':</span></span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"symbol\">'https</span>:<span class=\"comment\">//github.com':</span></span><br></pre></td></tr></table></figure>\n<p>hexo deploy命令执行成功后，浏览器中打开网址<a href=\"http://shengyur.github.io\" target=\"_blank\" rel=\"noopener\">http://shengyur.github.io</a>,<br>将shengyur换成你的用户名,就能能看到和打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 时一样的页面了。</p>\n<h3 id=\"添加ssh-key到Github\"><a href=\"#添加ssh-key到Github\" class=\"headerlink\" title=\"添加ssh key到Github\"></a>添加ssh key到Github</h3><h4 id=\"检查SSH-keys是否存在Github\"><a href=\"#检查SSH-keys是否存在Github\" class=\"headerlink\" title=\"检查SSH keys是否存在Github\"></a>检查SSH keys是否存在Github</h4><p>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ls</span> -al ~<span class=\"string\">/.ssh</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"生成新的ssh-key\"><a href=\"#生成新的ssh-key\" class=\"headerlink\" title=\"生成新的ssh key\"></a>生成新的ssh key</h4><p>执行如下命令生成public/private rsa key pair，注意将<a href=\"mailto:your_email@example.com\" target=\"_blank\" rel=\"noopener\">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ssh-keygen</span> <span class=\"selector-tag\">-t</span> <span class=\"selector-tag\">rsa</span> <span class=\"selector-tag\">-C</span> \"<span class=\"selector-tag\">your_email</span>@<span class=\"keyword\">example</span>.<span class=\"keyword\">com</span>\"</span><br></pre></td></tr></table></figure>\n<p>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。</p>\n<h4 id=\"将ssh-key添加到Github中\"><a href=\"#将ssh-key添加到Github中\" class=\"headerlink\" title=\"将ssh key添加到Github中\"></a>将ssh key添加到Github中</h4><ul>\n<li><p>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p>\n</li>\n<li><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p>\n</li>\n<li><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p>\n</li>\n</ul>\n<h3 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h3><p>终端cd到blog文件夹下，执行如下命令<strong>新建文章</strong>：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> <span class=\"string\">\"postName\"</span></span><br></pre></td></tr></table></figure>\n<p>名为postName.md的文件会建在目录 /blog/source/_posts 下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。<br>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">generate</span>                 <span class=\"comment\">//生成静态页面</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo deploy                   <span class=\"comment\">//将文章部署到Github</span></span><br></pre></td></tr></table></figure>\n<p>至此，Mac上搭建基于Github的Hexo博客就大功告成了！</p>\n<h3 id=\"跟换博客主题\"><a href=\"#跟换博客主题\" class=\"headerlink\" title=\"跟换博客主题\"></a>跟换博客主题</h3><p>如果不喜欢官网默认主题的话，以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo官网主题页</a>去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanzi1225627/article/details/54566792\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yanzi1225627/article/details/54566792</a></li>\n<li><a href=\"https://www.jianshu.com/p/13e64c9e2295\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/13e64c9e2295</a></li>\n</ul>"},{"title":"jquery源码解析01——总体架构","date":"2018-04-26T16:00:00.000Z","_content":"\n## jquery1.7.1源码的总体结构：\n```\n(function( window , undefined ){\n//构造jQuery对象\nvar  jQuery =  (function(){\nvar jQuery =  function (  selector,  context ){\nreturn new jQuery.fn.init(selector,context,rootjQuery);\n}\nreturn jQuery;\n})();\n//工具方法：Utilities\n//回调函数列表：Callbacks  Object\n//异步队列：Deferred  Object\n//浏览器功能测试：Support\n//数据缓存：DataS\n//队列：Queue\n//属性操作：Attributes\n//事件系统：Events\n//选择器：Sizzle\n//DOM遍历：Traversing\n//DOM操作：Manipulation\n//样式操作 css  (计算样式、内联样式)\n//异步请求：Ajax\n//动画： Effects\n//坐标：Offset、尺寸 Dimensions\nwindow.jQuery =  window.$  =  jQuery;\n})(window);\n```\n\n### 为什么要创建一个自调用匿名函数？\n因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突\n\n### 匿名函数自调有几种不同的写法？\n```\n1.（function(){\n//...\n})();\n```\n```\n2: (function(){\n//...\n}());\n```\n```\n3:\t!function(){\n//...\n}();\n```\n\n### 为什么匿名函数自调 要在在前面加！？\n匿名函数自调叫做**立即调用的函数表达式**更为贴切,直接执行,会报错(语法错误SyntaxError)\n语法错误的两种原因：\n- function (){ }()\n期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称\n-  function g(){ }()\n期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。\n所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。\n执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。\n<br>\n注意：\n圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数\n\n### 为什么要自调用匿名函数设置参数window，并传入window对象？\n- 通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，\n从而可以更快的访问window对象\n- 将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现\n(function(a,b){.......})(window)参数window被压缩成a,参数undefined被压缩成b\n\n### 为什么要自调用匿名函数并设置参数undefined？\n- undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链\n- 在压缩代码时可以进行优化\n- 重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值\n\n\n### 为什么匿名函数最后或者最开始要加分号？\n- 因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用\n","source":"_posts/jquery源码解读01-总体架构.md","raw":"title: jquery源码解析01——总体架构\ndate: 2018/4/27\ncategories: 源码浅析\ntags:\n  - jQuery源码\n---\n\n## jquery1.7.1源码的总体结构：\n```\n(function( window , undefined ){\n//构造jQuery对象\nvar  jQuery =  (function(){\nvar jQuery =  function (  selector,  context ){\nreturn new jQuery.fn.init(selector,context,rootjQuery);\n}\nreturn jQuery;\n})();\n//工具方法：Utilities\n//回调函数列表：Callbacks  Object\n//异步队列：Deferred  Object\n//浏览器功能测试：Support\n//数据缓存：DataS\n//队列：Queue\n//属性操作：Attributes\n//事件系统：Events\n//选择器：Sizzle\n//DOM遍历：Traversing\n//DOM操作：Manipulation\n//样式操作 css  (计算样式、内联样式)\n//异步请求：Ajax\n//动画： Effects\n//坐标：Offset、尺寸 Dimensions\nwindow.jQuery =  window.$  =  jQuery;\n})(window);\n```\n\n### 为什么要创建一个自调用匿名函数？\n因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突\n\n### 匿名函数自调有几种不同的写法？\n```\n1.（function(){\n//...\n})();\n```\n```\n2: (function(){\n//...\n}());\n```\n```\n3:\t!function(){\n//...\n}();\n```\n\n### 为什么匿名函数自调 要在在前面加！？\n匿名函数自调叫做**立即调用的函数表达式**更为贴切,直接执行,会报错(语法错误SyntaxError)\n语法错误的两种原因：\n- function (){ }()\n期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称\n-  function g(){ }()\n期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。\n所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。\n执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。\n<br>\n注意：\n圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数\n\n### 为什么要自调用匿名函数设置参数window，并传入window对象？\n- 通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，\n从而可以更快的访问window对象\n- 将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现\n(function(a,b){.......})(window)参数window被压缩成a,参数undefined被压缩成b\n\n### 为什么要自调用匿名函数并设置参数undefined？\n- undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链\n- 在压缩代码时可以进行优化\n- 重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值\n\n\n### 为什么匿名函数最后或者最开始要加分号？\n- 因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用\n","slug":"jquery源码解读01-总体架构","published":1,"updated":"2018-05-02T14:01:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uxy00207q0tme8ei5an","content":"<h2 id=\"jquery1-7-1源码的总体结构：\"><a href=\"#jquery1-7-1源码的总体结构：\" class=\"headerlink\" title=\"jquery1.7.1源码的总体结构：\"></a>jquery1.7.1源码的总体结构：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window , undefined </span>)</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//构造jQuery对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>  jQuery =  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jQuery =  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">  selector,  context </span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> jQuery.fn.init(selector,context,rootjQuery);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> jQuery;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">//工具方法：Utilities</span></span><br><span class=\"line\"><span class=\"comment\">//回调函数列表：Callbacks  Object</span></span><br><span class=\"line\"><span class=\"comment\">//异步队列：Deferred  Object</span></span><br><span class=\"line\"><span class=\"comment\">//浏览器功能测试：Support</span></span><br><span class=\"line\"><span class=\"comment\">//数据缓存：DataS</span></span><br><span class=\"line\"><span class=\"comment\">//队列：Queue</span></span><br><span class=\"line\"><span class=\"comment\">//属性操作：Attributes</span></span><br><span class=\"line\"><span class=\"comment\">//事件系统：Events</span></span><br><span class=\"line\"><span class=\"comment\">//选择器：Sizzle</span></span><br><span class=\"line\"><span class=\"comment\">//DOM遍历：Traversing</span></span><br><span class=\"line\"><span class=\"comment\">//DOM操作：Manipulation</span></span><br><span class=\"line\"><span class=\"comment\">//样式操作 css  (计算样式、内联样式)</span></span><br><span class=\"line\"><span class=\"comment\">//异步请求：Ajax</span></span><br><span class=\"line\"><span class=\"comment\">//动画： Effects</span></span><br><span class=\"line\"><span class=\"comment\">//坐标：Offset、尺寸 Dimensions</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.jQuery =  <span class=\"built_in\">window</span>.$  =  jQuery;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么要创建一个自调用匿名函数？\"><a href=\"#为什么要创建一个自调用匿名函数？\" class=\"headerlink\" title=\"为什么要创建一个自调用匿名函数？\"></a>为什么要创建一个自调用匿名函数？</h3><p>因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突</p>\n<h3 id=\"匿名函数自调有几种不同的写法？\"><a href=\"#匿名函数自调有几种不同的写法？\" class=\"headerlink\" title=\"匿名函数自调有几种不同的写法？\"></a>匿名函数自调有几种不同的写法？</h3><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>（<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>: (<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span>:\t!<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;();</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么匿名函数自调-要在在前面加！？\"><a href=\"#为什么匿名函数自调-要在在前面加！？\" class=\"headerlink\" title=\"为什么匿名函数自调 要在在前面加！？\"></a>为什么匿名函数自调 要在在前面加！？</h3><p>匿名函数自调叫做<strong>立即调用的函数表达式</strong>更为贴切,直接执行,会报错(语法错误SyntaxError)<br>语法错误的两种原因：</p>\n<ul>\n<li>function (){ }()<br>期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称</li>\n<li>function g(){ }()<br>期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。<br>所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。<br>执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。<br><br><br>注意：<br>圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数</li>\n</ul>\n<h3 id=\"为什么要自调用匿名函数设置参数window，并传入window对象？\"><a href=\"#为什么要自调用匿名函数设置参数window，并传入window对象？\" class=\"headerlink\" title=\"为什么要自调用匿名函数设置参数window，并传入window对象？\"></a>为什么要自调用匿名函数设置参数window，并传入window对象？</h3><ul>\n<li>通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，<br>从而可以更快的访问window对象</li>\n<li>将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现<br>(function(a,b){…….})(window)参数window被压缩成a,参数undefined被压缩成b</li>\n</ul>\n<h3 id=\"为什么要自调用匿名函数并设置参数undefined？\"><a href=\"#为什么要自调用匿名函数并设置参数undefined？\" class=\"headerlink\" title=\"为什么要自调用匿名函数并设置参数undefined？\"></a>为什么要自调用匿名函数并设置参数undefined？</h3><ul>\n<li>undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链</li>\n<li>在压缩代码时可以进行优化</li>\n<li>重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值</li>\n</ul>\n<h3 id=\"为什么匿名函数最后或者最开始要加分号？\"><a href=\"#为什么匿名函数最后或者最开始要加分号？\" class=\"headerlink\" title=\"为什么匿名函数最后或者最开始要加分号？\"></a>为什么匿名函数最后或者最开始要加分号？</h3><ul>\n<li>因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"jquery1-7-1源码的总体结构：\"><a href=\"#jquery1-7-1源码的总体结构：\" class=\"headerlink\" title=\"jquery1.7.1源码的总体结构：\"></a>jquery1.7.1源码的总体结构：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> window , undefined </span>)</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//构造jQuery对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>  jQuery =  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jQuery =  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">  selector,  context </span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> jQuery.fn.init(selector,context,rootjQuery);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> jQuery;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">//工具方法：Utilities</span></span><br><span class=\"line\"><span class=\"comment\">//回调函数列表：Callbacks  Object</span></span><br><span class=\"line\"><span class=\"comment\">//异步队列：Deferred  Object</span></span><br><span class=\"line\"><span class=\"comment\">//浏览器功能测试：Support</span></span><br><span class=\"line\"><span class=\"comment\">//数据缓存：DataS</span></span><br><span class=\"line\"><span class=\"comment\">//队列：Queue</span></span><br><span class=\"line\"><span class=\"comment\">//属性操作：Attributes</span></span><br><span class=\"line\"><span class=\"comment\">//事件系统：Events</span></span><br><span class=\"line\"><span class=\"comment\">//选择器：Sizzle</span></span><br><span class=\"line\"><span class=\"comment\">//DOM遍历：Traversing</span></span><br><span class=\"line\"><span class=\"comment\">//DOM操作：Manipulation</span></span><br><span class=\"line\"><span class=\"comment\">//样式操作 css  (计算样式、内联样式)</span></span><br><span class=\"line\"><span class=\"comment\">//异步请求：Ajax</span></span><br><span class=\"line\"><span class=\"comment\">//动画： Effects</span></span><br><span class=\"line\"><span class=\"comment\">//坐标：Offset、尺寸 Dimensions</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.jQuery =  <span class=\"built_in\">window</span>.$  =  jQuery;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么要创建一个自调用匿名函数？\"><a href=\"#为什么要创建一个自调用匿名函数？\" class=\"headerlink\" title=\"为什么要创建一个自调用匿名函数？\"></a>为什么要创建一个自调用匿名函数？</h3><p>因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突</p>\n<h3 id=\"匿名函数自调有几种不同的写法？\"><a href=\"#匿名函数自调有几种不同的写法？\" class=\"headerlink\" title=\"匿名函数自调有几种不同的写法？\"></a>匿名函数自调有几种不同的写法？</h3><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>（<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>: (<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span>:\t!<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;();</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么匿名函数自调-要在在前面加！？\"><a href=\"#为什么匿名函数自调-要在在前面加！？\" class=\"headerlink\" title=\"为什么匿名函数自调 要在在前面加！？\"></a>为什么匿名函数自调 要在在前面加！？</h3><p>匿名函数自调叫做<strong>立即调用的函数表达式</strong>更为贴切,直接执行,会报错(语法错误SyntaxError)<br>语法错误的两种原因：</p>\n<ul>\n<li>function (){ }()<br>期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称</li>\n<li>function g(){ }()<br>期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。<br>所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。<br>执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。<br><br><br>注意：<br>圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数</li>\n</ul>\n<h3 id=\"为什么要自调用匿名函数设置参数window，并传入window对象？\"><a href=\"#为什么要自调用匿名函数设置参数window，并传入window对象？\" class=\"headerlink\" title=\"为什么要自调用匿名函数设置参数window，并传入window对象？\"></a>为什么要自调用匿名函数设置参数window，并传入window对象？</h3><ul>\n<li>通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，<br>从而可以更快的访问window对象</li>\n<li>将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现<br>(function(a,b){…….})(window)参数window被压缩成a,参数undefined被压缩成b</li>\n</ul>\n<h3 id=\"为什么要自调用匿名函数并设置参数undefined？\"><a href=\"#为什么要自调用匿名函数并设置参数undefined？\" class=\"headerlink\" title=\"为什么要自调用匿名函数并设置参数undefined？\"></a>为什么要自调用匿名函数并设置参数undefined？</h3><ul>\n<li>undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链</li>\n<li>在压缩代码时可以进行优化</li>\n<li>重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值</li>\n</ul>\n<h3 id=\"为什么匿名函数最后或者最开始要加分号？\"><a href=\"#为什么匿名函数最后或者最开始要加分号？\" class=\"headerlink\" title=\"为什么匿名函数最后或者最开始要加分号？\"></a>为什么匿名函数最后或者最开始要加分号？</h3><ul>\n<li>因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用</li>\n</ul>\n"},{"title":"less配合vscode使用的配置","date":"2018-05-04T16:00:00.000Z","_content":"\n使用场景：写jquery老项目懒得配置css预编译的情况下，安装即用，提升效率。\n\n1. 安装 easy less\n\n2. 安装Preview on web server\n\n3. 在.less 文件最后一行敲下回车，就可以实现编译main.less到main.css了。\n\n如果不生效，就试试下面这个：\n\n1. 安装less转码器\n```\nnpm install -g node-sass less\n```\n2. 在css文件下建个less文件（后缀名为less）\n\n3. Ctrl + Shift + P（配置任务运行器）\n选择Others\n替换内容为：\n```\n  1. // Less configuration\n  2. {\n  3. \"version\": \"0.1.0\",\n  4. \"command\": \"lessc\",\n  5. \"isShellCommand\": true,\n  6. \"args\": [\"css/名字.less\", \"css/名字.css\"]\n  7. }\n  8. }\n```\n","source":"_posts/less配合vscode使用的配置.md","raw":"title: less配合vscode使用的配置\ndate: 2018/05/05\ncategories: 效率工具\ntags:\n  - Less\n  - vscode\n---\n\n使用场景：写jquery老项目懒得配置css预编译的情况下，安装即用，提升效率。\n\n1. 安装 easy less\n\n2. 安装Preview on web server\n\n3. 在.less 文件最后一行敲下回车，就可以实现编译main.less到main.css了。\n\n如果不生效，就试试下面这个：\n\n1. 安装less转码器\n```\nnpm install -g node-sass less\n```\n2. 在css文件下建个less文件（后缀名为less）\n\n3. Ctrl + Shift + P（配置任务运行器）\n选择Others\n替换内容为：\n```\n  1. // Less configuration\n  2. {\n  3. \"version\": \"0.1.0\",\n  4. \"command\": \"lessc\",\n  5. \"isShellCommand\": true,\n  6. \"args\": [\"css/名字.less\", \"css/名字.css\"]\n  7. }\n  8. }\n```\n","slug":"less配合vscode使用的配置","published":1,"updated":"2018-05-26T14:33:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uy000237q0tiezgml2l","content":"<p>使用场景：写jquery老项目懒得配置css预编译的情况下，安装即用，提升效率。</p>\n<ol>\n<li><p>安装 easy less</p>\n</li>\n<li><p>安装Preview on web server</p>\n</li>\n<li><p>在.less 文件最后一行敲下回车，就可以实现编译main.less到main.css了。</p>\n</li>\n</ol>\n<p>如果不生效，就试试下面这个：</p>\n<ol>\n<li><p>安装less转码器</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g <span class=\"keyword\">node</span><span class=\"title\">-sass</span> less</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在css文件下建个less文件（后缀名为less）</p>\n</li>\n<li><p>Ctrl + Shift + P（配置任务运行器）<br>选择Others<br>替换内容为：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"comment\">// Less configuration</span></span><br><span class=\"line\"><span class=\"number\">2.</span> &#123;</span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.1.0\"</span>,</span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"string\">\"command\"</span>: <span class=\"string\">\"lessc\"</span>,</span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"string\">\"isShellCommand\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"number\">6.</span> <span class=\"string\">\"args\"</span>: [<span class=\"string\">\"css/名字.less\"</span>, <span class=\"string\">\"css/名字.css\"</span>]</span><br><span class=\"line\"><span class=\"number\">7.</span> &#125;</span><br><span class=\"line\"><span class=\"number\">8.</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>使用场景：写jquery老项目懒得配置css预编译的情况下，安装即用，提升效率。</p>\n<ol>\n<li><p>安装 easy less</p>\n</li>\n<li><p>安装Preview on web server</p>\n</li>\n<li><p>在.less 文件最后一行敲下回车，就可以实现编译main.less到main.css了。</p>\n</li>\n</ol>\n<p>如果不生效，就试试下面这个：</p>\n<ol>\n<li><p>安装less转码器</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g <span class=\"keyword\">node</span><span class=\"title\">-sass</span> less</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在css文件下建个less文件（后缀名为less）</p>\n</li>\n<li><p>Ctrl + Shift + P（配置任务运行器）<br>选择Others<br>替换内容为：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"comment\">// Less configuration</span></span><br><span class=\"line\"><span class=\"number\">2.</span> &#123;</span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.1.0\"</span>,</span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"string\">\"command\"</span>: <span class=\"string\">\"lessc\"</span>,</span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"string\">\"isShellCommand\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"number\">6.</span> <span class=\"string\">\"args\"</span>: [<span class=\"string\">\"css/名字.less\"</span>, <span class=\"string\">\"css/名字.css\"</span>]</span><br><span class=\"line\"><span class=\"number\">7.</span> &#125;</span><br><span class=\"line\"><span class=\"number\">8.</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"mock工具使用","date":"2018-06-13T16:00:00.000Z","toc":true,"_content":"\n\n## mock的基础解释\n### 目的\n  可以在不依赖后端环境的情况下，进行前端开发，帮助编写单元测试,减少联调成本，提高工作效率。\n\n### 实现功能\n  A.能渲染模板\n  B.实现请求路由映射\n  C.数据接口代理到生产或者测试环境\n\n<!--more-->\n### 常用方式\n  在开发过程中，模拟后台接口数据，快速地实现前端开发。\n\n## mock的用法\n### 安装\n```\n    npm install mockjs\n```\n### 使用mock\n```\n        var Mock = require('mockjs');\n        var mock = Mock.mock({\n            ......\n        })\n```\n### 语法\n\n mock的语法规范包含两层规范：数据模板（DTD）和数据占位符（DPD）。\n\n#### 数据模板DTD\n\n    A.模板规则：'name|rule':value\n```\n        其中，name:属性名； rule:属性规则；value：属性值。\n            属性名和规则之间用|隔开，规则是可以选的。\n```\n    B.7个rule\n    ```\n        'name|min-max':value\n        'name|count':value\n        'name|min-max.dmin-dmax':value\n        'name|min-max.dcount':value\n        'name|count.dmin-dmax':value\n        'name|count.dcount':value\n        'name|+step':value\n```\n\n**（1）生成规则需要根据属性值的类型才能确定（2）属性值可以含有@占位符（3）属性值可以指定最终值的初始值和类型**\n\n    C.属性值是String\n```\n        var data = Mock.mock({\n            'name1|1-3' : 'a', //重复生成1到3个a\n            'name2|2' : 'b' //生成bb\n        })\n```\n    D.属性值是Number\n```\n        var data = Mock.mock({\n            'name1|+1' : 4,  //生成4,如果循环每次加1\n            'name2|1-7' : 2, //生成一个数字，1到7之间\n            'name3|1-4.5-8' : 1  //生成一个小数，整数部分1到4，小数部分5到8位（！！！表示小数点之后的位数范围）\n        })\n```\n    E.属性值是Boolean\n```\n        var data = Mock.mock({\n            'name|1': true, //生成一个布尔值，各一半\n            'name1|1-3': true  // 1/4是true，3/4是false\n        })\n```\n    F.属性值是Object\n```\n        var obj = {\n            a:1,\n            b:2,\n            c:3,\n            d:4\n        }\n        var data = Mock.mock({\n            'name|1-3': obj,\n            'name|2': obj\n        })\n```\n\n    G.属性值是Array\n\n```\n        var arr = [1,2,3];\n        var data = Mock.mock({\n            'name1|1': arr, //从数组里随机取出1个值\n            'name2|2': arr, //数组重复count次，这里count为2\n            'name3|1-3': arr  //数组重复1到3次\n        })\n```\n    H.属性值是Function\n\n```\n        var fun = function(x){\n            return x+10;\n        }\n        var data = Mock.mock({\n            'name':fun(10)         //返回函数的返回值20\n        })\n```\n\n    I.属性值是RegExp\n        根据正则表达式反向生成对应的字符串，用于生成自定义格式的字符串\n```\n            var data = Mock.mock({\n                ‘name1':/[a-z][A-Z]/,\n                'name2':/\\d{1,3}/\n            })\n```\n        会根据各自的正则表达式进行适配，并且随机返回\n\n\n#### 数据占位符DPD\n\n关于占位符，占位符只是在属性值是字符串的时候，在字符串里占个位置，并不会出现在最终的属性值中。\n\n占位符的格式为：@占位符,关于占位符需要知道以下几点：\n\n- 用@标识符标识后面的字符串是占位符\n\n- 占位符的值是从Mock.Random方法中引用的\n\n- 可以通过Mock.Random.extend()来扩展自定义占位符\n\n- 占位符可以引用数据模板中的属性\n\n- 占位符优先引用数据模板中的属性\n\n- 占位符支持相对路径和决定路径\n```\n    var data = Mock.mock({\n        name:{\n            name1:'@FIRST',\n            name2:'@LAST'\n        }    \n    })\n```\n\n#### Mock.mock()\n\n- Mock.mock(rurl,rtype,template|function(opt))\n\n```\n    rurl: ajax请求的地址\n    rtype: ajax请求的类型，如’GET','POST'\n    template: 数据模板，就是之前那些个例子\n    function: 生成相应数据的函数\n```\n\n- 常用的方法\n\n```\n    A. Mock.mock(template)\n\n    B. Mock.mock(rurl,template)，模拟ajax,匹配接收到url的ajax请求，把template对应的数据返回返回\n\n    C. Mock.mock(rurl,function(opt)),模拟ajax,会把函数执行的结果作为ajax回调返回\n\n    D. Mock.mock(rurl,rtype,template) 同上，只是对ajax的类型有要求\n\n    E. Mock.mock(rurl,rtype,function) 同上\n```\n\n#### Mock.setup(setting)\n\n配置拦截ajax请求的行为，支持的配置项有timeout。\n\n```\n    Mock.setup({\n        timeout:200\n    })\n    Mock.setup({\n        timeout:'200-500\n    })\n```\n\n#### Mock.valid(template,data)\n\n这个函数用来判断，数据模板和数据是否一样。\n\n#### Mock.toJSONShema(template)\n\n```\n    var template = Mock.mock({\n        'name|1-3':5\n    })\n    var tjs = Mock.toJSONSchema(tempalte);\n```\n\n####  Mock.Random\n\n```\n    var Random = Mock.Random;\n    var em1 = Mock.email();\n    var em2 = Mock.mock('@email');\n    var em3 = Mock.mock({\n        email:'@email'\n    })\n```\n\n## mock的原理\n1. Mock主要是关于测被测体与外部的交互逻辑。一般是指在不同场景下多次的与外部交互。\n\n2. 当外部依赖是硬件，或者外部程序没有准备好的情况下，Mock就能帮助完成单元测试。\n\n3. Mock的作用就是能通过设置输入输出值，让被测代码的各种工作场景都可以被测试覆盖。\n\n4. 为方便测试，程序设计应该采用依赖倒置原则，让被测试类依赖于接口，Mock类实现该接口。\n\n**被测类通过调用接口最终调用到Mock类，完成测试。而被测试类可以不作任何修改就能在实际系统里工作。\n这就是使用TDD能很自然的使产品代码于外部依赖松耦合。**\n\n参考：\n- [王老师的总结](https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%85%B3%E4%BA%8Emock.md)\n- https://www.zhihu.com/question/35436669/answer/62753889\n- https://segmentfault.com/a/1190000010211622\n- [深入理解Mock工作原理](https://blog.csdn.net/ibelieve1974/article/details/55220015)\n","source":"_posts/mock工具使用.md","raw":"title: mock工具使用\ndate: 2018/06/14\ncategories: 效率工具\ntags:\n  - mock\ntoc: true\n---\n\n\n## mock的基础解释\n### 目的\n  可以在不依赖后端环境的情况下，进行前端开发，帮助编写单元测试,减少联调成本，提高工作效率。\n\n### 实现功能\n  A.能渲染模板\n  B.实现请求路由映射\n  C.数据接口代理到生产或者测试环境\n\n<!--more-->\n### 常用方式\n  在开发过程中，模拟后台接口数据，快速地实现前端开发。\n\n## mock的用法\n### 安装\n```\n    npm install mockjs\n```\n### 使用mock\n```\n        var Mock = require('mockjs');\n        var mock = Mock.mock({\n            ......\n        })\n```\n### 语法\n\n mock的语法规范包含两层规范：数据模板（DTD）和数据占位符（DPD）。\n\n#### 数据模板DTD\n\n    A.模板规则：'name|rule':value\n```\n        其中，name:属性名； rule:属性规则；value：属性值。\n            属性名和规则之间用|隔开，规则是可以选的。\n```\n    B.7个rule\n    ```\n        'name|min-max':value\n        'name|count':value\n        'name|min-max.dmin-dmax':value\n        'name|min-max.dcount':value\n        'name|count.dmin-dmax':value\n        'name|count.dcount':value\n        'name|+step':value\n```\n\n**（1）生成规则需要根据属性值的类型才能确定（2）属性值可以含有@占位符（3）属性值可以指定最终值的初始值和类型**\n\n    C.属性值是String\n```\n        var data = Mock.mock({\n            'name1|1-3' : 'a', //重复生成1到3个a\n            'name2|2' : 'b' //生成bb\n        })\n```\n    D.属性值是Number\n```\n        var data = Mock.mock({\n            'name1|+1' : 4,  //生成4,如果循环每次加1\n            'name2|1-7' : 2, //生成一个数字，1到7之间\n            'name3|1-4.5-8' : 1  //生成一个小数，整数部分1到4，小数部分5到8位（！！！表示小数点之后的位数范围）\n        })\n```\n    E.属性值是Boolean\n```\n        var data = Mock.mock({\n            'name|1': true, //生成一个布尔值，各一半\n            'name1|1-3': true  // 1/4是true，3/4是false\n        })\n```\n    F.属性值是Object\n```\n        var obj = {\n            a:1,\n            b:2,\n            c:3,\n            d:4\n        }\n        var data = Mock.mock({\n            'name|1-3': obj,\n            'name|2': obj\n        })\n```\n\n    G.属性值是Array\n\n```\n        var arr = [1,2,3];\n        var data = Mock.mock({\n            'name1|1': arr, //从数组里随机取出1个值\n            'name2|2': arr, //数组重复count次，这里count为2\n            'name3|1-3': arr  //数组重复1到3次\n        })\n```\n    H.属性值是Function\n\n```\n        var fun = function(x){\n            return x+10;\n        }\n        var data = Mock.mock({\n            'name':fun(10)         //返回函数的返回值20\n        })\n```\n\n    I.属性值是RegExp\n        根据正则表达式反向生成对应的字符串，用于生成自定义格式的字符串\n```\n            var data = Mock.mock({\n                ‘name1':/[a-z][A-Z]/,\n                'name2':/\\d{1,3}/\n            })\n```\n        会根据各自的正则表达式进行适配，并且随机返回\n\n\n#### 数据占位符DPD\n\n关于占位符，占位符只是在属性值是字符串的时候，在字符串里占个位置，并不会出现在最终的属性值中。\n\n占位符的格式为：@占位符,关于占位符需要知道以下几点：\n\n- 用@标识符标识后面的字符串是占位符\n\n- 占位符的值是从Mock.Random方法中引用的\n\n- 可以通过Mock.Random.extend()来扩展自定义占位符\n\n- 占位符可以引用数据模板中的属性\n\n- 占位符优先引用数据模板中的属性\n\n- 占位符支持相对路径和决定路径\n```\n    var data = Mock.mock({\n        name:{\n            name1:'@FIRST',\n            name2:'@LAST'\n        }    \n    })\n```\n\n#### Mock.mock()\n\n- Mock.mock(rurl,rtype,template|function(opt))\n\n```\n    rurl: ajax请求的地址\n    rtype: ajax请求的类型，如’GET','POST'\n    template: 数据模板，就是之前那些个例子\n    function: 生成相应数据的函数\n```\n\n- 常用的方法\n\n```\n    A. Mock.mock(template)\n\n    B. Mock.mock(rurl,template)，模拟ajax,匹配接收到url的ajax请求，把template对应的数据返回返回\n\n    C. Mock.mock(rurl,function(opt)),模拟ajax,会把函数执行的结果作为ajax回调返回\n\n    D. Mock.mock(rurl,rtype,template) 同上，只是对ajax的类型有要求\n\n    E. Mock.mock(rurl,rtype,function) 同上\n```\n\n#### Mock.setup(setting)\n\n配置拦截ajax请求的行为，支持的配置项有timeout。\n\n```\n    Mock.setup({\n        timeout:200\n    })\n    Mock.setup({\n        timeout:'200-500\n    })\n```\n\n#### Mock.valid(template,data)\n\n这个函数用来判断，数据模板和数据是否一样。\n\n#### Mock.toJSONShema(template)\n\n```\n    var template = Mock.mock({\n        'name|1-3':5\n    })\n    var tjs = Mock.toJSONSchema(tempalte);\n```\n\n####  Mock.Random\n\n```\n    var Random = Mock.Random;\n    var em1 = Mock.email();\n    var em2 = Mock.mock('@email');\n    var em3 = Mock.mock({\n        email:'@email'\n    })\n```\n\n## mock的原理\n1. Mock主要是关于测被测体与外部的交互逻辑。一般是指在不同场景下多次的与外部交互。\n\n2. 当外部依赖是硬件，或者外部程序没有准备好的情况下，Mock就能帮助完成单元测试。\n\n3. Mock的作用就是能通过设置输入输出值，让被测代码的各种工作场景都可以被测试覆盖。\n\n4. 为方便测试，程序设计应该采用依赖倒置原则，让被测试类依赖于接口，Mock类实现该接口。\n\n**被测类通过调用接口最终调用到Mock类，完成测试。而被测试类可以不作任何修改就能在实际系统里工作。\n这就是使用TDD能很自然的使产品代码于外部依赖松耦合。**\n\n参考：\n- [王老师的总结](https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%85%B3%E4%BA%8Emock.md)\n- https://www.zhihu.com/question/35436669/answer/62753889\n- https://segmentfault.com/a/1190000010211622\n- [深入理解Mock工作原理](https://blog.csdn.net/ibelieve1974/article/details/55220015)\n","slug":"mock工具使用","published":1,"updated":"2018-06-15T02:08:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uy200267q0te5m3b4yd","content":"<h2 id=\"mock的基础解释\"><a href=\"#mock的基础解释\" class=\"headerlink\" title=\"mock的基础解释\"></a>mock的基础解释</h2><h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>  可以在不依赖后端环境的情况下，进行前端开发，帮助编写单元测试,减少联调成本，提高工作效率。</p>\n<h3 id=\"实现功能\"><a href=\"#实现功能\" class=\"headerlink\" title=\"实现功能\"></a>实现功能</h3><p>  A.能渲染模板<br>  B.实现请求路由映射<br>  C.数据接口代理到生产或者测试环境</p>\n<a id=\"more\"></a>\n<h3 id=\"常用方式\"><a href=\"#常用方式\" class=\"headerlink\" title=\"常用方式\"></a>常用方式</h3><p>  在开发过程中，模拟后台接口数据，快速地实现前端开发。</p>\n<h2 id=\"mock的用法\"><a href=\"#mock的用法\" class=\"headerlink\" title=\"mock的用法\"></a>mock的用法</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> mockjs</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用mock\"><a href=\"#使用mock\" class=\"headerlink\" title=\"使用mock\"></a>使用mock</h3><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> Mock = <span class=\"keyword\">require</span>(<span class=\"string\">'mockjs'</span>);</span><br><span class=\"line\"><span class=\"built_in\">var</span> mock = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"params\">...</span><span class=\"params\">...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p> mock的语法规范包含两层规范：数据模板（DTD）和数据占位符（DPD）。</p>\n<h4 id=\"数据模板DTD\"><a href=\"#数据模板DTD\" class=\"headerlink\" title=\"数据模板DTD\"></a>数据模板DTD</h4><pre><code>A.模板规则：&apos;name|rule&apos;:value\n</code></pre><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中，<span class=\"built_in\">na</span><span class=\"symbol\">me:</span>属性名； ru<span class=\"symbol\">le:</span>属性规则；<span class=\"built_in\">value</span>：属性值。</span><br><span class=\"line\">    属性名和规则之间用|隔开，规则是可以选的。</span><br></pre></td></tr></table></figure>\n<pre><code>B.7个rule\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>.dmin-dmax':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>.dcount':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>.dmin-dmax':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>.dcount':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|+step':<span class=\"built_in\">value</span></span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（1）生成规则需要根据属性值的类型才能确定（2）属性值可以含有@占位符（3）属性值可以指定最终值的初始值和类型</strong></p>\n<pre><code>C.属性值是String\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|1-3'</span> : <span class=\"string\">'a'</span>, <span class=\"comment\">//重复生成1到3个a</span></span><br><span class=\"line\">    <span class=\"string\">'name2|2'</span> : <span class=\"string\">'b'</span> <span class=\"comment\">//生成bb</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>D.属性值是Number\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|+1'</span> : <span class=\"number\">4</span>,  <span class=\"comment\">//生成4,如果循环每次加1</span></span><br><span class=\"line\">    <span class=\"string\">'name2|1-7'</span> : <span class=\"number\">2</span>, <span class=\"comment\">//生成一个数字，1到7之间</span></span><br><span class=\"line\">    <span class=\"string\">'name3|1-4.5-8'</span> : <span class=\"number\">1</span>  <span class=\"comment\">//生成一个小数，整数部分1到4，小数部分5到8位（！！！表示小数点之后的位数范围）</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>E.属性值是Boolean\n</code></pre><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1'</span>: <span class=\"keyword\">true</span>, <span class=\"regexp\">//</span>生成一个布尔值，各一半</span><br><span class=\"line\">    <span class=\"string\">'name1|1-3'</span>: <span class=\"keyword\">true</span>  /<span class=\"regexp\">/ 1/</span><span class=\"number\">4</span>是<span class=\"keyword\">true</span>，<span class=\"number\">3</span>/<span class=\"number\">4</span>是<span class=\"keyword\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>F.属性值是Object\n</code></pre><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">a</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">b</span>:<span class=\"number\">2</span>,</span><br><span class=\"line\">    c:<span class=\"number\">3</span>,</span><br><span class=\"line\">    d:<span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">var</span> data = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1-3'</span>: obj,</span><br><span class=\"line\">    <span class=\"string\">'name|2'</span>: obj</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>G.属性值是Array\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|1'</span>: arr, <span class=\"comment\">//从数组里随机取出1个值</span></span><br><span class=\"line\">    <span class=\"string\">'name2|2'</span>: arr, <span class=\"comment\">//数组重复count次，这里count为2</span></span><br><span class=\"line\">    <span class=\"string\">'name3|1-3'</span>: arr  <span class=\"comment\">//数组重复1到3次</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>H.属性值是Function\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"function\"><span class=\"keyword\">fun</span> = <span class=\"title\">function</span><span class=\"params\">(x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+<span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name'</span>:<span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>         <span class=\"comment\">//返回函数的返回值20</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>I.属性值是RegExp\n    根据正则表达式反向生成对应的字符串，用于生成自定义格式的字符串\n</code></pre><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> <span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"type\">Mock</span>.mock(&#123;</span></span><br><span class=\"line\"><span class=\"class\">    ‘<span class=\"title\">name1'</span>:/[<span class=\"title\">a</span>-<span class=\"title\">z</span>][<span class=\"type\">A</span>-<span class=\"type\">Z</span>]/,</span></span><br><span class=\"line\"><span class=\"class\">    '<span class=\"title\">name2'</span>:/\\<span class=\"title\">d</span>&#123;1,3&#125;/</span></span><br><span class=\"line\"><span class=\"class\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<pre><code>会根据各自的正则表达式进行适配，并且随机返回\n</code></pre><h4 id=\"数据占位符DPD\"><a href=\"#数据占位符DPD\" class=\"headerlink\" title=\"数据占位符DPD\"></a>数据占位符DPD</h4><p>关于占位符，占位符只是在属性值是字符串的时候，在字符串里占个位置，并不会出现在最终的属性值中。</p>\n<p>占位符的格式为：@占位符,关于占位符需要知道以下几点：</p>\n<ul>\n<li><p>用@标识符标识后面的字符串是占位符</p>\n</li>\n<li><p>占位符的值是从Mock.Random方法中引用的</p>\n</li>\n<li><p>可以通过Mock.Random.extend()来扩展自定义占位符</p>\n</li>\n<li><p>占位符可以引用数据模板中的属性</p>\n</li>\n<li><p>占位符优先引用数据模板中的属性</p>\n</li>\n<li><p>占位符支持相对路径和决定路径</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> <span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"type\">Mock</span>.mock(&#123;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">name</span>:&#123;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">name1</span>:'@<span class=\"type\">FIRST</span>',</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">name2</span>:'@<span class=\"type\">LAST</span>'</span></span><br><span class=\"line\"><span class=\"class\">    &#125;    </span></span><br><span class=\"line\"><span class=\"class\">&#125;)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Mock-mock\"><a href=\"#Mock-mock\" class=\"headerlink\" title=\"Mock.mock()\"></a>Mock.mock()</h4><ul>\n<li>Mock.mock(rurl,rtype,template|function(opt))</li>\n</ul>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">rurl:</span> ajax请求的地址</span><br><span class=\"line\"><span class=\"symbol\">rtype:</span> ajax请求的类型，如’GET<span class=\"string\">','</span>POST'</span><br><span class=\"line\"><span class=\"symbol\">template:</span> 数据模板，就是之前那些个例子</span><br><span class=\"line\"><span class=\"symbol\">function:</span> 生成相应数据的函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常用的方法</li>\n</ul>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A. Mock.mock(<span class=\"keyword\">template</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">B. Mock.mock(rurl,<span class=\"keyword\">template</span>)，模拟ajax,匹配接收到url的ajax请求，把<span class=\"keyword\">template</span>对应的数据返回返回</span><br><span class=\"line\"></span><br><span class=\"line\">C. Mock.mock(rurl,<span class=\"built_in\">function</span>(opt)),模拟ajax,会把函数执行的结果作为ajax回调返回</span><br><span class=\"line\"></span><br><span class=\"line\">D. Mock.mock(rurl,rtype,<span class=\"keyword\">template</span>) 同上，只是对ajax的类型有要求</span><br><span class=\"line\"></span><br><span class=\"line\">E. Mock.mock(rurl,rtype,<span class=\"built_in\">function</span>) 同上</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-setup-setting\"><a href=\"#Mock-setup-setting\" class=\"headerlink\" title=\"Mock.setup(setting)\"></a>Mock.setup(setting)</h4><p>配置拦截ajax请求的行为，支持的配置项有timeout。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mock.setup(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">timeout</span>:<span class=\"number\">200</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Mock.setup(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">timeout</span>:'<span class=\"number\">200</span><span class=\"number\">-500</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-valid-template-data\"><a href=\"#Mock-valid-template-data\" class=\"headerlink\" title=\"Mock.valid(template,data)\"></a>Mock.valid(template,data)</h4><p>这个函数用来判断，数据模板和数据是否一样。</p>\n<h4 id=\"Mock-toJSONShema-template\"><a href=\"#Mock-toJSONShema-template\" class=\"headerlink\" title=\"Mock.toJSONShema(template)\"></a>Mock.toJSONShema(template)</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> template = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1-3'</span>:<span class=\"number\">5</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tjs = Mock.toJSONSchema(tempalte);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-Random\"><a href=\"#Mock-Random\" class=\"headerlink\" title=\"Mock.Random\"></a>Mock.Random</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Random = Mock.Random;</span><br><span class=\"line\"><span class=\"keyword\">var</span> em1 = Mock.email();</span><br><span class=\"line\"><span class=\"keyword\">var</span> em2 = Mock.mock(<span class=\"string\">'@email'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> em3 = Mock.mock(&#123;</span><br><span class=\"line\">    email:<span class=\"string\">'@email'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"mock的原理\"><a href=\"#mock的原理\" class=\"headerlink\" title=\"mock的原理\"></a>mock的原理</h2><ol>\n<li><p>Mock主要是关于测被测体与外部的交互逻辑。一般是指在不同场景下多次的与外部交互。</p>\n</li>\n<li><p>当外部依赖是硬件，或者外部程序没有准备好的情况下，Mock就能帮助完成单元测试。</p>\n</li>\n<li><p>Mock的作用就是能通过设置输入输出值，让被测代码的各种工作场景都可以被测试覆盖。</p>\n</li>\n<li><p>为方便测试，程序设计应该采用依赖倒置原则，让被测试类依赖于接口，Mock类实现该接口。</p>\n</li>\n</ol>\n<p><strong>被测类通过调用接口最终调用到Mock类，完成测试。而被测试类可以不作任何修改就能在实际系统里工作。<br>这就是使用TDD能很自然的使产品代码于外部依赖松耦合。</strong></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%85%B3%E4%BA%8Emock.md\" target=\"_blank\" rel=\"noopener\">王老师的总结</a></li>\n<li><a href=\"https://www.zhihu.com/question/35436669/answer/62753889\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/35436669/answer/62753889</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010211622\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000010211622</a></li>\n<li><a href=\"https://blog.csdn.net/ibelieve1974/article/details/55220015\" target=\"_blank\" rel=\"noopener\">深入理解Mock工作原理</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"mock的基础解释\"><a href=\"#mock的基础解释\" class=\"headerlink\" title=\"mock的基础解释\"></a>mock的基础解释</h2><h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>  可以在不依赖后端环境的情况下，进行前端开发，帮助编写单元测试,减少联调成本，提高工作效率。</p>\n<h3 id=\"实现功能\"><a href=\"#实现功能\" class=\"headerlink\" title=\"实现功能\"></a>实现功能</h3><p>  A.能渲染模板<br>  B.实现请求路由映射<br>  C.数据接口代理到生产或者测试环境</p>","more":"<h3 id=\"常用方式\"><a href=\"#常用方式\" class=\"headerlink\" title=\"常用方式\"></a>常用方式</h3><p>  在开发过程中，模拟后台接口数据，快速地实现前端开发。</p>\n<h2 id=\"mock的用法\"><a href=\"#mock的用法\" class=\"headerlink\" title=\"mock的用法\"></a>mock的用法</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> mockjs</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用mock\"><a href=\"#使用mock\" class=\"headerlink\" title=\"使用mock\"></a>使用mock</h3><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> Mock = <span class=\"keyword\">require</span>(<span class=\"string\">'mockjs'</span>);</span><br><span class=\"line\"><span class=\"built_in\">var</span> mock = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"params\">...</span><span class=\"params\">...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p> mock的语法规范包含两层规范：数据模板（DTD）和数据占位符（DPD）。</p>\n<h4 id=\"数据模板DTD\"><a href=\"#数据模板DTD\" class=\"headerlink\" title=\"数据模板DTD\"></a>数据模板DTD</h4><pre><code>A.模板规则：&apos;name|rule&apos;:value\n</code></pre><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中，<span class=\"built_in\">na</span><span class=\"symbol\">me:</span>属性名； ru<span class=\"symbol\">le:</span>属性规则；<span class=\"built_in\">value</span>：属性值。</span><br><span class=\"line\">    属性名和规则之间用|隔开，规则是可以选的。</span><br></pre></td></tr></table></figure>\n<pre><code>B.7个rule\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>.dmin-dmax':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">min</span>-<span class=\"built_in\">max</span>.dcount':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>.dmin-dmax':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|<span class=\"built_in\">count</span>.dcount':<span class=\"built_in\">value</span></span><br><span class=\"line\">'name|+step':<span class=\"built_in\">value</span></span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（1）生成规则需要根据属性值的类型才能确定（2）属性值可以含有@占位符（3）属性值可以指定最终值的初始值和类型</strong></p>\n<pre><code>C.属性值是String\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|1-3'</span> : <span class=\"string\">'a'</span>, <span class=\"comment\">//重复生成1到3个a</span></span><br><span class=\"line\">    <span class=\"string\">'name2|2'</span> : <span class=\"string\">'b'</span> <span class=\"comment\">//生成bb</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>D.属性值是Number\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|+1'</span> : <span class=\"number\">4</span>,  <span class=\"comment\">//生成4,如果循环每次加1</span></span><br><span class=\"line\">    <span class=\"string\">'name2|1-7'</span> : <span class=\"number\">2</span>, <span class=\"comment\">//生成一个数字，1到7之间</span></span><br><span class=\"line\">    <span class=\"string\">'name3|1-4.5-8'</span> : <span class=\"number\">1</span>  <span class=\"comment\">//生成一个小数，整数部分1到4，小数部分5到8位（！！！表示小数点之后的位数范围）</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>E.属性值是Boolean\n</code></pre><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1'</span>: <span class=\"keyword\">true</span>, <span class=\"regexp\">//</span>生成一个布尔值，各一半</span><br><span class=\"line\">    <span class=\"string\">'name1|1-3'</span>: <span class=\"keyword\">true</span>  /<span class=\"regexp\">/ 1/</span><span class=\"number\">4</span>是<span class=\"keyword\">true</span>，<span class=\"number\">3</span>/<span class=\"number\">4</span>是<span class=\"keyword\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>F.属性值是Object\n</code></pre><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">a</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">b</span>:<span class=\"number\">2</span>,</span><br><span class=\"line\">    c:<span class=\"number\">3</span>,</span><br><span class=\"line\">    d:<span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">var</span> data = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1-3'</span>: obj,</span><br><span class=\"line\">    <span class=\"string\">'name|2'</span>: obj</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>G.属性值是Array\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name1|1'</span>: arr, <span class=\"comment\">//从数组里随机取出1个值</span></span><br><span class=\"line\">    <span class=\"string\">'name2|2'</span>: arr, <span class=\"comment\">//数组重复count次，这里count为2</span></span><br><span class=\"line\">    <span class=\"string\">'name3|1-3'</span>: arr  <span class=\"comment\">//数组重复1到3次</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>H.属性值是Function\n</code></pre><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"function\"><span class=\"keyword\">fun</span> = <span class=\"title\">function</span><span class=\"params\">(x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+<span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name'</span>:<span class=\"function\"><span class=\"title\">fun</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>         <span class=\"comment\">//返回函数的返回值20</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<pre><code>I.属性值是RegExp\n    根据正则表达式反向生成对应的字符串，用于生成自定义格式的字符串\n</code></pre><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> <span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"type\">Mock</span>.mock(&#123;</span></span><br><span class=\"line\"><span class=\"class\">    ‘<span class=\"title\">name1'</span>:/[<span class=\"title\">a</span>-<span class=\"title\">z</span>][<span class=\"type\">A</span>-<span class=\"type\">Z</span>]/,</span></span><br><span class=\"line\"><span class=\"class\">    '<span class=\"title\">name2'</span>:/\\<span class=\"title\">d</span>&#123;1,3&#125;/</span></span><br><span class=\"line\"><span class=\"class\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<pre><code>会根据各自的正则表达式进行适配，并且随机返回\n</code></pre><h4 id=\"数据占位符DPD\"><a href=\"#数据占位符DPD\" class=\"headerlink\" title=\"数据占位符DPD\"></a>数据占位符DPD</h4><p>关于占位符，占位符只是在属性值是字符串的时候，在字符串里占个位置，并不会出现在最终的属性值中。</p>\n<p>占位符的格式为：@占位符,关于占位符需要知道以下几点：</p>\n<ul>\n<li><p>用@标识符标识后面的字符串是占位符</p>\n</li>\n<li><p>占位符的值是从Mock.Random方法中引用的</p>\n</li>\n<li><p>可以通过Mock.Random.extend()来扩展自定义占位符</p>\n</li>\n<li><p>占位符可以引用数据模板中的属性</p>\n</li>\n<li><p>占位符优先引用数据模板中的属性</p>\n</li>\n<li><p>占位符支持相对路径和决定路径</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> <span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"type\">Mock</span>.mock(&#123;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">name</span>:&#123;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">name1</span>:'@<span class=\"type\">FIRST</span>',</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">name2</span>:'@<span class=\"type\">LAST</span>'</span></span><br><span class=\"line\"><span class=\"class\">    &#125;    </span></span><br><span class=\"line\"><span class=\"class\">&#125;)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Mock-mock\"><a href=\"#Mock-mock\" class=\"headerlink\" title=\"Mock.mock()\"></a>Mock.mock()</h4><ul>\n<li>Mock.mock(rurl,rtype,template|function(opt))</li>\n</ul>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">rurl:</span> ajax请求的地址</span><br><span class=\"line\"><span class=\"symbol\">rtype:</span> ajax请求的类型，如’GET<span class=\"string\">','</span>POST'</span><br><span class=\"line\"><span class=\"symbol\">template:</span> 数据模板，就是之前那些个例子</span><br><span class=\"line\"><span class=\"symbol\">function:</span> 生成相应数据的函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常用的方法</li>\n</ul>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A. Mock.mock(<span class=\"keyword\">template</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">B. Mock.mock(rurl,<span class=\"keyword\">template</span>)，模拟ajax,匹配接收到url的ajax请求，把<span class=\"keyword\">template</span>对应的数据返回返回</span><br><span class=\"line\"></span><br><span class=\"line\">C. Mock.mock(rurl,<span class=\"built_in\">function</span>(opt)),模拟ajax,会把函数执行的结果作为ajax回调返回</span><br><span class=\"line\"></span><br><span class=\"line\">D. Mock.mock(rurl,rtype,<span class=\"keyword\">template</span>) 同上，只是对ajax的类型有要求</span><br><span class=\"line\"></span><br><span class=\"line\">E. Mock.mock(rurl,rtype,<span class=\"built_in\">function</span>) 同上</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-setup-setting\"><a href=\"#Mock-setup-setting\" class=\"headerlink\" title=\"Mock.setup(setting)\"></a>Mock.setup(setting)</h4><p>配置拦截ajax请求的行为，支持的配置项有timeout。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mock.setup(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">timeout</span>:<span class=\"number\">200</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Mock.setup(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">timeout</span>:'<span class=\"number\">200</span><span class=\"number\">-500</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-valid-template-data\"><a href=\"#Mock-valid-template-data\" class=\"headerlink\" title=\"Mock.valid(template,data)\"></a>Mock.valid(template,data)</h4><p>这个函数用来判断，数据模板和数据是否一样。</p>\n<h4 id=\"Mock-toJSONShema-template\"><a href=\"#Mock-toJSONShema-template\" class=\"headerlink\" title=\"Mock.toJSONShema(template)\"></a>Mock.toJSONShema(template)</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> template = Mock.mock(&#123;</span><br><span class=\"line\">    <span class=\"string\">'name|1-3'</span>:<span class=\"number\">5</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tjs = Mock.toJSONSchema(tempalte);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock-Random\"><a href=\"#Mock-Random\" class=\"headerlink\" title=\"Mock.Random\"></a>Mock.Random</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Random = Mock.Random;</span><br><span class=\"line\"><span class=\"keyword\">var</span> em1 = Mock.email();</span><br><span class=\"line\"><span class=\"keyword\">var</span> em2 = Mock.mock(<span class=\"string\">'@email'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> em3 = Mock.mock(&#123;</span><br><span class=\"line\">    email:<span class=\"string\">'@email'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"mock的原理\"><a href=\"#mock的原理\" class=\"headerlink\" title=\"mock的原理\"></a>mock的原理</h2><ol>\n<li><p>Mock主要是关于测被测体与外部的交互逻辑。一般是指在不同场景下多次的与外部交互。</p>\n</li>\n<li><p>当外部依赖是硬件，或者外部程序没有准备好的情况下，Mock就能帮助完成单元测试。</p>\n</li>\n<li><p>Mock的作用就是能通过设置输入输出值，让被测代码的各种工作场景都可以被测试覆盖。</p>\n</li>\n<li><p>为方便测试，程序设计应该采用依赖倒置原则，让被测试类依赖于接口，Mock类实现该接口。</p>\n</li>\n</ol>\n<p><strong>被测类通过调用接口最终调用到Mock类，完成测试。而被测试类可以不作任何修改就能在实际系统里工作。<br>这就是使用TDD能很自然的使产品代码于外部依赖松耦合。</strong></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%85%B3%E4%BA%8Emock.md\" target=\"_blank\" rel=\"noopener\">王老师的总结</a></li>\n<li><a href=\"https://www.zhihu.com/question/35436669/answer/62753889\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/35436669/answer/62753889</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010211622\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000010211622</a></li>\n<li><a href=\"https://blog.csdn.net/ibelieve1974/article/details/55220015\" target=\"_blank\" rel=\"noopener\">深入理解Mock工作原理</a></li>\n</ul>"},{"title":"node_module无法删除？","date":"2018-07-02T16:00:00.000Z","_content":"\nwindows下 删除node_modules文件夹，解决目录层次太深删除报错的问题\n\n解决方法：\n\n使用npm中的插件rimraf，专门用于删除的模块插件\n```\n\t1、安装：npm install -g rimraf（全局安装）\n\n  2、使用：先定位目标文件夹的父级目录，然后命令行输入rimraf xxx（xxx为需要删除的文件夹名称）。\n```\n\n原文链接：http://blog.csdn.net/sensation_cyq/article/details/51657595\n\n亲测可用~\n","source":"_posts/node_module无法删除？.md","raw":"title: node_module无法删除？\ndate: 2018/07/03\ncategories:\n  - 十万个为什么\ntags:\n  - node\n---\n\nwindows下 删除node_modules文件夹，解决目录层次太深删除报错的问题\n\n解决方法：\n\n使用npm中的插件rimraf，专门用于删除的模块插件\n```\n\t1、安装：npm install -g rimraf（全局安装）\n\n  2、使用：先定位目标文件夹的父级目录，然后命令行输入rimraf xxx（xxx为需要删除的文件夹名称）。\n```\n\n原文链接：http://blog.csdn.net/sensation_cyq/article/details/51657595\n\n亲测可用~\n","slug":"node_module无法删除？","published":1,"updated":"2018-07-03T12:49:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uy400297q0t2xxxx3sk","content":"<p>windows下 删除node_modules文件夹，解决目录层次太深删除报错的问题</p>\n<p>解决方法：</p>\n<p>使用npm中的插件rimraf，专门用于删除的模块插件<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、安装：npm install -g rimraf（全局安装）</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"number\">2</span>、使用：先定位目标文件夹的父级目录，然后命令行输入rimraf xxx（xxx为需要删除的文件夹名称）。</span><br></pre></td></tr></table></figure></p>\n<p>原文链接：<a href=\"http://blog.csdn.net/sensation_cyq/article/details/51657595\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/sensation_cyq/article/details/51657595</a></p>\n<p>亲测可用~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>windows下 删除node_modules文件夹，解决目录层次太深删除报错的问题</p>\n<p>解决方法：</p>\n<p>使用npm中的插件rimraf，专门用于删除的模块插件<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、安装：npm install -g rimraf（全局安装）</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"number\">2</span>、使用：先定位目标文件夹的父级目录，然后命令行输入rimraf xxx（xxx为需要删除的文件夹名称）。</span><br></pre></td></tr></table></figure></p>\n<p>原文链接：<a href=\"http://blog.csdn.net/sensation_cyq/article/details/51657595\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/sensation_cyq/article/details/51657595</a></p>\n<p>亲测可用~</p>\n"},{"title":"node版本切换工具的常用命令","date":"2018-05-04T16:00:00.000Z","_content":"\n使用场景：同时处理几个项目时，依赖的node版本不同，使用nvm工具，可以实现快速切换。\n\n- nvm install <version>  ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4\n- nvm uninstall <version>  ## 删除已安装的指定版本，语法与install类似\n- nvm use <version>  ## 切换使用指定的版本node\n- nvm ls  ## 列出所有安装的版本\n- nvm ls-remote  ## 列出所以远程服务器的版本（官方node version list）\n- nvm current  ## 显示当前的版本\n- nvm alias <name> <version>  ## 给不同的版本号添加别名\n- nvm unalias <name>  ## 删除已定义的别名\n- nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包\n","source":"_posts/node版本切换工具nvm的常用命令.md","raw":"title: node版本切换工具的常用命令\ndate: 2018/05/05\ncategories: 效率工具\n---\n\n使用场景：同时处理几个项目时，依赖的node版本不同，使用nvm工具，可以实现快速切换。\n\n- nvm install <version>  ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4\n- nvm uninstall <version>  ## 删除已安装的指定版本，语法与install类似\n- nvm use <version>  ## 切换使用指定的版本node\n- nvm ls  ## 列出所有安装的版本\n- nvm ls-remote  ## 列出所以远程服务器的版本（官方node version list）\n- nvm current  ## 显示当前的版本\n- nvm alias <name> <version>  ## 给不同的版本号添加别名\n- nvm unalias <name>  ## 删除已定义的别名\n- nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包\n","slug":"node版本切换工具nvm的常用命令","published":1,"updated":"2018-05-05T12:51:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uy5002c7q0tiuu2m9kl","content":"<p>使用场景：同时处理几个项目时，依赖的node版本不同，使用nvm工具，可以实现快速切换。</p>\n<ul>\n<li>nvm install <version>  ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4</version></li>\n<li>nvm uninstall <version>  ## 删除已安装的指定版本，语法与install类似</version></li>\n<li>nvm use <version>  ## 切换使用指定的版本node</version></li>\n<li>nvm ls  ## 列出所有安装的版本</li>\n<li>nvm ls-remote  ## 列出所以远程服务器的版本（官方node version list）</li>\n<li>nvm current  ## 显示当前的版本</li>\n<li>nvm alias <name> <version>  ## 给不同的版本号添加别名</version></name></li>\n<li>nvm unalias <name>  ## 删除已定义的别名</name></li>\n<li>nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包</version></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>使用场景：同时处理几个项目时，依赖的node版本不同，使用nvm工具，可以实现快速切换。</p>\n<ul>\n<li>nvm install <version>  ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4</version></li>\n<li>nvm uninstall <version>  ## 删除已安装的指定版本，语法与install类似</version></li>\n<li>nvm use <version>  ## 切换使用指定的版本node</version></li>\n<li>nvm ls  ## 列出所有安装的版本</li>\n<li>nvm ls-remote  ## 列出所以远程服务器的版本（官方node version list）</li>\n<li>nvm current  ## 显示当前的版本</li>\n<li>nvm alias <name> <version>  ## 给不同的版本号添加别名</version></name></li>\n<li>nvm unalias <name>  ## 删除已定义的别名</name></li>\n<li>nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包</version></li>\n</ul>\n"},{"title":"为什么git经常无法提交？","date":"2018-07-25T16:00:00.000Z","_content":"\n\n报错1：\n\n```Linux\nfatal: unable to access 'https://github.com/shengyur/shengyur.github.io.git/': Could not resolve host: github.com\n```\n\n报错2：\n\n```Linux\n rewrite categories/Questions/index.html (80%)\n rewrite index.html (77%)\n rewrite page/3/index.html (61%)\n rewrite tags/git/index.html (78%)\n```\npush 时，进度疯狂卡住，太焦躁了\n\n```Linux\nfatal: unable to access 'https://github.com/shengyur/shengyur.github.io.git/': Server aborted the SSL handshake\n```\n\n报错3：\n\n```Linux\nCould not resolve host: github.com\n```\n\n报错原因：\n\n域名解析不了，推测是网络问题,检查设备，发现vpn和翻墙工具都开好了，难不成是网速问题。。。\n\n然后把电脑连上手机热点，三个报错就都不见了 == ，吐槽下南京电信，真是辣鸡\n\n\n\n\n\n参考：\n- [github 创建远程分支以及远程分支无法删除的问题解决](https://blog.csdn.net/u014182411/article/details/74011901)\n","source":"_posts/为什么git经常无法提交？.md","raw":"title: 为什么git经常无法提交？\ndate: 2018/07/26\ncategories:\n  - 十万个为什么\ntags:\n  - git\n---\n\n\n报错1：\n\n```Linux\nfatal: unable to access 'https://github.com/shengyur/shengyur.github.io.git/': Could not resolve host: github.com\n```\n\n报错2：\n\n```Linux\n rewrite categories/Questions/index.html (80%)\n rewrite index.html (77%)\n rewrite page/3/index.html (61%)\n rewrite tags/git/index.html (78%)\n```\npush 时，进度疯狂卡住，太焦躁了\n\n```Linux\nfatal: unable to access 'https://github.com/shengyur/shengyur.github.io.git/': Server aborted the SSL handshake\n```\n\n报错3：\n\n```Linux\nCould not resolve host: github.com\n```\n\n报错原因：\n\n域名解析不了，推测是网络问题,检查设备，发现vpn和翻墙工具都开好了，难不成是网速问题。。。\n\n然后把电脑连上手机热点，三个报错就都不见了 == ，吐槽下南京电信，真是辣鸡\n\n\n\n\n\n参考：\n- [github 创建远程分支以及远程分支无法删除的问题解决](https://blog.csdn.net/u014182411/article/details/74011901)\n","slug":"为什么git经常无法提交？","published":1,"updated":"2018-08-08T00:59:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uy7002g7q0tefzao7ta","content":"<p>报错1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal: unable to access &apos;https://github.com/shengyur/shengyur.github.io.git/&apos;: Could not resolve host: github.com</span><br></pre></td></tr></table></figure>\n<p>报错2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rewrite categories/Questions/index.html (80%)</span><br><span class=\"line\">rewrite index.html (77%)</span><br><span class=\"line\">rewrite page/3/index.html (61%)</span><br><span class=\"line\">rewrite tags/git/index.html (78%)</span><br></pre></td></tr></table></figure>\n<p>push 时，进度疯狂卡住，太焦躁了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal: unable to access &apos;https://github.com/shengyur/shengyur.github.io.git/&apos;: Server aborted the SSL handshake</span><br></pre></td></tr></table></figure>\n<p>报错3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Could not resolve host: github.com</span><br></pre></td></tr></table></figure>\n<p>报错原因：</p>\n<p>域名解析不了，推测是网络问题,检查设备，发现vpn和翻墙工具都开好了，难不成是网速问题。。。</p>\n<p>然后把电脑连上手机热点，三个报错就都不见了 == ，吐槽下南京电信，真是辣鸡</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/u014182411/article/details/74011901\" target=\"_blank\" rel=\"noopener\">github 创建远程分支以及远程分支无法删除的问题解决</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>报错1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal: unable to access &apos;https://github.com/shengyur/shengyur.github.io.git/&apos;: Could not resolve host: github.com</span><br></pre></td></tr></table></figure>\n<p>报错2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rewrite categories/Questions/index.html (80%)</span><br><span class=\"line\">rewrite index.html (77%)</span><br><span class=\"line\">rewrite page/3/index.html (61%)</span><br><span class=\"line\">rewrite tags/git/index.html (78%)</span><br></pre></td></tr></table></figure>\n<p>push 时，进度疯狂卡住，太焦躁了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal: unable to access &apos;https://github.com/shengyur/shengyur.github.io.git/&apos;: Server aborted the SSL handshake</span><br></pre></td></tr></table></figure>\n<p>报错3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Could not resolve host: github.com</span><br></pre></td></tr></table></figure>\n<p>报错原因：</p>\n<p>域名解析不了，推测是网络问题,检查设备，发现vpn和翻墙工具都开好了，难不成是网速问题。。。</p>\n<p>然后把电脑连上手机热点，三个报错就都不见了 == ，吐槽下南京电信，真是辣鸡</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/u014182411/article/details/74011901\" target=\"_blank\" rel=\"noopener\">github 创建远程分支以及远程分支无法删除的问题解决</a></li>\n</ul>\n"},{"title":"vscode 之多设备配置同步","date":"2018-05-31T16:00:00.000Z","_content":"\n#### 背景：\n多台电脑同时使用的情况下，每次换电脑都重新配置一次就太麻烦了。得同步一把啊~\n\n#### 解决：\n实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。\n<!--more-->\n\n这个配置并不复杂，下面来简单介绍下它的使用：\n- 在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync；\n- 安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置；\n- 如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入；\n- 下载后等待安装，然后重启即可\n\n顺便纪念下2018儿童节的第一分钟，以及那些年我们吹过的牛逼\n![我们的征途，是星辰大海](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/lufi.jpg)\n原文：\nhttps://www.barretlee.com/blog/2017/04/21/something-about-vsc/\n","source":"_posts/vscode之多设备配置同步.md","raw":"title: vscode 之多设备配置同步\ndate: 2018/06/01\ncategories: 效率工具\ntags:\n  - vscode\n---\n\n#### 背景：\n多台电脑同时使用的情况下，每次换电脑都重新配置一次就太麻烦了。得同步一把啊~\n\n#### 解决：\n实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。\n<!--more-->\n\n这个配置并不复杂，下面来简单介绍下它的使用：\n- 在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync；\n- 安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置；\n- 如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入；\n- 下载后等待安装，然后重启即可\n\n顺便纪念下2018儿童节的第一分钟，以及那些年我们吹过的牛逼\n![我们的征途，是星辰大海](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/lufi.jpg)\n原文：\nhttps://www.barretlee.com/blog/2017/04/21/something-about-vsc/\n","slug":"vscode之多设备配置同步","published":1,"updated":"2018-05-31T16:21:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uya002k7q0ttw101vmc","content":"<h4 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h4><p>多台电脑同时使用的情况下，每次换电脑都重新配置一次就太麻烦了。得同步一把啊~</p>\n<h4 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h4><p>实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。<br><a id=\"more\"></a></p>\n<p>这个配置并不复杂，下面来简单介绍下它的使用：</p>\n<ul>\n<li>在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync；</li>\n<li>安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置；</li>\n<li>如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入；</li>\n<li>下载后等待安装，然后重启即可</li>\n</ul>\n<p>顺便纪念下2018儿童节的第一分钟，以及那些年我们吹过的牛逼<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/lufi.jpg\" alt=\"我们的征途，是星辰大海\"><br>原文：<br><a href=\"https://www.barretlee.com/blog/2017/04/21/something-about-vsc/\" target=\"_blank\" rel=\"noopener\">https://www.barretlee.com/blog/2017/04/21/something-about-vsc/</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h4><p>多台电脑同时使用的情况下，每次换电脑都重新配置一次就太麻烦了。得同步一把啊~</p>\n<h4 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h4><p>实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。<br>","more":"</p>\n<p>这个配置并不复杂，下面来简单介绍下它的使用：</p>\n<ul>\n<li>在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync；</li>\n<li>安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置；</li>\n<li>如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入；</li>\n<li>下载后等待安装，然后重启即可</li>\n</ul>\n<p>顺便纪念下2018儿童节的第一分钟，以及那些年我们吹过的牛逼<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/lufi.jpg\" alt=\"我们的征途，是星辰大海\"><br>原文：<br><a href=\"https://www.barretlee.com/blog/2017/04/21/something-about-vsc/\" target=\"_blank\" rel=\"noopener\">https://www.barretlee.com/blog/2017/04/21/something-about-vsc/</a></p>"},{"title":"为啥老王要敲头？","date":"2018-06-26T16:00:00.000Z","_content":"\n因为写全局的公共方法没写容错处理额==,mark一下\n\n```\n/**\n * 把分钟数转化为day天hour小时minute分钟\n * @param minutes 总分钟数\n * @param onlyToHour 是否只精确到小时（true/false）\n */\ntransferMinutesToTime(minutes,onlyToHour) {\n  const basicMinute = 60;\n  const basicHour = 24;\n  const basic = basicHour*basicMinute;\n\n  //如果minutes不是非负整数，返回null\n  if(!this.checkByRegExp.nonnegativeInt(minutes)){\n    return null;\n  }\n\n  //如果minutes等于0\n  if (minutes == 0) {\n    return onlyToHour ? {\n      day: 0,\n      hour: 0\n    } : {\n        day: 0,\n        hour: 0,\n        minute: 0\n      }\n  }\n\n  //如果minutes为正整数\n  let all = Number(minutes);\n  let day = Math.floor(all/basic);\n  let hour = Math.floor((all%basic)/basicMinute);\n  let minute = all%basic%basicMinute;\n\n  let data = {\n    day: day?day:0,\n    hour: hour?hour:0\n  }\n\n  if(!onlyToHour){\n    data.minute = minute?minute:0;\n  }\n\n  return data;\n}\n```\n","source":"_posts/为啥老王要敲头？.md","raw":"title: 为啥老王要敲头？\ndate: 2018/06/27\ncategories:\n  - 十万个为什么\n---\n\n因为写全局的公共方法没写容错处理额==,mark一下\n\n```\n/**\n * 把分钟数转化为day天hour小时minute分钟\n * @param minutes 总分钟数\n * @param onlyToHour 是否只精确到小时（true/false）\n */\ntransferMinutesToTime(minutes,onlyToHour) {\n  const basicMinute = 60;\n  const basicHour = 24;\n  const basic = basicHour*basicMinute;\n\n  //如果minutes不是非负整数，返回null\n  if(!this.checkByRegExp.nonnegativeInt(minutes)){\n    return null;\n  }\n\n  //如果minutes等于0\n  if (minutes == 0) {\n    return onlyToHour ? {\n      day: 0,\n      hour: 0\n    } : {\n        day: 0,\n        hour: 0,\n        minute: 0\n      }\n  }\n\n  //如果minutes为正整数\n  let all = Number(minutes);\n  let day = Math.floor(all/basic);\n  let hour = Math.floor((all%basic)/basicMinute);\n  let minute = all%basic%basicMinute;\n\n  let data = {\n    day: day?day:0,\n    hour: hour?hour:0\n  }\n\n  if(!onlyToHour){\n    data.minute = minute?minute:0;\n  }\n\n  return data;\n}\n```\n","slug":"为啥老王要敲头？","published":1,"updated":"2018-06-28T14:07:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uyc002n7q0txqtqj42p","content":"<p>因为写全局的公共方法没写容错处理额==,mark一下</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 把分钟数转化为day天hour小时minute分钟</span></span><br><span class=\"line\"><span class=\"comment\"> * @param minutes 总分钟数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param onlyToHour 是否只精确到小时（true/false）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">transferMinutesToTime(minutes,onlyToHour) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> basicMinute = <span class=\"number\">60</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> basicHour = <span class=\"number\">24</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> basic = basicHour*basicMinute;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果minutes不是非负整数，返回null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.checkByRegExp.nonnegativeInt(minutes))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果minutes等于0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minutes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> onlyToHour ? &#123;</span><br><span class=\"line\">      <span class=\"built_in\">day</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"built_in\">hour</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125; : &#123;</span><br><span class=\"line\">        <span class=\"built_in\">day</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"built_in\">hour</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"built_in\">minute</span>: <span class=\"number\">0</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果minutes为正整数</span></span><br><span class=\"line\">  let all = Number(minutes);</span><br><span class=\"line\">  let <span class=\"built_in\">day</span> = Math.<span class=\"built_in\">floor</span>(all/basic);</span><br><span class=\"line\">  let <span class=\"built_in\">hour</span> = Math.<span class=\"built_in\">floor</span>((all%basic)/basicMinute);</span><br><span class=\"line\">  let <span class=\"built_in\">minute</span> = all%basic%basicMinute;</span><br><span class=\"line\"></span><br><span class=\"line\">  let data = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">day</span>: <span class=\"built_in\">day</span>?<span class=\"built_in\">day</span>:<span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"built_in\">hour</span>: <span class=\"built_in\">hour</span>?<span class=\"built_in\">hour</span>:<span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!onlyToHour)&#123;</span><br><span class=\"line\">    data.<span class=\"built_in\">minute</span> = <span class=\"built_in\">minute</span>?<span class=\"built_in\">minute</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>因为写全局的公共方法没写容错处理额==,mark一下</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 把分钟数转化为day天hour小时minute分钟</span></span><br><span class=\"line\"><span class=\"comment\"> * @param minutes 总分钟数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param onlyToHour 是否只精确到小时（true/false）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">transferMinutesToTime(minutes,onlyToHour) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> basicMinute = <span class=\"number\">60</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> basicHour = <span class=\"number\">24</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> basic = basicHour*basicMinute;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果minutes不是非负整数，返回null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.checkByRegExp.nonnegativeInt(minutes))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果minutes等于0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minutes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> onlyToHour ? &#123;</span><br><span class=\"line\">      <span class=\"built_in\">day</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"built_in\">hour</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125; : &#123;</span><br><span class=\"line\">        <span class=\"built_in\">day</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"built_in\">hour</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"built_in\">minute</span>: <span class=\"number\">0</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果minutes为正整数</span></span><br><span class=\"line\">  let all = Number(minutes);</span><br><span class=\"line\">  let <span class=\"built_in\">day</span> = Math.<span class=\"built_in\">floor</span>(all/basic);</span><br><span class=\"line\">  let <span class=\"built_in\">hour</span> = Math.<span class=\"built_in\">floor</span>((all%basic)/basicMinute);</span><br><span class=\"line\">  let <span class=\"built_in\">minute</span> = all%basic%basicMinute;</span><br><span class=\"line\"></span><br><span class=\"line\">  let data = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">day</span>: <span class=\"built_in\">day</span>?<span class=\"built_in\">day</span>:<span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"built_in\">hour</span>: <span class=\"built_in\">hour</span>?<span class=\"built_in\">hour</span>:<span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!onlyToHour)&#123;</span><br><span class=\"line\">    data.<span class=\"built_in\">minute</span> = <span class=\"built_in\">minute</span>?<span class=\"built_in\">minute</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"利用hexo在多台电脑上提交和更新github pages博客","date":"2018-06-15T16:00:00.000Z","toc":true,"_content":"\n\n#### 概述\nHexo部署到GitHub上的文件，是本地的.md文件编译生成的html文件（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，没有编译之前的母本文件，操作就很麻烦了。\n\n其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，操作简单，效率更高。\n\n但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，就会多出许多不必要的仓库（10个项目需要20个仓库）。所以，本文选择利用分支。\n\n简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。\n\n下面以我的博客作为例子详细地讲述。\n\n\n#### 搭建流程\n\n1 . 创建仓库，shengyur.github.io；\n\n2 . 创建两个分支：master 与 sourceCode;\n\n3 . 设置sourceCode为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n\n4 . 使用git clone xxx.github.io.git拷贝仓库；\n\n5 . 在本地xxx.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n\n6 . 修改_config.yml中的deploy参数，分支应为master；\n\n7 . 依次执行git add .、git commit -m “…”、git push origin sourceCode提交网站相关的文件；\n如果出现报错\n```\n! [rejected]          sourceCode -> sourceCode (non-fast-forward)\n```\n解决办法：\n\n1、用Merge合并\n\n      命令行下，可以使用以下命令：\n\n      git fetch\n\n      git merge\n\n2、强推\n\n      git push -f\n\n      即利用强覆盖方式用你本地的代码替代git仓库内的内容。\n\n8 . 执行hexo generate -d生成网站并部署到GitHub上。\n\n这样一来，在GitHub上的xxx.github.io仓库就有两个分支，一个sourceCode分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。多端登陆修改博客就可以实现了~\n\n\n参考：\n1. https://www.jianshu.com/p/0b1fccce74e0\n2. https://formulahendry.github.io/2016/12/04/hexo-ci/\n3. http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\n","source":"_posts/利用hexo在多台电脑上提交和更新github pages博客.md","raw":"title: 利用hexo在多台电脑上提交和更新github pages博客\ndate: 2018/6/16\ncategories: 效率工具\ntoc: true\ntags:\n  - Hexo\n---\n\n\n#### 概述\nHexo部署到GitHub上的文件，是本地的.md文件编译生成的html文件（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，没有编译之前的母本文件，操作就很麻烦了。\n\n其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，操作简单，效率更高。\n\n但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，就会多出许多不必要的仓库（10个项目需要20个仓库）。所以，本文选择利用分支。\n\n简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。\n\n下面以我的博客作为例子详细地讲述。\n\n\n#### 搭建流程\n\n1 . 创建仓库，shengyur.github.io；\n\n2 . 创建两个分支：master 与 sourceCode;\n\n3 . 设置sourceCode为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n\n4 . 使用git clone xxx.github.io.git拷贝仓库；\n\n5 . 在本地xxx.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n\n6 . 修改_config.yml中的deploy参数，分支应为master；\n\n7 . 依次执行git add .、git commit -m “…”、git push origin sourceCode提交网站相关的文件；\n如果出现报错\n```\n! [rejected]          sourceCode -> sourceCode (non-fast-forward)\n```\n解决办法：\n\n1、用Merge合并\n\n      命令行下，可以使用以下命令：\n\n      git fetch\n\n      git merge\n\n2、强推\n\n      git push -f\n\n      即利用强覆盖方式用你本地的代码替代git仓库内的内容。\n\n8 . 执行hexo generate -d生成网站并部署到GitHub上。\n\n这样一来，在GitHub上的xxx.github.io仓库就有两个分支，一个sourceCode分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。多端登陆修改博客就可以实现了~\n\n\n参考：\n1. https://www.jianshu.com/p/0b1fccce74e0\n2. https://formulahendry.github.io/2016/12/04/hexo-ci/\n3. http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\n","slug":"利用hexo在多台电脑上提交和更新github pages博客","published":1,"updated":"2018-08-17T15:52:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uye002q7q0th6ipek6m","content":"<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Hexo部署到GitHub上的文件，是本地的.md文件编译生成的html文件（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，没有编译之前的母本文件，操作就很麻烦了。</p>\n<p>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，操作简单，效率更高。</p>\n<p>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，就会多出许多不必要的仓库（10个项目需要20个仓库）。所以，本文选择利用分支。</p>\n<p>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p>\n<p>下面以我的博客作为例子详细地讲述。</p>\n<h4 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h4><p>1 . 创建仓库，shengyur.github.io；</p>\n<p>2 . 创建两个分支：master 与 sourceCode;</p>\n<p>3 . 设置sourceCode为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</p>\n<p>4 . 使用git clone xxx.github.io.git拷贝仓库；</p>\n<p>5 . 在本地xxx.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</p>\n<p>6 . 修改_config.yml中的deploy参数，分支应为master；</p>\n<p>7 . 依次执行git add .、git commit -m “…”、git push origin sourceCode提交网站相关的文件；<br>如果出现报错<br><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! [rejected]          sourceCode -&gt; sourceCode (non-fast-forward)</span><br></pre></td></tr></table></figure></p>\n<p>解决办法：</p>\n<p>1、用Merge合并</p>\n<pre><code>命令行下，可以使用以下命令：\n\ngit fetch\n\ngit merge\n</code></pre><p>2、强推</p>\n<pre><code>git push -f\n\n即利用强覆盖方式用你本地的代码替代git仓库内的内容。\n</code></pre><p>8 . 执行hexo generate -d生成网站并部署到GitHub上。</p>\n<p>这样一来，在GitHub上的xxx.github.io仓库就有两个分支，一个sourceCode分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。多端登陆修改博客就可以实现了~</p>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/0b1fccce74e0</a></li>\n<li><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">https://formulahendry.github.io/2016/12/04/hexo-ci/</a></li>\n<li><a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Hexo部署到GitHub上的文件，是本地的.md文件编译生成的html文件（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，没有编译之前的母本文件，操作就很麻烦了。</p>\n<p>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，操作简单，效率更高。</p>\n<p>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，就会多出许多不必要的仓库（10个项目需要20个仓库）。所以，本文选择利用分支。</p>\n<p>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p>\n<p>下面以我的博客作为例子详细地讲述。</p>\n<h4 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h4><p>1 . 创建仓库，shengyur.github.io；</p>\n<p>2 . 创建两个分支：master 与 sourceCode;</p>\n<p>3 . 设置sourceCode为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</p>\n<p>4 . 使用git clone xxx.github.io.git拷贝仓库；</p>\n<p>5 . 在本地xxx.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</p>\n<p>6 . 修改_config.yml中的deploy参数，分支应为master；</p>\n<p>7 . 依次执行git add .、git commit -m “…”、git push origin sourceCode提交网站相关的文件；<br>如果出现报错<br><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! [rejected]          sourceCode -&gt; sourceCode (non-fast-forward)</span><br></pre></td></tr></table></figure></p>\n<p>解决办法：</p>\n<p>1、用Merge合并</p>\n<pre><code>命令行下，可以使用以下命令：\n\ngit fetch\n\ngit merge\n</code></pre><p>2、强推</p>\n<pre><code>git push -f\n\n即利用强覆盖方式用你本地的代码替代git仓库内的内容。\n</code></pre><p>8 . 执行hexo generate -d生成网站并部署到GitHub上。</p>\n<p>这样一来，在GitHub上的xxx.github.io仓库就有两个分支，一个sourceCode分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。多端登陆修改博客就可以实现了~</p>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/0b1fccce74e0</a></li>\n<li><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">https://formulahendry.github.io/2016/12/04/hexo-ci/</a></li>\n<li><a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more</a></li>\n</ol>\n"},{"title":"前端性能优化的常见措施","date":"2018-07-20T16:00:00.000Z","toc":true,"_content":"\n### Yslow的23条优化建议\n1. Minimize HTTP Requests\n2. Use a Content Delivery Network\n3. Avoid empty src or href\n4. Add an Expires or a Cache-Control Header\n5. Gzip Components\n6. Put StyleSheets at the Top\n7. Put Scripts at the Bottom\n8. Avoid CSS Expressions\n9. Make JavaScript and CSS External\n10. Reduce DNS Lookups\n11. Minify JavaScript and CSS\n12. Avoid Redirects\n13. Remove Duplicate Scripts\n14. Configure ETags\n15. Make AJAX Cacheable\n16. Use GET for AJAX Requests\n17. Reduce the Number of DOM Elements\n18. No 404s\n19. Reduce Cookie Size\n20. Use Cookie-Free Domains for Components\n21. Avoid Filters\n22. Do Not Scale Images in HTML\n23. Make favicon.ico Small and Cacheable\n\n\n### HTTP Cathe\n\nExpires\n\nCache-control\n\nLast-Modified + Etag\n\nVary\nhttp://www.cnblogs.com/vajoy/p/5341664.html\n\n原文：\n- http缓存 http://www.cnblogs.com/vajoy/p/5341664.html\n- yslow http://yslow.org/\n","source":"_posts/前端性能优化的常见措施.md","raw":"title: 前端性能优化的常见措施\ndate: 2018/07/21\ncategories: 性能优化\ntoc: true\ntags:\n  - 性能\n---\n\n### Yslow的23条优化建议\n1. Minimize HTTP Requests\n2. Use a Content Delivery Network\n3. Avoid empty src or href\n4. Add an Expires or a Cache-Control Header\n5. Gzip Components\n6. Put StyleSheets at the Top\n7. Put Scripts at the Bottom\n8. Avoid CSS Expressions\n9. Make JavaScript and CSS External\n10. Reduce DNS Lookups\n11. Minify JavaScript and CSS\n12. Avoid Redirects\n13. Remove Duplicate Scripts\n14. Configure ETags\n15. Make AJAX Cacheable\n16. Use GET for AJAX Requests\n17. Reduce the Number of DOM Elements\n18. No 404s\n19. Reduce Cookie Size\n20. Use Cookie-Free Domains for Components\n21. Avoid Filters\n22. Do Not Scale Images in HTML\n23. Make favicon.ico Small and Cacheable\n\n\n### HTTP Cathe\n\nExpires\n\nCache-control\n\nLast-Modified + Etag\n\nVary\nhttp://www.cnblogs.com/vajoy/p/5341664.html\n\n原文：\n- http缓存 http://www.cnblogs.com/vajoy/p/5341664.html\n- yslow http://yslow.org/\n","slug":"前端性能优化的常见措施","published":1,"updated":"2018-07-21T15:15:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uyh002u7q0t1vc1t0tx","content":"<h3 id=\"Yslow的23条优化建议\"><a href=\"#Yslow的23条优化建议\" class=\"headerlink\" title=\"Yslow的23条优化建议\"></a>Yslow的23条优化建议</h3><ol>\n<li>Minimize HTTP Requests</li>\n<li>Use a Content Delivery Network</li>\n<li>Avoid empty src or href</li>\n<li>Add an Expires or a Cache-Control Header</li>\n<li>Gzip Components</li>\n<li>Put StyleSheets at the Top</li>\n<li>Put Scripts at the Bottom</li>\n<li>Avoid CSS Expressions</li>\n<li>Make JavaScript and CSS External</li>\n<li>Reduce DNS Lookups</li>\n<li>Minify JavaScript and CSS</li>\n<li>Avoid Redirects</li>\n<li>Remove Duplicate Scripts</li>\n<li>Configure ETags</li>\n<li>Make AJAX Cacheable</li>\n<li>Use GET for AJAX Requests</li>\n<li>Reduce the Number of DOM Elements</li>\n<li>No 404s</li>\n<li>Reduce Cookie Size</li>\n<li>Use Cookie-Free Domains for Components</li>\n<li>Avoid Filters</li>\n<li>Do Not Scale Images in HTML</li>\n<li>Make favicon.ico Small and Cacheable</li>\n</ol>\n<h3 id=\"HTTP-Cathe\"><a href=\"#HTTP-Cathe\" class=\"headerlink\" title=\"HTTP Cathe\"></a>HTTP Cathe</h3><p>Expires</p>\n<p>Cache-control</p>\n<p>Last-Modified + Etag</p>\n<p>Vary<br><a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/vajoy/p/5341664.html</a></p>\n<p>原文：</p>\n<ul>\n<li>http缓存 <a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/vajoy/p/5341664.html</a></li>\n<li>yslow <a href=\"http://yslow.org/\" target=\"_blank\" rel=\"noopener\">http://yslow.org/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Yslow的23条优化建议\"><a href=\"#Yslow的23条优化建议\" class=\"headerlink\" title=\"Yslow的23条优化建议\"></a>Yslow的23条优化建议</h3><ol>\n<li>Minimize HTTP Requests</li>\n<li>Use a Content Delivery Network</li>\n<li>Avoid empty src or href</li>\n<li>Add an Expires or a Cache-Control Header</li>\n<li>Gzip Components</li>\n<li>Put StyleSheets at the Top</li>\n<li>Put Scripts at the Bottom</li>\n<li>Avoid CSS Expressions</li>\n<li>Make JavaScript and CSS External</li>\n<li>Reduce DNS Lookups</li>\n<li>Minify JavaScript and CSS</li>\n<li>Avoid Redirects</li>\n<li>Remove Duplicate Scripts</li>\n<li>Configure ETags</li>\n<li>Make AJAX Cacheable</li>\n<li>Use GET for AJAX Requests</li>\n<li>Reduce the Number of DOM Elements</li>\n<li>No 404s</li>\n<li>Reduce Cookie Size</li>\n<li>Use Cookie-Free Domains for Components</li>\n<li>Avoid Filters</li>\n<li>Do Not Scale Images in HTML</li>\n<li>Make favicon.ico Small and Cacheable</li>\n</ol>\n<h3 id=\"HTTP-Cathe\"><a href=\"#HTTP-Cathe\" class=\"headerlink\" title=\"HTTP Cathe\"></a>HTTP Cathe</h3><p>Expires</p>\n<p>Cache-control</p>\n<p>Last-Modified + Etag</p>\n<p>Vary<br><a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/vajoy/p/5341664.html</a></p>\n<p>原文：</p>\n<ul>\n<li>http缓存 <a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/vajoy/p/5341664.html</a></li>\n<li>yslow <a href=\"http://yslow.org/\" target=\"_blank\" rel=\"noopener\">http://yslow.org/</a></li>\n</ul>\n"},{"title":"前端技能积累","date":"2018-05-01T16:00:00.000Z","toc":true,"_content":"\n### CSS基础\n  1. 如何实现一个三栏布局，要求两边固定宽度，中间宽度自适应？\n  2. 圣杯布局 双飞翼布局 flex布局分别是什么？\n  3. css的几种垂直居中的方法\n\n<!--more-->\n\n### Javascript基础\n  1. js中的变量提升是什么原理？\n  2. 标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？\n    - 先冒泡还是先捕获？\n    - 各浏览器监听函数的写法是否一致？\n    - 冒泡和捕获的区别是什么？\n  3. 闭包的原理是什么？为什么会造成内存泄露？\n  4. XMLHttpRequest\n  5. 如何实现对象的深拷贝？\n\n###  HTTP协议 & 缓存\n  1. 下面的状态码代表的是什么意思？200、204、301、302、304、404？\n  2. HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?\n  3. 对运营商劫持有什么好的处理办法？\n  4. [cookie](http://www.cnblogs.com/Darren_code/archive/2011/11/24/Cookie.html)\n  5. [跨域问题???](https://segmentfault.com/a/1190000015597029)\n\n###  安全问题\n  1. 富文本编辑器如何解决XSS问题？\n  2. 为什么Restfal API不应当使用'Access-Cross-Origin:* '来实现跨域？\n\n### Node\n  1. Express 和 Koa有什么差别？\n  2. 怎么在Node做CI测试？\n\n### 性能优化\n  1. Yslow 和 PageSpeed用过吗?记得其中多少规则？\n  2. CDN是什么?为什么能资源加速?\n  3. 前端怎么样拿到DNS的查询时间？\n\n### 设计&交互&体验\n  1. PNG 和 JPG 的区别是什么？\n\n### 前端工程化\n  1. 你使用过构建工具来编译前端代码吗?使用过 Grunt、Gulp、webpack、FIS中的一些吗？\n  2. [Grunt、Gulp、webpack的区别是什么？](https://segmentfault.com/q/1010000008058766/a-1020000008058892)\n  3. [webpack基本配置入门](https://segmentfault.com/a/1190000011383224)\n  4. [AMD与CMD分别是什么？有什么区别？](https://blog.csdn.net/u014445339/article/details/55517770)\n  5. [webpack是如何进行依赖管理的？](https://segmentfault.com/a/1190000003970448)\n\n\n\n### 经验考察\n  1. 你遇到过兼容性问题吗?最令你影响深刻的兼容问题什么?\n\n### 框架类\n1. [React 常用面试题目与分析](https://segmentfault.com/a/1190000008102870)\n2. 详细说说Vue双向绑定原理？\n3. react 的渲染层和数据层怎么分开管理？renderProps types\n4. react 组件怎么实现按需加载？\n\n\n\n***\n\n刷微博看到一张图，分享一波，愿看到的你学以致用，日益精进。\n\n原图见水印哦~\n![前端工程师能力图](https://raw.githubusercontent.com/shengyur/Images/master/img/skills.jpeg)\n","source":"_posts/前端技能图谱.md","raw":"title: 前端技能积累\ndate: 2018/05/02\ncategories: 前端基础\ntoc: true\ntags:\n  - Javascript\n  - HTTP\n  - 安全\n  - Node\n---\n\n### CSS基础\n  1. 如何实现一个三栏布局，要求两边固定宽度，中间宽度自适应？\n  2. 圣杯布局 双飞翼布局 flex布局分别是什么？\n  3. css的几种垂直居中的方法\n\n<!--more-->\n\n### Javascript基础\n  1. js中的变量提升是什么原理？\n  2. 标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？\n    - 先冒泡还是先捕获？\n    - 各浏览器监听函数的写法是否一致？\n    - 冒泡和捕获的区别是什么？\n  3. 闭包的原理是什么？为什么会造成内存泄露？\n  4. XMLHttpRequest\n  5. 如何实现对象的深拷贝？\n\n###  HTTP协议 & 缓存\n  1. 下面的状态码代表的是什么意思？200、204、301、302、304、404？\n  2. HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?\n  3. 对运营商劫持有什么好的处理办法？\n  4. [cookie](http://www.cnblogs.com/Darren_code/archive/2011/11/24/Cookie.html)\n  5. [跨域问题???](https://segmentfault.com/a/1190000015597029)\n\n###  安全问题\n  1. 富文本编辑器如何解决XSS问题？\n  2. 为什么Restfal API不应当使用'Access-Cross-Origin:* '来实现跨域？\n\n### Node\n  1. Express 和 Koa有什么差别？\n  2. 怎么在Node做CI测试？\n\n### 性能优化\n  1. Yslow 和 PageSpeed用过吗?记得其中多少规则？\n  2. CDN是什么?为什么能资源加速?\n  3. 前端怎么样拿到DNS的查询时间？\n\n### 设计&交互&体验\n  1. PNG 和 JPG 的区别是什么？\n\n### 前端工程化\n  1. 你使用过构建工具来编译前端代码吗?使用过 Grunt、Gulp、webpack、FIS中的一些吗？\n  2. [Grunt、Gulp、webpack的区别是什么？](https://segmentfault.com/q/1010000008058766/a-1020000008058892)\n  3. [webpack基本配置入门](https://segmentfault.com/a/1190000011383224)\n  4. [AMD与CMD分别是什么？有什么区别？](https://blog.csdn.net/u014445339/article/details/55517770)\n  5. [webpack是如何进行依赖管理的？](https://segmentfault.com/a/1190000003970448)\n\n\n\n### 经验考察\n  1. 你遇到过兼容性问题吗?最令你影响深刻的兼容问题什么?\n\n### 框架类\n1. [React 常用面试题目与分析](https://segmentfault.com/a/1190000008102870)\n2. 详细说说Vue双向绑定原理？\n3. react 的渲染层和数据层怎么分开管理？renderProps types\n4. react 组件怎么实现按需加载？\n\n\n\n***\n\n刷微博看到一张图，分享一波，愿看到的你学以致用，日益精进。\n\n原图见水印哦~\n![前端工程师能力图](https://raw.githubusercontent.com/shengyur/Images/master/img/skills.jpeg)\n","slug":"前端技能图谱","published":1,"updated":"2018-08-19T23:51:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uyj002y7q0t3v0zq7u2","content":"<h3 id=\"CSS基础\"><a href=\"#CSS基础\" class=\"headerlink\" title=\"CSS基础\"></a>CSS基础</h3><ol>\n<li>如何实现一个三栏布局，要求两边固定宽度，中间宽度自适应？</li>\n<li>圣杯布局 双飞翼布局 flex布局分别是什么？</li>\n<li>css的几种垂直居中的方法</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"Javascript基础\"><a href=\"#Javascript基础\" class=\"headerlink\" title=\"Javascript基础\"></a>Javascript基础</h3><ol>\n<li>js中的变量提升是什么原理？</li>\n<li>标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？<ul>\n<li>先冒泡还是先捕获？</li>\n<li>各浏览器监听函数的写法是否一致？</li>\n<li>冒泡和捕获的区别是什么？</li>\n</ul>\n</li>\n<li>闭包的原理是什么？为什么会造成内存泄露？</li>\n<li>XMLHttpRequest</li>\n<li>如何实现对象的深拷贝？</li>\n</ol>\n<h3 id=\"HTTP协议-amp-缓存\"><a href=\"#HTTP协议-amp-缓存\" class=\"headerlink\" title=\"HTTP协议 &amp; 缓存\"></a>HTTP协议 &amp; 缓存</h3><ol>\n<li>下面的状态码代表的是什么意思？200、204、301、302、304、404？</li>\n<li>HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?</li>\n<li>对运营商劫持有什么好的处理办法？</li>\n<li><a href=\"http://www.cnblogs.com/Darren_code/archive/2011/11/24/Cookie.html\" target=\"_blank\" rel=\"noopener\">cookie</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015597029\" target=\"_blank\" rel=\"noopener\">跨域问题???</a></li>\n</ol>\n<h3 id=\"安全问题\"><a href=\"#安全问题\" class=\"headerlink\" title=\"安全问题\"></a>安全问题</h3><ol>\n<li>富文本编辑器如何解决XSS问题？</li>\n<li>为什么Restfal API不应当使用’Access-Cross-Origin:* ‘来实现跨域？</li>\n</ol>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><ol>\n<li>Express 和 Koa有什么差别？</li>\n<li>怎么在Node做CI测试？</li>\n</ol>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><ol>\n<li>Yslow 和 PageSpeed用过吗?记得其中多少规则？</li>\n<li>CDN是什么?为什么能资源加速?</li>\n<li>前端怎么样拿到DNS的查询时间？</li>\n</ol>\n<h3 id=\"设计-amp-交互-amp-体验\"><a href=\"#设计-amp-交互-amp-体验\" class=\"headerlink\" title=\"设计&amp;交互&amp;体验\"></a>设计&amp;交互&amp;体验</h3><ol>\n<li>PNG 和 JPG 的区别是什么？</li>\n</ol>\n<h3 id=\"前端工程化\"><a href=\"#前端工程化\" class=\"headerlink\" title=\"前端工程化\"></a>前端工程化</h3><ol>\n<li>你使用过构建工具来编译前端代码吗?使用过 Grunt、Gulp、webpack、FIS中的一些吗？</li>\n<li><a href=\"https://segmentfault.com/q/1010000008058766/a-1020000008058892\" target=\"_blank\" rel=\"noopener\">Grunt、Gulp、webpack的区别是什么？</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011383224\" target=\"_blank\" rel=\"noopener\">webpack基本配置入门</a></li>\n<li><a href=\"https://blog.csdn.net/u014445339/article/details/55517770\" target=\"_blank\" rel=\"noopener\">AMD与CMD分别是什么？有什么区别？</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000003970448\" target=\"_blank\" rel=\"noopener\">webpack是如何进行依赖管理的？</a></li>\n</ol>\n<h3 id=\"经验考察\"><a href=\"#经验考察\" class=\"headerlink\" title=\"经验考察\"></a>经验考察</h3><ol>\n<li>你遇到过兼容性问题吗?最令你影响深刻的兼容问题什么?</li>\n</ol>\n<h3 id=\"框架类\"><a href=\"#框架类\" class=\"headerlink\" title=\"框架类\"></a>框架类</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008102870\" target=\"_blank\" rel=\"noopener\">React 常用面试题目与分析</a></li>\n<li>详细说说Vue双向绑定原理？</li>\n<li>react 的渲染层和数据层怎么分开管理？renderProps types</li>\n<li>react 组件怎么实现按需加载？</li>\n</ol>\n<hr>\n<p>刷微博看到一张图，分享一波，愿看到的你学以致用，日益精进。</p>\n<p>原图见水印哦~<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/skills.jpeg\" alt=\"前端工程师能力图\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"CSS基础\"><a href=\"#CSS基础\" class=\"headerlink\" title=\"CSS基础\"></a>CSS基础</h3><ol>\n<li>如何实现一个三栏布局，要求两边固定宽度，中间宽度自适应？</li>\n<li>圣杯布局 双飞翼布局 flex布局分别是什么？</li>\n<li>css的几种垂直居中的方法</li>\n</ol>","more":"<h3 id=\"Javascript基础\"><a href=\"#Javascript基础\" class=\"headerlink\" title=\"Javascript基础\"></a>Javascript基础</h3><ol>\n<li>js中的变量提升是什么原理？</li>\n<li>标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？<ul>\n<li>先冒泡还是先捕获？</li>\n<li>各浏览器监听函数的写法是否一致？</li>\n<li>冒泡和捕获的区别是什么？</li>\n</ul>\n</li>\n<li>闭包的原理是什么？为什么会造成内存泄露？</li>\n<li>XMLHttpRequest</li>\n<li>如何实现对象的深拷贝？</li>\n</ol>\n<h3 id=\"HTTP协议-amp-缓存\"><a href=\"#HTTP协议-amp-缓存\" class=\"headerlink\" title=\"HTTP协议 &amp; 缓存\"></a>HTTP协议 &amp; 缓存</h3><ol>\n<li>下面的状态码代表的是什么意思？200、204、301、302、304、404？</li>\n<li>HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?</li>\n<li>对运营商劫持有什么好的处理办法？</li>\n<li><a href=\"http://www.cnblogs.com/Darren_code/archive/2011/11/24/Cookie.html\" target=\"_blank\" rel=\"noopener\">cookie</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015597029\" target=\"_blank\" rel=\"noopener\">跨域问题???</a></li>\n</ol>\n<h3 id=\"安全问题\"><a href=\"#安全问题\" class=\"headerlink\" title=\"安全问题\"></a>安全问题</h3><ol>\n<li>富文本编辑器如何解决XSS问题？</li>\n<li>为什么Restfal API不应当使用’Access-Cross-Origin:* ‘来实现跨域？</li>\n</ol>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><ol>\n<li>Express 和 Koa有什么差别？</li>\n<li>怎么在Node做CI测试？</li>\n</ol>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><ol>\n<li>Yslow 和 PageSpeed用过吗?记得其中多少规则？</li>\n<li>CDN是什么?为什么能资源加速?</li>\n<li>前端怎么样拿到DNS的查询时间？</li>\n</ol>\n<h3 id=\"设计-amp-交互-amp-体验\"><a href=\"#设计-amp-交互-amp-体验\" class=\"headerlink\" title=\"设计&amp;交互&amp;体验\"></a>设计&amp;交互&amp;体验</h3><ol>\n<li>PNG 和 JPG 的区别是什么？</li>\n</ol>\n<h3 id=\"前端工程化\"><a href=\"#前端工程化\" class=\"headerlink\" title=\"前端工程化\"></a>前端工程化</h3><ol>\n<li>你使用过构建工具来编译前端代码吗?使用过 Grunt、Gulp、webpack、FIS中的一些吗？</li>\n<li><a href=\"https://segmentfault.com/q/1010000008058766/a-1020000008058892\" target=\"_blank\" rel=\"noopener\">Grunt、Gulp、webpack的区别是什么？</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011383224\" target=\"_blank\" rel=\"noopener\">webpack基本配置入门</a></li>\n<li><a href=\"https://blog.csdn.net/u014445339/article/details/55517770\" target=\"_blank\" rel=\"noopener\">AMD与CMD分别是什么？有什么区别？</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000003970448\" target=\"_blank\" rel=\"noopener\">webpack是如何进行依赖管理的？</a></li>\n</ol>\n<h3 id=\"经验考察\"><a href=\"#经验考察\" class=\"headerlink\" title=\"经验考察\"></a>经验考察</h3><ol>\n<li>你遇到过兼容性问题吗?最令你影响深刻的兼容问题什么?</li>\n</ol>\n<h3 id=\"框架类\"><a href=\"#框架类\" class=\"headerlink\" title=\"框架类\"></a>框架类</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008102870\" target=\"_blank\" rel=\"noopener\">React 常用面试题目与分析</a></li>\n<li>详细说说Vue双向绑定原理？</li>\n<li>react 的渲染层和数据层怎么分开管理？renderProps types</li>\n<li>react 组件怎么实现按需加载？</li>\n</ol>\n<hr>\n<p>刷微博看到一张图，分享一波，愿看到的你学以致用，日益精进。</p>\n<p>原图见水印哦~<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/skills.jpeg\" alt=\"前端工程师能力图\"></p>"},{"title":"和固定，求两项（难度：★）","date":"2018-08-07T16:00:00.000Z","_content":"\n\n### 给定一个整数数组，其中有两项之和为一个特定的数字，假设每次 input 只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。\n\n比如：\n给定 nums = [2, 7, 11, 15]，target = 9，由于 nums[0] + nums[1] = 9，所以返回 [0, 1]\n\n<!--more-->\n\n\n\n1. 最简单粗暴的解法：\n\n```javascript\nlet getSum1 = (nums,target)=>{\n    for(let i=0;i<nums.length;i++){\n        for(let j=0;j<nums.length;j++){\n            if(i !== j && nums[i]+nums[j] == target){\n                return [i,j]\n            }\n        }\n    }\n}\nconst arr = [2,7,11,15,24,7];\nconst target = 9;\nconsole.log(getSum(arr,target));\n```\n\n2. 借用对象字面量，对 ‘“是否存在另一个数” 与 “当前遍历的数” 之和为 target’ 这个问题进行判断。化 O(n^2) 为 O(n)\n\n```javascript\nlet getSum2 = function(nums, target) {\n    let result = [];//index 数组\n    let map = {};\n    let temp;\n    for (let i = 0, len = nums.length; i < len; i++) {\n        //假设条件：\n        //存在另一个数，且 与当前遍历数字的和为target\n        temp = target - nums[i];\n        if (map[temp] !== undefined) {\n            result[0] = map[temp];\n            result[1] = i;\n            return result;\n        }\n        //当前项的value做key,index值当做value,把数组转化为对象的结构\n        map[nums[i]] = i;\n    }\n    return -1;\n  };\n  const arr = [2,7,11,15,24,7];\n  const target = 9;\n  console.log(getSum(arr,target));\n```\n\n3. 使用[https://jsperf.com/](https://jsperf.com/)检测两块代码的性能\n\n```javascript\nvar nums = []\n for (var i=0; i<1000; i++){\n   nums [i] = Math.floor(Math.random() * 100000);\n }\n\n var target = Math.floor(Math.random() * 100000);\n ```\n 生成一万条随机数据\n\n测试结果：https://jsperf.com/daily-algorithms-two-sum\n\n![](https://raw.githubusercontent.com/shengyur/Images/master/img/getTwoSum.jpg)\n可以发现在测试数据足够多的时候，第二种方法，比第一种快出许多。\n\n\n\n\n\n\n参考答案：\nhttps://github.com/barretlee/daily-algorithms/blob/master/answers/1.md\n\n原文：\nhttps://github.com/barretlee/daily-algorithms/issues/1\n","source":"_posts/和固定，求两项（难度：★）.md","raw":"title: 和固定，求两项（难度：★）\ndate: 2018/08/08\ncategories: 小算法\n---\n\n\n### 给定一个整数数组，其中有两项之和为一个特定的数字，假设每次 input 只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。\n\n比如：\n给定 nums = [2, 7, 11, 15]，target = 9，由于 nums[0] + nums[1] = 9，所以返回 [0, 1]\n\n<!--more-->\n\n\n\n1. 最简单粗暴的解法：\n\n```javascript\nlet getSum1 = (nums,target)=>{\n    for(let i=0;i<nums.length;i++){\n        for(let j=0;j<nums.length;j++){\n            if(i !== j && nums[i]+nums[j] == target){\n                return [i,j]\n            }\n        }\n    }\n}\nconst arr = [2,7,11,15,24,7];\nconst target = 9;\nconsole.log(getSum(arr,target));\n```\n\n2. 借用对象字面量，对 ‘“是否存在另一个数” 与 “当前遍历的数” 之和为 target’ 这个问题进行判断。化 O(n^2) 为 O(n)\n\n```javascript\nlet getSum2 = function(nums, target) {\n    let result = [];//index 数组\n    let map = {};\n    let temp;\n    for (let i = 0, len = nums.length; i < len; i++) {\n        //假设条件：\n        //存在另一个数，且 与当前遍历数字的和为target\n        temp = target - nums[i];\n        if (map[temp] !== undefined) {\n            result[0] = map[temp];\n            result[1] = i;\n            return result;\n        }\n        //当前项的value做key,index值当做value,把数组转化为对象的结构\n        map[nums[i]] = i;\n    }\n    return -1;\n  };\n  const arr = [2,7,11,15,24,7];\n  const target = 9;\n  console.log(getSum(arr,target));\n```\n\n3. 使用[https://jsperf.com/](https://jsperf.com/)检测两块代码的性能\n\n```javascript\nvar nums = []\n for (var i=0; i<1000; i++){\n   nums [i] = Math.floor(Math.random() * 100000);\n }\n\n var target = Math.floor(Math.random() * 100000);\n ```\n 生成一万条随机数据\n\n测试结果：https://jsperf.com/daily-algorithms-two-sum\n\n![](https://raw.githubusercontent.com/shengyur/Images/master/img/getTwoSum.jpg)\n可以发现在测试数据足够多的时候，第二种方法，比第一种快出许多。\n\n\n\n\n\n\n参考答案：\nhttps://github.com/barretlee/daily-algorithms/blob/master/answers/1.md\n\n原文：\nhttps://github.com/barretlee/daily-algorithms/issues/1\n","slug":"和固定，求两项（难度：★）","published":1,"updated":"2018-08-20T00:12:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uyl00327q0t27b4ouw8","content":"<h3 id=\"给定一个整数数组，其中有两项之和为一个特定的数字，假设每次-input-只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。\"><a href=\"#给定一个整数数组，其中有两项之和为一个特定的数字，假设每次-input-只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。\" class=\"headerlink\" title=\"给定一个整数数组，其中有两项之和为一个特定的数字，假设每次 input 只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。\"></a>给定一个整数数组，其中有两项之和为一个特定的数字，假设每次 input 只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。</h3><p>比如：<br>给定 nums = [2, 7, 11, 15]，target = 9，由于 nums[0] + nums[1] = 9，所以返回 [0, 1]</p>\n<a id=\"more\"></a>\n<ol>\n<li>最简单粗暴的解法：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getSum1 = <span class=\"function\">(<span class=\"params\">nums,target</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j=<span class=\"number\">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i !== j &amp;&amp; nums[i]+nums[j] == target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [i,j]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">24</span>,<span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> target = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getSum(arr,target));</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>借用对象字面量，对 ‘“是否存在另一个数” 与 “当前遍历的数” 之和为 target’ 这个问题进行判断。化 O(n^2) 为 O(n)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getSum2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = [];<span class=\"comment\">//index 数组</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> map = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = nums.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//假设条件：</span></span><br><span class=\"line\">        <span class=\"comment\">//存在另一个数，且 与当前遍历数字的和为target</span></span><br><span class=\"line\">        temp = target - nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map[temp] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">            result[<span class=\"number\">0</span>] = map[temp];</span><br><span class=\"line\">            result[<span class=\"number\">1</span>] = i;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//当前项的value做key,index值当做value,把数组转化为对象的结构</span></span><br><span class=\"line\">        map[nums[i]] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">24</span>,<span class=\"number\">7</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> target = <span class=\"number\">9</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(getSum(arr,target));</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使用<a href=\"https://jsperf.com/\" target=\"_blank\" rel=\"noopener\">https://jsperf.com/</a>检测两块代码的性能</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = []</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">   nums [i] = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100000</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> target = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100000</span>);</span><br></pre></td></tr></table></figure>\n<p> 生成一万条随机数据</p>\n<p>测试结果：<a href=\"https://jsperf.com/daily-algorithms-two-sum\" target=\"_blank\" rel=\"noopener\">https://jsperf.com/daily-algorithms-two-sum</a></p>\n<p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/getTwoSum.jpg\" alt=\"\"><br>可以发现在测试数据足够多的时候，第二种方法，比第一种快出许多。</p>\n<p>参考答案：<br><a href=\"https://github.com/barretlee/daily-algorithms/blob/master/answers/1.md\" target=\"_blank\" rel=\"noopener\">https://github.com/barretlee/daily-algorithms/blob/master/answers/1.md</a></p>\n<p>原文：<br><a href=\"https://github.com/barretlee/daily-algorithms/issues/1\" target=\"_blank\" rel=\"noopener\">https://github.com/barretlee/daily-algorithms/issues/1</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"给定一个整数数组，其中有两项之和为一个特定的数字，假设每次-input-只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。\"><a href=\"#给定一个整数数组，其中有两项之和为一个特定的数字，假设每次-input-只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。\" class=\"headerlink\" title=\"给定一个整数数组，其中有两项之和为一个特定的数字，假设每次 input 只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。\"></a>给定一个整数数组，其中有两项之和为一个特定的数字，假设每次 input 只有一个唯一解，不允许两次使用同一个元素，返回这两个数的索引。</h3><p>比如：<br>给定 nums = [2, 7, 11, 15]，target = 9，由于 nums[0] + nums[1] = 9，所以返回 [0, 1]</p>","more":"<ol>\n<li>最简单粗暴的解法：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getSum1 = <span class=\"function\">(<span class=\"params\">nums,target</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j=<span class=\"number\">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i !== j &amp;&amp; nums[i]+nums[j] == target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [i,j]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">24</span>,<span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> target = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getSum(arr,target));</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>借用对象字面量，对 ‘“是否存在另一个数” 与 “当前遍历的数” 之和为 target’ 这个问题进行判断。化 O(n^2) 为 O(n)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getSum2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = [];<span class=\"comment\">//index 数组</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> map = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = nums.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//假设条件：</span></span><br><span class=\"line\">        <span class=\"comment\">//存在另一个数，且 与当前遍历数字的和为target</span></span><br><span class=\"line\">        temp = target - nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map[temp] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">            result[<span class=\"number\">0</span>] = map[temp];</span><br><span class=\"line\">            result[<span class=\"number\">1</span>] = i;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//当前项的value做key,index值当做value,把数组转化为对象的结构</span></span><br><span class=\"line\">        map[nums[i]] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">24</span>,<span class=\"number\">7</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> target = <span class=\"number\">9</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(getSum(arr,target));</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使用<a href=\"https://jsperf.com/\" target=\"_blank\" rel=\"noopener\">https://jsperf.com/</a>检测两块代码的性能</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = []</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">   nums [i] = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100000</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> target = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100000</span>);</span><br></pre></td></tr></table></figure>\n<p> 生成一万条随机数据</p>\n<p>测试结果：<a href=\"https://jsperf.com/daily-algorithms-two-sum\" target=\"_blank\" rel=\"noopener\">https://jsperf.com/daily-algorithms-two-sum</a></p>\n<p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/getTwoSum.jpg\" alt=\"\"><br>可以发现在测试数据足够多的时候，第二种方法，比第一种快出许多。</p>\n<p>参考答案：<br><a href=\"https://github.com/barretlee/daily-algorithms/blob/master/answers/1.md\" target=\"_blank\" rel=\"noopener\">https://github.com/barretlee/daily-algorithms/blob/master/answers/1.md</a></p>\n<p>原文：<br><a href=\"https://github.com/barretlee/daily-algorithms/issues/1\" target=\"_blank\" rel=\"noopener\">https://github.com/barretlee/daily-algorithms/issues/1</a></p>"},{"title":"复制知乎/简书的文本内容，为什么会自带版权声明？","date":"2018-04-30T16:00:00.000Z","_content":"\n实现思路：\n1. 答案区域监听copy事件，并阻止这个事件的默认行为。\n2. 获取选中的内容**window.getSelection()**后加上版权信息，然后设置到剪切板**clipboardData.setData()**。\n\n```\n<div id=\"copyText\">我是一段即将被复制的话<b>test</b></div>\n<script>\n    function setClipboardText(e){\n        e.preventDefault();\n        var node = document.getElementById('#copyText');\n        var htmlData = '<div>著作权归作者所有。<br />'\n                        + '商业转载请联系作者获得授权，非商业转载请注明出处。<br />'\n                        + '作者：shengyu <br/>链接：https://shengyur.github.io/<br />'\n                        + node.innerHTML\n                        + '</div>';\n        var textData = '著作权归作者所有。\\n'\n                        + '商业转载请联系作者获得授权，非商业转载请注明出处。\\n'\n                        + '作者：shengyu \\n链接：https://shengyur.github.io/ \\n'\n                        + window.getSelection().getRangeAt(0);\n        if(e.clipboardData){  \n            e.clipboardData.setData(\"text/html\", htmlData);\n            e.clipboardData.setData(\"text/plain\",textData);\n        }\n        else if(window.clipboardData){  \n            return window.clipboardData.setData(\"text\", textData);  \n        }  \n    };  \n    var answer = document.getElementById(\"answer\");\n    answer.addEventListener('copy',function(e){\n        setClipboardText(e);\n    });\n</script>\n```\n\n\n备注：\n- 如果是复制到纯文本编辑器，就使用clipboardData.setData(\"text/plain\",textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(\"text/html\", htmlData);)，比如word,就有必要保留标签了。\n- oncopy 事件在用户拷贝元素上的内容时触发。\n- 有三种方式可以拷贝元素和内容：\n    1. 按下 CTRL + C\n    2. 在你的浏览器的 Edit(编辑) 菜单中选择 \"Copy（复制）\"\n    3. 右键鼠标按钮，在上下文菜单中选择 \"Copy（复制）\" 命令。\n\n\n参考：https://blog.csdn.net/sinat_23880167/article/details/79418505\n","source":"_posts/复制知乎简书的文本内容，为什么会自带版权声明？.md","raw":"title: 复制知乎/简书的文本内容，为什么会自带版权声明？\ndate: 2018/05/01\ncategories: 十万个为什么\n\n---\n\n实现思路：\n1. 答案区域监听copy事件，并阻止这个事件的默认行为。\n2. 获取选中的内容**window.getSelection()**后加上版权信息，然后设置到剪切板**clipboardData.setData()**。\n\n```\n<div id=\"copyText\">我是一段即将被复制的话<b>test</b></div>\n<script>\n    function setClipboardText(e){\n        e.preventDefault();\n        var node = document.getElementById('#copyText');\n        var htmlData = '<div>著作权归作者所有。<br />'\n                        + '商业转载请联系作者获得授权，非商业转载请注明出处。<br />'\n                        + '作者：shengyu <br/>链接：https://shengyur.github.io/<br />'\n                        + node.innerHTML\n                        + '</div>';\n        var textData = '著作权归作者所有。\\n'\n                        + '商业转载请联系作者获得授权，非商业转载请注明出处。\\n'\n                        + '作者：shengyu \\n链接：https://shengyur.github.io/ \\n'\n                        + window.getSelection().getRangeAt(0);\n        if(e.clipboardData){  \n            e.clipboardData.setData(\"text/html\", htmlData);\n            e.clipboardData.setData(\"text/plain\",textData);\n        }\n        else if(window.clipboardData){  \n            return window.clipboardData.setData(\"text\", textData);  \n        }  \n    };  \n    var answer = document.getElementById(\"answer\");\n    answer.addEventListener('copy',function(e){\n        setClipboardText(e);\n    });\n</script>\n```\n\n\n备注：\n- 如果是复制到纯文本编辑器，就使用clipboardData.setData(\"text/plain\",textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(\"text/html\", htmlData);)，比如word,就有必要保留标签了。\n- oncopy 事件在用户拷贝元素上的内容时触发。\n- 有三种方式可以拷贝元素和内容：\n    1. 按下 CTRL + C\n    2. 在你的浏览器的 Edit(编辑) 菜单中选择 \"Copy（复制）\"\n    3. 右键鼠标按钮，在上下文菜单中选择 \"Copy（复制）\" 命令。\n\n\n参考：https://blog.csdn.net/sinat_23880167/article/details/79418505\n","slug":"复制知乎简书的文本内容，为什么会自带版权声明？","published":1,"updated":"2018-05-02T14:02:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uyn00367q0tk8p2ms2i","content":"<p>实现思路：</p>\n<ol>\n<li>答案区域监听copy事件，并阻止这个事件的默认行为。</li>\n<li>获取选中的内容<strong>window.getSelection()</strong>后加上版权信息，然后设置到剪切板<strong>clipboardData.setData()</strong>。</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"copyText\"</span>&gt;</span>我是一段即将被复制的话<span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setClipboardText</span><span class=\"params\">(e)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        e.preventDefault();</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'#copyText'</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> htmlData = <span class=\"string\">'&lt;div&gt;著作权归作者所有。&lt;br /&gt;'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'商业转载请联系作者获得授权，非商业转载请注明出处。&lt;br /&gt;'</span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">                        + '作者：shengyu <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span>链接：https://shengyur.github.io/<span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span>'</span></span></span><br><span class=\"line\"><span class=\"undefined\">                        + node.innerHTML</span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'&lt;/div&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> textData = <span class=\"string\">'著作权归作者所有。\\n'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'商业转载请联系作者获得授权，非商业转载请注明出处。\\n'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'作者：shengyu \\n链接：https://shengyur.github.io/ \\n'</span></span></span><br><span class=\"line\"><span class=\"javascript\">                        + <span class=\"built_in\">window</span>.getSelection().getRangeAt(<span class=\"number\">0</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">if</span>(e.clipboardData)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\">            e.clipboardData.setData(<span class=\"string\">\"text/html\"</span>, htmlData);</span></span><br><span class=\"line\"><span class=\"actionscript\">            e.clipboardData.setData(<span class=\"string\">\"text/plain\"</span>,textData);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.clipboardData)&#123;  </span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.clipboardData.setData(<span class=\"string\">\"text\"</span>, textData);  </span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;  </span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;  </span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> answer = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"answer\"</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    answer.addEventListener(<span class=\"string\">'copy'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(e)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        setClipboardText(e);</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>备注：</p>\n<ul>\n<li>如果是复制到纯文本编辑器，就使用clipboardData.setData(“text/plain”,textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(“text/html”, htmlData);)，比如word,就有必要保留标签了。</li>\n<li>oncopy 事件在用户拷贝元素上的内容时触发。</li>\n<li>有三种方式可以拷贝元素和内容：<ol>\n<li>按下 CTRL + C</li>\n<li>在你的浏览器的 Edit(编辑) 菜单中选择 “Copy（复制）”</li>\n<li>右键鼠标按钮，在上下文菜单中选择 “Copy（复制）” 命令。</li>\n</ol>\n</li>\n</ul>\n<p>参考：<a href=\"https://blog.csdn.net/sinat_23880167/article/details/79418505\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_23880167/article/details/79418505</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>实现思路：</p>\n<ol>\n<li>答案区域监听copy事件，并阻止这个事件的默认行为。</li>\n<li>获取选中的内容<strong>window.getSelection()</strong>后加上版权信息，然后设置到剪切板<strong>clipboardData.setData()</strong>。</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"copyText\"</span>&gt;</span>我是一段即将被复制的话<span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setClipboardText</span><span class=\"params\">(e)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        e.preventDefault();</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'#copyText'</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> htmlData = <span class=\"string\">'&lt;div&gt;著作权归作者所有。&lt;br /&gt;'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'商业转载请联系作者获得授权，非商业转载请注明出处。&lt;br /&gt;'</span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">                        + '作者：shengyu <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span>链接：https://shengyur.github.io/<span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span>'</span></span></span><br><span class=\"line\"><span class=\"undefined\">                        + node.innerHTML</span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'&lt;/div&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> textData = <span class=\"string\">'著作权归作者所有。\\n'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'商业转载请联系作者获得授权，非商业转载请注明出处。\\n'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">                        + <span class=\"string\">'作者：shengyu \\n链接：https://shengyur.github.io/ \\n'</span></span></span><br><span class=\"line\"><span class=\"javascript\">                        + <span class=\"built_in\">window</span>.getSelection().getRangeAt(<span class=\"number\">0</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">if</span>(e.clipboardData)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\">            e.clipboardData.setData(<span class=\"string\">\"text/html\"</span>, htmlData);</span></span><br><span class=\"line\"><span class=\"actionscript\">            e.clipboardData.setData(<span class=\"string\">\"text/plain\"</span>,textData);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.clipboardData)&#123;  </span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.clipboardData.setData(<span class=\"string\">\"text\"</span>, textData);  </span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;  </span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;  </span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> answer = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"answer\"</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    answer.addEventListener(<span class=\"string\">'copy'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(e)</span></span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        setClipboardText(e);</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>备注：</p>\n<ul>\n<li>如果是复制到纯文本编辑器，就使用clipboardData.setData(“text/plain”,textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(“text/html”, htmlData);)，比如word,就有必要保留标签了。</li>\n<li>oncopy 事件在用户拷贝元素上的内容时触发。</li>\n<li>有三种方式可以拷贝元素和内容：<ol>\n<li>按下 CTRL + C</li>\n<li>在你的浏览器的 Edit(编辑) 菜单中选择 “Copy（复制）”</li>\n<li>右键鼠标按钮，在上下文菜单中选择 “Copy（复制）” 命令。</li>\n</ol>\n</li>\n</ul>\n<p>参考：<a href=\"https://blog.csdn.net/sinat_23880167/article/details/79418505\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_23880167/article/details/79418505</a></p>\n"},{"title":"如何使用a标签或者href实现文件的下载？","date":"2018-06-22T16:00:00.000Z","_content":"\n1. 利用iframe实现（下载的文件域名不方便直接写）\n\nhtml：\n\n```\n  \n    <a href=\"javascript:Slide.downLoadCooperationAgreement();\">年度合作协议</a>\n```\n\njs：\n\n```  \n    Slide.downLoadCooperationAgreement = function(){\n        var url = System.domainUrlTotUedPxy[System.testTotPxyFlag]+'/download/annualCooperationAgreement_v1.docx';\n        var size = $(\"#cooperationAgreement_download\").size();\n        if (size == 0) {\n           $(\"body\").append(\"<iframe id = 'cooperationAgreement_download' style='display:none;' src='\"+url+\"'></iframe>\");\n        } else {\n          $(\"#cooperationAgreement_download\").attr(\"src\", url);\n        }\n      };\n```\n2. 利用a标签实现，download属性可以用来命名下载的文件。\n```\n    <a href=\"/i/w3school_logo_white.gif\" download=\"w3logo\">\n      <img border=\"0\" src=\"/i/w3school_logo_white.gif\" alt=\"W3School\">\n    </a>\n```\n\n原文：\n - [王老师的积累](https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/%E5%85%B6%E5%AE%83/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88a%E6%A0%87%E7%AD%BE%E7%9A%84href%E5%AE%9E%E7%8E%B0%EF%BC%89.md)\n\n\n","source":"_posts/如何使用a标签或者href实现文件的下载？.md","raw":"title: 如何使用a标签或者href实现文件的下载？\ndate: 2018/06/23\ncategories: 十万个为什么\n\n---\n\n1. 利用iframe实现（下载的文件域名不方便直接写）\n\nhtml：\n\n```\n  \n    <a href=\"javascript:Slide.downLoadCooperationAgreement();\">年度合作协议</a>\n```\n\njs：\n\n```  \n    Slide.downLoadCooperationAgreement = function(){\n        var url = System.domainUrlTotUedPxy[System.testTotPxyFlag]+'/download/annualCooperationAgreement_v1.docx';\n        var size = $(\"#cooperationAgreement_download\").size();\n        if (size == 0) {\n           $(\"body\").append(\"<iframe id = 'cooperationAgreement_download' style='display:none;' src='\"+url+\"'></iframe>\");\n        } else {\n          $(\"#cooperationAgreement_download\").attr(\"src\", url);\n        }\n      };\n```\n2. 利用a标签实现，download属性可以用来命名下载的文件。\n```\n    <a href=\"/i/w3school_logo_white.gif\" download=\"w3logo\">\n      <img border=\"0\" src=\"/i/w3school_logo_white.gif\" alt=\"W3School\">\n    </a>\n```\n\n原文：\n - [王老师的积累](https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/%E5%85%B6%E5%AE%83/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88a%E6%A0%87%E7%AD%BE%E7%9A%84href%E5%AE%9E%E7%8E%B0%EF%BC%89.md)\n\n\n","slug":"如何使用a标签或者href实现文件的下载？","published":1,"updated":"2018-06-23T13:57:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uyr003a7q0tbsjlr0v0","content":"<ol>\n<li>利用iframe实现（下载的文件域名不方便直接写）</li>\n</ol>\n<p>html：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"javascript:Slide.downLoadCooperationAgreement();\"</span>&gt;</span>年度合作协议<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>js：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slide.downLoadCooperationAgreement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">url</span> = System.domainUrlTotUedPxy[System.testTotPxyFlag]+<span class=\"string\">'/download/annualCooperationAgreement_v1.docx'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">size</span> = $(<span class=\"string\">\"#cooperationAgreement_download\"</span>).size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">size</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       $(<span class=\"string\">\"body\"</span>).append(<span class=\"string\">\"&lt;iframe id = 'cooperationAgreement_download' style='display:none;' src='\"</span>+<span class=\"built_in\">url</span>+<span class=\"string\">\"'&gt;&lt;/iframe&gt;\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"title\">else</span> &#123;</span><br><span class=\"line\">      $(<span class=\"string\">\"#cooperationAgreement_download\"</span>).attr(<span class=\"string\">\"src\"</span>, <span class=\"built_in\">url</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>利用a标签实现，download属性可以用来命名下载的文件。<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">a</span> href=<span class=\"string\">\"/i/w3school_logo_white.gif\"</span> download=<span class=\"string\">\"w3logo\"</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"selector-tag\">img</span> <span class=\"attribute\">border</span>=<span class=\"string\">\"0\"</span> src=<span class=\"string\">\"/i/w3school_logo_white.gif\"</span> alt=<span class=\"string\">\"W3School\"</span>&gt;</span><br><span class=\"line\">&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>原文：</p>\n<ul>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/%E5%85%B6%E5%AE%83/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88a%E6%A0%87%E7%AD%BE%E7%9A%84href%E5%AE%9E%E7%8E%B0%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">王老师的积累</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>利用iframe实现（下载的文件域名不方便直接写）</li>\n</ol>\n<p>html：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"javascript:Slide.downLoadCooperationAgreement();\"</span>&gt;</span>年度合作协议<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>js：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slide.downLoadCooperationAgreement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">url</span> = System.domainUrlTotUedPxy[System.testTotPxyFlag]+<span class=\"string\">'/download/annualCooperationAgreement_v1.docx'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">size</span> = $(<span class=\"string\">\"#cooperationAgreement_download\"</span>).size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">size</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       $(<span class=\"string\">\"body\"</span>).append(<span class=\"string\">\"&lt;iframe id = 'cooperationAgreement_download' style='display:none;' src='\"</span>+<span class=\"built_in\">url</span>+<span class=\"string\">\"'&gt;&lt;/iframe&gt;\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"title\">else</span> &#123;</span><br><span class=\"line\">      $(<span class=\"string\">\"#cooperationAgreement_download\"</span>).attr(<span class=\"string\">\"src\"</span>, <span class=\"built_in\">url</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>利用a标签实现，download属性可以用来命名下载的文件。<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">a</span> href=<span class=\"string\">\"/i/w3school_logo_white.gif\"</span> download=<span class=\"string\">\"w3logo\"</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"selector-tag\">img</span> <span class=\"attribute\">border</span>=<span class=\"string\">\"0\"</span> src=<span class=\"string\">\"/i/w3school_logo_white.gif\"</span> alt=<span class=\"string\">\"W3School\"</span>&gt;</span><br><span class=\"line\">&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>原文：</p>\n<ul>\n<li><a href=\"https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/%E5%85%B6%E5%AE%83/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88a%E6%A0%87%E7%AD%BE%E7%9A%84href%E5%AE%9E%E7%8E%B0%EF%BC%89.md\" target=\"_blank\" rel=\"noopener\">王老师的积累</a></li>\n</ul>\n"},{"title":"常用前端性能优化工具分析","date":"2018-07-20T16:00:00.000Z","toc":true,"_content":"\n在网站和应用程序变的越来越丰富的今天，web应用对网络和设备资源的要求也越来越高。配合各种方式、手段、辅助系统，进行前端优化的最终目的都是提升用户体验，改善页面性能。\n我们常常竭尽全力进行前端页面优化，但却忽略了这样做的效果和意义。先不急于探究前端优化具体可以怎样去做，先看看什么是前端性能，应该怎样去了解和评价前端页面的性能。\n\n<!--more-->\n\n## 浏览器API\n\n### Performance Timing API\n\n下图为W3C标准中Performance Timing资源加载和解析过程记录各个关键点的示意图，浏览器中加载和解析一个HTML文件的详细过程先后经历unload、redirect、App Cache、DNS、TCP、Request、Response、Processing、onload几个阶段，每个过程开始和结束的关键时间戳浏览器已经使用performance.timing来记录了，所以根据这个记录并结合简单的计算，我们就可以得到页面中每个过程所消耗的时间。\n\n![](https://raw.githubusercontent.com/shengyur/Images/master/performance.jpg)\n\n```javascript\nfunction performanceTest(){\n\nlet timing = performance.timing,\n\nreadyStart = timing.fetchStart - timing.navigationStart,\n\nredirectTime = timing.redirectEnd - timing.redirectStart,\n\nappcacheTime = timing.domainLookupStart - timing.fetchStart,\n\nunloadEventTime = timing.unloadEventEnd - timing.unloadEventStart,\n\nlookupDomainTime = timing.domainLookupEnd - timing.domainLookupStart,\n\nconnectTime = timing.connectEnd - timing.connectStart,\n\nrequestTime = timing.responseEnd - timing.requestStart,\n\ninitDomTreeTime = timing.domInteractive - timing.responseEnd,\n\ndomReadyTime = timing.domComplete - timing.domInteractive,\n\nloadEventTime = timing.loadEventEnd - timing.loadEventStart,\n\nloadTime = timing.loadEventEnd - timing.navigationStart;\n\nconsole.log('准备新页面时间耗时: ' + readyStart);\n\nconsole.log('redirect 重定向耗时: ' + redirectTime);\n\nconsole.log('Appcache 耗时: ' + appcacheTime);\n\nconsole.log('unload 前文档耗时: ' + unloadEventTime);\n\nconsole.log('DNS 查询耗时: ' + lookupDomainTime);\n\nconsole.log('TCP连接耗时: ' + connectTime);\n\nconsole.log('request请求耗时: ' + requestTime);\n\nconsole.log('请求完毕至DOM加载: ' + initDomTreeTime);\n\nconsole.log('解析DOM树耗时: ' + domReadyTime);\n\nconsole.log('load事件耗时: ' + loadEventTime);\n\nconsole.log('加载时间耗时: ' + loadTime);\n}\n```\n\n\n### Navigation Timing\n\n\n\n### Resource Timing\n\n\n\n### 页面埋点计时\n 使用new Date()时间戳记录操作的时间点\n\n\n## 工具\n### chrome Develop Tools\n\n### Profile工具\n\n\n\n原文：\n[前端性能分析](https://my.oschina.net/zhangstephen/blog/1601380)\n[谷歌性能优化文章](https://developers.google.cn/web/fundamentals/performance/why-performance-matters/)\n","source":"_posts/性能优化工具分析.md","raw":"title: 常用前端性能优化工具分析\ndate: 2018/07/21\ncategories: 性能优化\ntoc: true\ntags:\n  - 性能\n---\n\n在网站和应用程序变的越来越丰富的今天，web应用对网络和设备资源的要求也越来越高。配合各种方式、手段、辅助系统，进行前端优化的最终目的都是提升用户体验，改善页面性能。\n我们常常竭尽全力进行前端页面优化，但却忽略了这样做的效果和意义。先不急于探究前端优化具体可以怎样去做，先看看什么是前端性能，应该怎样去了解和评价前端页面的性能。\n\n<!--more-->\n\n## 浏览器API\n\n### Performance Timing API\n\n下图为W3C标准中Performance Timing资源加载和解析过程记录各个关键点的示意图，浏览器中加载和解析一个HTML文件的详细过程先后经历unload、redirect、App Cache、DNS、TCP、Request、Response、Processing、onload几个阶段，每个过程开始和结束的关键时间戳浏览器已经使用performance.timing来记录了，所以根据这个记录并结合简单的计算，我们就可以得到页面中每个过程所消耗的时间。\n\n![](https://raw.githubusercontent.com/shengyur/Images/master/performance.jpg)\n\n```javascript\nfunction performanceTest(){\n\nlet timing = performance.timing,\n\nreadyStart = timing.fetchStart - timing.navigationStart,\n\nredirectTime = timing.redirectEnd - timing.redirectStart,\n\nappcacheTime = timing.domainLookupStart - timing.fetchStart,\n\nunloadEventTime = timing.unloadEventEnd - timing.unloadEventStart,\n\nlookupDomainTime = timing.domainLookupEnd - timing.domainLookupStart,\n\nconnectTime = timing.connectEnd - timing.connectStart,\n\nrequestTime = timing.responseEnd - timing.requestStart,\n\ninitDomTreeTime = timing.domInteractive - timing.responseEnd,\n\ndomReadyTime = timing.domComplete - timing.domInteractive,\n\nloadEventTime = timing.loadEventEnd - timing.loadEventStart,\n\nloadTime = timing.loadEventEnd - timing.navigationStart;\n\nconsole.log('准备新页面时间耗时: ' + readyStart);\n\nconsole.log('redirect 重定向耗时: ' + redirectTime);\n\nconsole.log('Appcache 耗时: ' + appcacheTime);\n\nconsole.log('unload 前文档耗时: ' + unloadEventTime);\n\nconsole.log('DNS 查询耗时: ' + lookupDomainTime);\n\nconsole.log('TCP连接耗时: ' + connectTime);\n\nconsole.log('request请求耗时: ' + requestTime);\n\nconsole.log('请求完毕至DOM加载: ' + initDomTreeTime);\n\nconsole.log('解析DOM树耗时: ' + domReadyTime);\n\nconsole.log('load事件耗时: ' + loadEventTime);\n\nconsole.log('加载时间耗时: ' + loadTime);\n}\n```\n\n\n### Navigation Timing\n\n\n\n### Resource Timing\n\n\n\n### 页面埋点计时\n 使用new Date()时间戳记录操作的时间点\n\n\n## 工具\n### chrome Develop Tools\n\n### Profile工具\n\n\n\n原文：\n[前端性能分析](https://my.oschina.net/zhangstephen/blog/1601380)\n[谷歌性能优化文章](https://developers.google.cn/web/fundamentals/performance/why-performance-matters/)\n","slug":"性能优化工具分析","published":1,"updated":"2018-07-22T02:06:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uyt003d7q0tkjql0j9q","content":"<p>在网站和应用程序变的越来越丰富的今天，web应用对网络和设备资源的要求也越来越高。配合各种方式、手段、辅助系统，进行前端优化的最终目的都是提升用户体验，改善页面性能。<br>我们常常竭尽全力进行前端页面优化，但却忽略了这样做的效果和意义。先不急于探究前端优化具体可以怎样去做，先看看什么是前端性能，应该怎样去了解和评价前端页面的性能。</p>\n<a id=\"more\"></a>\n<h2 id=\"浏览器API\"><a href=\"#浏览器API\" class=\"headerlink\" title=\"浏览器API\"></a>浏览器API</h2><h3 id=\"Performance-Timing-API\"><a href=\"#Performance-Timing-API\" class=\"headerlink\" title=\"Performance Timing API\"></a>Performance Timing API</h3><p>下图为W3C标准中Performance Timing资源加载和解析过程记录各个关键点的示意图，浏览器中加载和解析一个HTML文件的详细过程先后经历unload、redirect、App Cache、DNS、TCP、Request、Response、Processing、onload几个阶段，每个过程开始和结束的关键时间戳浏览器已经使用performance.timing来记录了，所以根据这个记录并结合简单的计算，我们就可以得到页面中每个过程所消耗的时间。</p>\n<p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/performance.jpg\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">performanceTest</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> timing = performance.timing,</span><br><span class=\"line\"></span><br><span class=\"line\">readyStart = timing.fetchStart - timing.navigationStart,</span><br><span class=\"line\"></span><br><span class=\"line\">redirectTime = timing.redirectEnd - timing.redirectStart,</span><br><span class=\"line\"></span><br><span class=\"line\">appcacheTime = timing.domainLookupStart - timing.fetchStart,</span><br><span class=\"line\"></span><br><span class=\"line\">unloadEventTime = timing.unloadEventEnd - timing.unloadEventStart,</span><br><span class=\"line\"></span><br><span class=\"line\">lookupDomainTime = timing.domainLookupEnd - timing.domainLookupStart,</span><br><span class=\"line\"></span><br><span class=\"line\">connectTime = timing.connectEnd - timing.connectStart,</span><br><span class=\"line\"></span><br><span class=\"line\">requestTime = timing.responseEnd - timing.requestStart,</span><br><span class=\"line\"></span><br><span class=\"line\">initDomTreeTime = timing.domInteractive - timing.responseEnd,</span><br><span class=\"line\"></span><br><span class=\"line\">domReadyTime = timing.domComplete - timing.domInteractive,</span><br><span class=\"line\"></span><br><span class=\"line\">loadEventTime = timing.loadEventEnd - timing.loadEventStart,</span><br><span class=\"line\"></span><br><span class=\"line\">loadTime = timing.loadEventEnd - timing.navigationStart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'准备新页面时间耗时: '</span> + readyStart);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'redirect 重定向耗时: '</span> + redirectTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Appcache 耗时: '</span> + appcacheTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'unload 前文档耗时: '</span> + unloadEventTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'DNS 查询耗时: '</span> + lookupDomainTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'TCP连接耗时: '</span> + connectTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'request请求耗时: '</span> + requestTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'请求完毕至DOM加载: '</span> + initDomTreeTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'解析DOM树耗时: '</span> + domReadyTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'load事件耗时: '</span> + loadEventTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'加载时间耗时: '</span> + loadTime);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Navigation-Timing\"><a href=\"#Navigation-Timing\" class=\"headerlink\" title=\"Navigation Timing\"></a>Navigation Timing</h3><h3 id=\"Resource-Timing\"><a href=\"#Resource-Timing\" class=\"headerlink\" title=\"Resource Timing\"></a>Resource Timing</h3><h3 id=\"页面埋点计时\"><a href=\"#页面埋点计时\" class=\"headerlink\" title=\"页面埋点计时\"></a>页面埋点计时</h3><p> 使用new Date()时间戳记录操作的时间点</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"chrome-Develop-Tools\"><a href=\"#chrome-Develop-Tools\" class=\"headerlink\" title=\"chrome Develop Tools\"></a>chrome Develop Tools</h3><h3 id=\"Profile工具\"><a href=\"#Profile工具\" class=\"headerlink\" title=\"Profile工具\"></a>Profile工具</h3><p>原文：<br><a href=\"https://my.oschina.net/zhangstephen/blog/1601380\" target=\"_blank\" rel=\"noopener\">前端性能分析</a><br><a href=\"https://developers.google.cn/web/fundamentals/performance/why-performance-matters/\" target=\"_blank\" rel=\"noopener\">谷歌性能优化文章</a></p>\n","site":{"data":{}},"excerpt":"<p>在网站和应用程序变的越来越丰富的今天，web应用对网络和设备资源的要求也越来越高。配合各种方式、手段、辅助系统，进行前端优化的最终目的都是提升用户体验，改善页面性能。<br>我们常常竭尽全力进行前端页面优化，但却忽略了这样做的效果和意义。先不急于探究前端优化具体可以怎样去做，先看看什么是前端性能，应该怎样去了解和评价前端页面的性能。</p>","more":"<h2 id=\"浏览器API\"><a href=\"#浏览器API\" class=\"headerlink\" title=\"浏览器API\"></a>浏览器API</h2><h3 id=\"Performance-Timing-API\"><a href=\"#Performance-Timing-API\" class=\"headerlink\" title=\"Performance Timing API\"></a>Performance Timing API</h3><p>下图为W3C标准中Performance Timing资源加载和解析过程记录各个关键点的示意图，浏览器中加载和解析一个HTML文件的详细过程先后经历unload、redirect、App Cache、DNS、TCP、Request、Response、Processing、onload几个阶段，每个过程开始和结束的关键时间戳浏览器已经使用performance.timing来记录了，所以根据这个记录并结合简单的计算，我们就可以得到页面中每个过程所消耗的时间。</p>\n<p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/performance.jpg\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">performanceTest</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> timing = performance.timing,</span><br><span class=\"line\"></span><br><span class=\"line\">readyStart = timing.fetchStart - timing.navigationStart,</span><br><span class=\"line\"></span><br><span class=\"line\">redirectTime = timing.redirectEnd - timing.redirectStart,</span><br><span class=\"line\"></span><br><span class=\"line\">appcacheTime = timing.domainLookupStart - timing.fetchStart,</span><br><span class=\"line\"></span><br><span class=\"line\">unloadEventTime = timing.unloadEventEnd - timing.unloadEventStart,</span><br><span class=\"line\"></span><br><span class=\"line\">lookupDomainTime = timing.domainLookupEnd - timing.domainLookupStart,</span><br><span class=\"line\"></span><br><span class=\"line\">connectTime = timing.connectEnd - timing.connectStart,</span><br><span class=\"line\"></span><br><span class=\"line\">requestTime = timing.responseEnd - timing.requestStart,</span><br><span class=\"line\"></span><br><span class=\"line\">initDomTreeTime = timing.domInteractive - timing.responseEnd,</span><br><span class=\"line\"></span><br><span class=\"line\">domReadyTime = timing.domComplete - timing.domInteractive,</span><br><span class=\"line\"></span><br><span class=\"line\">loadEventTime = timing.loadEventEnd - timing.loadEventStart,</span><br><span class=\"line\"></span><br><span class=\"line\">loadTime = timing.loadEventEnd - timing.navigationStart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'准备新页面时间耗时: '</span> + readyStart);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'redirect 重定向耗时: '</span> + redirectTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Appcache 耗时: '</span> + appcacheTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'unload 前文档耗时: '</span> + unloadEventTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'DNS 查询耗时: '</span> + lookupDomainTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'TCP连接耗时: '</span> + connectTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'request请求耗时: '</span> + requestTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'请求完毕至DOM加载: '</span> + initDomTreeTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'解析DOM树耗时: '</span> + domReadyTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'load事件耗时: '</span> + loadEventTime);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'加载时间耗时: '</span> + loadTime);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Navigation-Timing\"><a href=\"#Navigation-Timing\" class=\"headerlink\" title=\"Navigation Timing\"></a>Navigation Timing</h3><h3 id=\"Resource-Timing\"><a href=\"#Resource-Timing\" class=\"headerlink\" title=\"Resource Timing\"></a>Resource Timing</h3><h3 id=\"页面埋点计时\"><a href=\"#页面埋点计时\" class=\"headerlink\" title=\"页面埋点计时\"></a>页面埋点计时</h3><p> 使用new Date()时间戳记录操作的时间点</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"chrome-Develop-Tools\"><a href=\"#chrome-Develop-Tools\" class=\"headerlink\" title=\"chrome Develop Tools\"></a>chrome Develop Tools</h3><h3 id=\"Profile工具\"><a href=\"#Profile工具\" class=\"headerlink\" title=\"Profile工具\"></a>Profile工具</h3><p>原文：<br><a href=\"https://my.oschina.net/zhangstephen/blog/1601380\" target=\"_blank\" rel=\"noopener\">前端性能分析</a><br><a href=\"https://developers.google.cn/web/fundamentals/performance/why-performance-matters/\" target=\"_blank\" rel=\"noopener\">谷歌性能优化文章</a></p>"},{"title":"说大人，则渺之。","date":"2018-06-17T16:00:00.000Z","_content":"\n孟子曰：说①大人，则藐之，勿视其巍巍然。堂高数仞，榱题②数尺，我得志，弗为也。食前方丈，侍妾数百人，我得志，弗为也。般乐饮酒，驱骋田猎，后车千乘，我得志，弗为也。在彼者，皆我所不为也；在我者，皆古之制也。吾何畏彼哉？”\n\n<!--more-->\n\n①说（Shui）：向……进言。\n②榱（cuī）题：也叫“出檐”，指屋檐的前端。\n","source":"_posts/说大人，则渺之。.md","raw":"title: 说大人，则渺之。\ndate: 2018/06/18\ncategories:\n  - 人间不值得\n---\n\n孟子曰：说①大人，则藐之，勿视其巍巍然。堂高数仞，榱题②数尺，我得志，弗为也。食前方丈，侍妾数百人，我得志，弗为也。般乐饮酒，驱骋田猎，后车千乘，我得志，弗为也。在彼者，皆我所不为也；在我者，皆古之制也。吾何畏彼哉？”\n\n<!--more-->\n\n①说（Shui）：向……进言。\n②榱（cuī）题：也叫“出檐”，指屋檐的前端。\n","slug":"说大人，则渺之。","published":1,"updated":"2018-07-01T15:31:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81uyy003g7q0tlfg9flin","content":"<p>孟子曰：说①大人，则藐之，勿视其巍巍然。堂高数仞，榱题②数尺，我得志，弗为也。食前方丈，侍妾数百人，我得志，弗为也。般乐饮酒，驱骋田猎，后车千乘，我得志，弗为也。在彼者，皆我所不为也；在我者，皆古之制也。吾何畏彼哉？”</p>\n<a id=\"more\"></a>\n<p>①说（Shui）：向……进言。<br>②榱（cuī）题：也叫“出檐”，指屋檐的前端。</p>\n","site":{"data":{}},"excerpt":"<p>孟子曰：说①大人，则藐之，勿视其巍巍然。堂高数仞，榱题②数尺，我得志，弗为也。食前方丈，侍妾数百人，我得志，弗为也。般乐饮酒，驱骋田猎，后车千乘，我得志，弗为也。在彼者，皆我所不为也；在我者，皆古之制也。吾何畏彼哉？”</p>","more":"<p>①说（Shui）：向……进言。<br>②榱（cuī）题：也叫“出檐”，指屋檐的前端。</p>"},{"title":"flex布局从懵逼到运用","date":"2018-05-05T16:00:00.000Z","_content":"\n\n<figure>\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"></img>\n</figure>\n\n本文包括了Flex布局的语法介绍，以及几种运用Flex布局实现的实例，涵盖了常见的使用场景。\n\n### 一、Flex 布局是什么？\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n任何一个容器都可以指定为 Flex 布局。\n```\n.box{\n  display: flex;\n}\n```\n行内元素也可以使用 Flex 布局。\n```\n.box{\n  display: inline-flex;\n}\n```\nWebkit 内核的浏览器，必须加上-webkit前缀。\n```\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n```\n注意：**设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效**。\n\n### 二、基本概念\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"></img>\n容器默认存在两根轴，水平的叫做 **主轴**(main axis),垂直的叫做 **交叉轴**(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n### 三、容器的属性\n```\n<div class=\"container\">\n        <div class=\"item\">1</div>\n        <div class=\"item\">2</div>\n        <div class=\"item\">3</div>\n</div>\n```\n以下6个属性设置在容器上\n```\n  flex-direction\n  flex-wrap\n  flex-flow\n  justify-content\n  align-items\n  align-content\n```\n\n#### 1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\n\n```\n  .container {\n    flex-direction: row | row-reverse | column | column-reverse;\n  }\n```\n- row(默认值)：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿。\n\n#### 2. flex-wrap属性，默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\n```\n.container{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n- nowrap（默认）：不换行。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n#### 3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n```\n.container{\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n#### 4.justify-content属性，定义了项目在 **主轴** 上的对齐方式\n```\n.container{\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍\n\n#### 5.align-items属性,定义项目在 **交叉轴** 上如何对齐\n```\n.container{\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n#### 6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n```\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n### 四、项目的属性\n以下6个属性设置在项目上。\n- order\n- flex-grow\n- flex-shrink\n- flex-basis\n- flex\n- align-self\n\n#### 1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n```\n.item {\n  order: <integer>;\n}\n```\n\n####  2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n```\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n#### 3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n```\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n#### 4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）\n浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n```\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n#### 5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n```\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'> <'flex-basis'> ]\n}\n```\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n#### 6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.\n可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch\n```\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n\nflex布局练习代码：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flexDemo.jpg)\nHTML:\n```\n<div class=\"container\">\n    <div class=\"item\">1</div>\n    <div class=\"item\">2</div>\n    <div class=\"item\">3</div>\n    <div class=\"item\">4</div>\n    <div class=\"item\">5</div>\n    <div class=\"item\">6</div>\n    <div class=\"item\">7</div>\n    <div class=\"item\">8</div>\n    <div class=\"item\">9</div>\n    <div class=\"item\">10</div>\n    <div class=\"item\">11</div>\n</div>\n```\nCSS:\n```\n.container {\n    width: 300px;\n    /* height: 400px; */\n    background-color: blanchedalmond;\n    display: flex;\n    flex-flow: row wrap;\n    /* 默认 */\n    justify-content: flex-start;\n    align-items: flex-start;\n    align-content: space-around;\n}\n.container .item {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 5px;\n    width: 50px;\n    height: 50px;\n    background-color: rgba(0, 0, 255, 0.315)\n}\n.container .item:nth-of-type(1) {\n    flex-grow: 7;\n    width: 100px;\n    height: 100px;\n}\n.container .item:nth-of-type(2) {\n    flex-shrink: 0;\n    /*flex-shrink为0时，即使空间不够，也不缩小*/\n    width: 100px;\n    height: 100px;\n}\n.container .item:nth-of-type(3) {\n    /* order: 1; */\n    flex-basis: 200px;\n    width: 200px;\n    height: 60px;\n}\n.container .item:nth-of-type(4) {\n    width: 30px;\n    height: 30px;\n}\n.container .item:nth-of-type(5) {\n    width: 70px;\n    height: 70px;\n}\n```\n\n### 五、flex运用实例\n1. 如何使用flex布局绘制筛子的6个面？\n\n\n2. 网格布局\n\n3. 圣杯布局\n\n4. 输入框组件的布局\n\n5. 悬挂式布局\n\n6. 固定的底栏\n\n7. 流式布局\n\n未完待续...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n原文：阮老师的博客\n- http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$\n- http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\n","source":"_posts/flex布局从入门到运用.md","raw":"title: flex布局从懵逼到运用\ndate: 2018/05/06\ncategories: 前端基础\n---\n\n\n<figure>\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"></img>\n</figure>\n\n本文包括了Flex布局的语法介绍，以及几种运用Flex布局实现的实例，涵盖了常见的使用场景。\n\n### 一、Flex 布局是什么？\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n任何一个容器都可以指定为 Flex 布局。\n```\n.box{\n  display: flex;\n}\n```\n行内元素也可以使用 Flex 布局。\n```\n.box{\n  display: inline-flex;\n}\n```\nWebkit 内核的浏览器，必须加上-webkit前缀。\n```\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n```\n注意：**设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效**。\n\n### 二、基本概念\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n<img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"></img>\n容器默认存在两根轴，水平的叫做 **主轴**(main axis),垂直的叫做 **交叉轴**(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n### 三、容器的属性\n```\n<div class=\"container\">\n        <div class=\"item\">1</div>\n        <div class=\"item\">2</div>\n        <div class=\"item\">3</div>\n</div>\n```\n以下6个属性设置在容器上\n```\n  flex-direction\n  flex-wrap\n  flex-flow\n  justify-content\n  align-items\n  align-content\n```\n\n#### 1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\n\n```\n  .container {\n    flex-direction: row | row-reverse | column | column-reverse;\n  }\n```\n- row(默认值)：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿。\n\n#### 2. flex-wrap属性，默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\n```\n.container{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n- nowrap（默认）：不换行。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n#### 3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n```\n.container{\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n#### 4.justify-content属性，定义了项目在 **主轴** 上的对齐方式\n```\n.container{\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍\n\n#### 5.align-items属性,定义项目在 **交叉轴** 上如何对齐\n```\n.container{\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n#### 6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n```\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n### 四、项目的属性\n以下6个属性设置在项目上。\n- order\n- flex-grow\n- flex-shrink\n- flex-basis\n- flex\n- align-self\n\n#### 1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n```\n.item {\n  order: <integer>;\n}\n```\n\n####  2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n```\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n#### 3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n```\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n#### 4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）\n浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n```\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n#### 5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n```\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'> <'flex-basis'> ]\n}\n```\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n#### 6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.\n可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch\n```\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n\nflex布局练习代码：\n![](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flexDemo.jpg)\nHTML:\n```\n<div class=\"container\">\n    <div class=\"item\">1</div>\n    <div class=\"item\">2</div>\n    <div class=\"item\">3</div>\n    <div class=\"item\">4</div>\n    <div class=\"item\">5</div>\n    <div class=\"item\">6</div>\n    <div class=\"item\">7</div>\n    <div class=\"item\">8</div>\n    <div class=\"item\">9</div>\n    <div class=\"item\">10</div>\n    <div class=\"item\">11</div>\n</div>\n```\nCSS:\n```\n.container {\n    width: 300px;\n    /* height: 400px; */\n    background-color: blanchedalmond;\n    display: flex;\n    flex-flow: row wrap;\n    /* 默认 */\n    justify-content: flex-start;\n    align-items: flex-start;\n    align-content: space-around;\n}\n.container .item {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 5px;\n    width: 50px;\n    height: 50px;\n    background-color: rgba(0, 0, 255, 0.315)\n}\n.container .item:nth-of-type(1) {\n    flex-grow: 7;\n    width: 100px;\n    height: 100px;\n}\n.container .item:nth-of-type(2) {\n    flex-shrink: 0;\n    /*flex-shrink为0时，即使空间不够，也不缩小*/\n    width: 100px;\n    height: 100px;\n}\n.container .item:nth-of-type(3) {\n    /* order: 1; */\n    flex-basis: 200px;\n    width: 200px;\n    height: 60px;\n}\n.container .item:nth-of-type(4) {\n    width: 30px;\n    height: 30px;\n}\n.container .item:nth-of-type(5) {\n    width: 70px;\n    height: 70px;\n}\n```\n\n### 五、flex运用实例\n1. 如何使用flex布局绘制筛子的6个面？\n\n\n2. 网格布局\n\n3. 圣杯布局\n\n4. 输入框组件的布局\n\n5. 悬挂式布局\n\n6. 固定的底栏\n\n7. 流式布局\n\n未完待续...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n原文：阮老师的博客\n- http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$\n- http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\n","slug":"flex布局从入门到运用","published":1,"updated":"2018-05-12T11:58:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81wft00537q0t8l3ftih4","content":"<figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"><br></figure>\n\n<p>本文包括了Flex布局的语法介绍，以及几种运用Flex布局实现的实例，涵盖了常见的使用场景。</p>\n<h3 id=\"一、Flex-布局是什么？\"><a href=\"#一、Flex-布局是什么？\" class=\"headerlink\" title=\"一、Flex 布局是什么？\"></a>一、Flex 布局是什么？</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>行内元素也可以使用 Flex 布局。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Webkit 内核的浏览器，必须加上-webkit前缀。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex; <span class=\"comment\">/* Safari */</span></span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：<strong>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</strong>。</p>\n<h3 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"><br>容器默认存在两根轴，水平的叫做 <strong>主轴</strong>(main axis),垂直的叫做 <strong>交叉轴</strong>(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<h3 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h3><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">1</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">2</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">3</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以下6个属性设置在容器上<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">flex-direction</span></span><br><span class=\"line\"><span class=\"attribute\">flex-wrap</span></span><br><span class=\"line\"><span class=\"attribute\">flex-flow</span></span><br><span class=\"line\"><span class=\"attribute\">justify-content</span></span><br><span class=\"line\"><span class=\"attribute\">align-items</span></span><br><span class=\"line\"><span class=\"attribute\">align-content</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\"><a href=\"#1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\" class=\"headerlink\" title=\"1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\"></a>1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>row(默认值)：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h4 id=\"2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\"><a href=\"#2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\" class=\"headerlink\" title=\"2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\"></a>2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>nowrap（默认）：不换行。</li>\n<li>wrap：换行，第一行在上方。</li>\n<li>wrap-reverse：换行，第一行在下方。</li>\n</ul>\n<h4 id=\"3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap\"><a href=\"#3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap\" class=\"headerlink\" title=\"3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\"></a>3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-justify-content属性，定义了项目在-主轴-上的对齐方式\"><a href=\"#4-justify-content属性，定义了项目在-主轴-上的对齐方式\" class=\"headerlink\" title=\"4.justify-content属性，定义了项目在 主轴 上的对齐方式\"></a>4.justify-content属性，定义了项目在 <strong>主轴</strong> 上的对齐方式</h4><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">  justify-content: flex-start | flex-<span class=\"keyword\">end</span> | center | <span class=\"literal\">space</span>-<span class=\"keyword\">between</span> | <span class=\"literal\">space</span>-<span class=\"keyword\">around</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>\n</ul>\n<h4 id=\"5-align-items属性-定义项目在-交叉轴-上如何对齐\"><a href=\"#5-align-items属性-定义项目在-交叉轴-上如何对齐\" class=\"headerlink\" title=\"5.align-items属性,定义项目在 交叉轴 上如何对齐\"></a>5.align-items属性,定义项目在 <strong>交叉轴</strong> 上如何对齐</h4><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">  align-items: flex-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">baseline</span> | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<h4 id=\"6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\"><a href=\"#6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\" class=\"headerlink\" title=\"6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\"></a>6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</h4><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  align-content: flex-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">space</span>-between | <span class=\"type\">space</span>-around | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h4 id=\"1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"><a href=\"#1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\" class=\"headerlink\" title=\"1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"></a>1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\"><a href=\"#2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\" class=\"headerlink\" title=\"2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\"></a>2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h4 id=\"3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\"><a href=\"#3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\" class=\"headerlink\" title=\"3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\"></a>3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<h4 id=\"4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）\"><a href=\"#4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）\" class=\"headerlink\" title=\"4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）\"></a>4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）</h4><p>浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-basis</span>: &lt;length&gt; | auto; <span class=\"comment\">/* default auto */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>\n<h4 id=\"5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。\"><a href=\"#5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。\" class=\"headerlink\" title=\"5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\"></a>5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt; &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h4 id=\"6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式\"><a href=\"#6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式\" class=\"headerlink\" title=\"6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.\"></a>6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.</h4><p>可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch<br><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  align-self: <span class=\"built_in\">auto</span> | <span class=\"type\">flex</span>-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">baseline</span> | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>\n<p>flex布局练习代码：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flexDemo.jpg\" alt=\"\"><br>HTML:<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">1</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">2</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">3</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">4</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">5</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">6</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">7</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">8</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">9</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">10</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">11</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* height: 400px; */</span></span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blanchedalmond;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-flow</span>: row wrap;</span><br><span class=\"line\">    <span class=\"comment\">/* 默认 */</span></span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: flex-start;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: flex-start;</span><br><span class=\"line\">    <span class=\"attribute\">align-content</span>: space-around;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgba</span>(0, 0, 255, 0.315)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(1)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex-grow</span>: <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(2)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex-shrink</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*flex-shrink为0时，即使空间不够，也不缩小*/</span></span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(3)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* order: 1; */</span></span><br><span class=\"line\">    <span class=\"attribute\">flex-basis</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(4)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(5)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、flex运用实例\"><a href=\"#五、flex运用实例\" class=\"headerlink\" title=\"五、flex运用实例\"></a>五、flex运用实例</h3><ol>\n<li>如何使用flex布局绘制筛子的6个面？</li>\n</ol>\n<ol start=\"2\">\n<li><p>网格布局</p>\n</li>\n<li><p>圣杯布局</p>\n</li>\n<li><p>输入框组件的布局</p>\n</li>\n<li><p>悬挂式布局</p>\n</li>\n<li><p>固定的底栏</p>\n</li>\n<li><p>流式布局</p>\n</li>\n</ol>\n<p>未完待续…</p>\n<p>原文：阮老师的博客</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"><br></figure>\n\n<p>本文包括了Flex布局的语法介绍，以及几种运用Flex布局实现的实例，涵盖了常见的使用场景。</p>\n<h3 id=\"一、Flex-布局是什么？\"><a href=\"#一、Flex-布局是什么？\" class=\"headerlink\" title=\"一、Flex 布局是什么？\"></a>一、Flex 布局是什么？</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>行内元素也可以使用 Flex 布局。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Webkit 内核的浏览器，必须加上-webkit前缀。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex; <span class=\"comment\">/* Safari */</span></span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：<strong>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</strong>。</p>\n<h3 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png\"><br>容器默认存在两根轴，水平的叫做 <strong>主轴</strong>(main axis),垂直的叫做 <strong>交叉轴</strong>(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<h3 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h3><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">1</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">2</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">3</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以下6个属性设置在容器上<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">flex-direction</span></span><br><span class=\"line\"><span class=\"attribute\">flex-wrap</span></span><br><span class=\"line\"><span class=\"attribute\">flex-flow</span></span><br><span class=\"line\"><span class=\"attribute\">justify-content</span></span><br><span class=\"line\"><span class=\"attribute\">align-items</span></span><br><span class=\"line\"><span class=\"attribute\">align-content</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\"><a href=\"#1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\" class=\"headerlink\" title=\"1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值\"></a>1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>row(默认值)：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h4 id=\"2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\"><a href=\"#2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\" class=\"headerlink\" title=\"2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值\"></a>2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>nowrap（默认）：不换行。</li>\n<li>wrap：换行，第一行在上方。</li>\n<li>wrap-reverse：换行，第一行在下方。</li>\n</ul>\n<h4 id=\"3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap\"><a href=\"#3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap\" class=\"headerlink\" title=\"3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\"></a>3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-justify-content属性，定义了项目在-主轴-上的对齐方式\"><a href=\"#4-justify-content属性，定义了项目在-主轴-上的对齐方式\" class=\"headerlink\" title=\"4.justify-content属性，定义了项目在 主轴 上的对齐方式\"></a>4.justify-content属性，定义了项目在 <strong>主轴</strong> 上的对齐方式</h4><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">  justify-content: flex-start | flex-<span class=\"keyword\">end</span> | center | <span class=\"literal\">space</span>-<span class=\"keyword\">between</span> | <span class=\"literal\">space</span>-<span class=\"keyword\">around</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>\n</ul>\n<h4 id=\"5-align-items属性-定义项目在-交叉轴-上如何对齐\"><a href=\"#5-align-items属性-定义项目在-交叉轴-上如何对齐\" class=\"headerlink\" title=\"5.align-items属性,定义项目在 交叉轴 上如何对齐\"></a>5.align-items属性,定义项目在 <strong>交叉轴</strong> 上如何对齐</h4><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">  align-items: flex-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">baseline</span> | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<h4 id=\"6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\"><a href=\"#6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\" class=\"headerlink\" title=\"6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\"></a>6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</h4><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  align-content: flex-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">space</span>-between | <span class=\"type\">space</span>-around | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h4 id=\"1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"><a href=\"#1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\" class=\"headerlink\" title=\"1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\"></a>1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\"><a href=\"#2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\" class=\"headerlink\" title=\"2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\"></a>2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h4 id=\"3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\"><a href=\"#3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\" class=\"headerlink\" title=\"3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\"></a>3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<h4 id=\"4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）\"><a href=\"#4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）\" class=\"headerlink\" title=\"4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）\"></a>4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）</h4><p>浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-basis</span>: &lt;length&gt; | auto; <span class=\"comment\">/* default auto */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>\n<h4 id=\"5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。\"><a href=\"#5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。\" class=\"headerlink\" title=\"5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\"></a>5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt; &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h4 id=\"6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式\"><a href=\"#6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式\" class=\"headerlink\" title=\"6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.\"></a>6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.</h4><p>可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch<br><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  align-self: <span class=\"built_in\">auto</span> | <span class=\"type\">flex</span>-start | <span class=\"type\">flex</span>-<span class=\"keyword\">end</span> | <span class=\"type\">center</span> | <span class=\"type\">baseline</span> | <span class=\"type\">stretch</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>\n<p>flex布局练习代码：<br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flexDemo.jpg\" alt=\"\"><br>HTML:<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">1</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">2</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">3</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">4</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">5</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">6</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">7</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">8</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">9</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">10</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"item\"</span>&gt;<span class=\"number\">11</span>&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* height: 400px; */</span></span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blanchedalmond;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-flow</span>: row wrap;</span><br><span class=\"line\">    <span class=\"comment\">/* 默认 */</span></span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: flex-start;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: flex-start;</span><br><span class=\"line\">    <span class=\"attribute\">align-content</span>: space-around;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgba</span>(0, 0, 255, 0.315)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(1)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex-grow</span>: <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(2)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex-shrink</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*flex-shrink为0时，即使空间不够，也不缩小*/</span></span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(3)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* order: 1; */</span></span><br><span class=\"line\">    <span class=\"attribute\">flex-basis</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(4)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:nth-of-type(5)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、flex运用实例\"><a href=\"#五、flex运用实例\" class=\"headerlink\" title=\"五、flex运用实例\"></a>五、flex运用实例</h3><ol>\n<li>如何使用flex布局绘制筛子的6个面？</li>\n</ol>\n<ol start=\"2\">\n<li><p>网格布局</p>\n</li>\n<li><p>圣杯布局</p>\n</li>\n<li><p>输入框组件的布局</p>\n</li>\n<li><p>悬挂式布局</p>\n</li>\n<li><p>固定的底栏</p>\n</li>\n<li><p>流式布局</p>\n</li>\n</ol>\n<p>未完待续…</p>\n<p>原文：阮老师的博客</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li>\n</ul>\n"},{"title":"函数式编程入门","date":"2018-06-18T16:00:00.000Z","toc":true,"front-matter":"comments:true","_content":"\n### 什么是函数式编程？\n它详细的解释可以参考维基百科。缘起数学家 Alonzo Church 提出了 Lambda 演算的概念，可以用函数组合的方式来描述计算过程，换句话来说，**如果一个问题能够用一系列函数组合的算法来表达，那么这个问题就认为是可计算的。**\n\n<figure>\n![Gardenia jasminoides](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/fl.jpeg)\n</figure>\n<!--more-->\n\n它和面向对象编程一样，也是一种编程范式。强调执行的过程而非结果，通过一系列的嵌套的函数调用，完成一个运算过程。它主要有以下几个特点：\n\n- 函数是\"一等公民\"：函数优先，和其他数据类型一样。\n\n- 只用\"表达式\"，不用\"语句\"：通过表达式（expression）计算过程得到一个返回值，而不是通过一个语句（statement）修改某一个状态。\n\n- 无副作用：不污染变量，同一个输入永远得到同一个数据。\n\n- 不可变性：前面一提到，不修改变量，返回一个新的值。\n\n\n### 范畴论与函数式编程\n- 在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。\n- 所以，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。\n- **本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。**\n\n### 函数的合成与柯里化\n函数式编程有两个最基本的运算：**合成和柯里化**。\n#### 函数的合成\n如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做\"函数的合成\"（compose）。\n合成两个函数的简单代码如下。\n```\nconst compose = function (f, g) {\n  return function (x) {\n    return f(g(x));\n  };\n}\n```\n函数的合成还必须满足结合律。\n```\ncompose(f, compose(g, h))\n// 等同于\ncompose(compose(f, g), h)\n// 等同于\ncompose(f, g, h)\n```\n**合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？**\n前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。\n\n#### 柯里化\nf(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。\n**这时就需要函数柯里化了。所谓\"柯里化\"，就是把一个多参数的函数，转化为单参数函数。**\n```\n// 柯里化之前\nfunction add(x, y) {\n  return x + y;\n}\n\nadd(1, 2) // 3\n\n// 柯里化之后\nfunction addX(y) {\n  return function (x) {\n    return x + y;\n  };\n}\n\naddX(2)(1) // 3\n```\n\n有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。\n\n#### 函子\n函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。\n\n\n\n\n\n\n### 函数式编程在前端开发中的应用\n函数式编程的概念其实出来也已经好几十年了，我们能在很多编程语言身上看到它的身影。比如比较纯粹的 Haskell，以及一些语言开始逐渐成为多范式编程语言，比如 Swift，还有 Kotlin，Java，Js 等都开始具备函数式编程的特性。这么多语言开始逐渐有了支持，函数式编程对于我们的生活到底能够带来一些什么好处呢?\n\n提到现代前端开发，那么 React 肯定是逃不开的一个话题。在 React 技术栈中，函数式编程有哪些体现呢？\n\n####  Stateless components\n在 React 0.14 之后推出的，先来看一段代码\n```\nfunction MyComponent(props) {\n  return <div>My props name {props.name}</div>\n}\n```\n这是一个简单的无状态组件，我们没有用createClass或者是extends React.Component来创建一个组件，而是通过一个 Pure function 返回了一个组件。\n那么这里的好处是什么呢？\n\n1. 简洁，一眼可以看出这个组件的作用；\n\n2. 无副作用，只要传入同一个 props 那么 render 出来的组件一定是相同的；\n\n3. 测试更友好；\n\n4. 没有this，要知道this还是难倒了好多英雄好汉的；\n\n5. 更容易实现 SSR（这一点我并未考证，有知道的朋友可以补充）。\n\n当然，使用Stateless component并不是万能的，可以很明显的看到没有了 React 的生命周期，这个问题通常我们会结合 HOC 来解决。你看这一点就印证了前面说的，通过函数的组合完成对结果的表达，是不是很有意思。\n\n####  Redux\n在前端应用越来越复杂的今天，数据流管理是一件很重要的事，Redux 就是来解决这个问题的。它是 Flux 架构的演化实现，官方 GitHub 解释为 **Predictable state container（可预测状态机）。**\n\n在 Redux 中我们存在一个单的树形结构的 state，单一数据源降低了多数据源的信任问题。State 是通过每个 reducer 的结果组合而来的，每个 reducer 都是一个 Pure function，如下：\n```\nexport const isLoading = (state = false, action) => {\n  switch (action.type) {\n    case MarketActionsTypes.FETCH_MARKET_DATA_START: {\n      return false;\n    }\n    default:\n      return false;\n  }\n};\n```\n**在 reducer 中不会直接修改每个 state 中的状态，而是返回一个新的状态，然后整个 state 的结果通过一个个 reducer 的结果归纳出来。** 我们来看 reducer 源码是怎么工作的：\n```\n....\n    // from https://github.com/reduxjs/redux/blob/b02310b359a0832f65873d024570d411b465ced9/src/combineReducers.js#L162\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === 'undefined') {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    return hasChanged ? nextState : state\n....\n```\n我们可以很直观的看到，最后的 state 结果是通过将每个 reducer 生成的局部结果组合起来得到一个新的 nextState，而不是直接在原有的 state 上进行修改。\n\n所以，我们再回过头来看看它的定义——可预测状态机。\n**每个 reducer 都是一个纯函数，只要输入恒定，那么输出肯定是恒定的。同时，无副作用的特性可以保证 state 不会被意外修改，那么整个应用的 state 都是可以准确的知道的。**\n最终的结果可以通过一系列的信息组合得来，这是一个很重要的改变。\n\n在函数式编程中，我们将一个个复杂的问题抽象成一个个过程的表达，然后再将不同的过程结果组合起来，更加容易找到问题的解决办法。对于我们在其他领域的编码也是一样的道理，剥离问题表面，还原问题本质。有了这样的思维的时候，当你和别人在看同一个问题的时候，你会更容易有一种拨云见日的感觉。\n\n除了抽象的能力，分解问题的能力也是很重要的一个启发。将问题化小，分而治之，然后组合结果。当然这个能力不仅仅是函数式编程才具备的，分治法在很多算法里已经体现得淋漓尽致了。不过这里还是想再提一下这个话题，分而治之可以在各个维度的工作上进行运用，小到一个算法的具体实现，然后到一个问题的过程分解，甚至大到一个工作任务的拆解，都可以用分而治之的思维去寻找解题之法。\n\n当然函数式编程还有其他的一些不足之处，比如有人会说在函数式编程中数据复制可能会比较严重，可能会造成性能问题。这个问题我是这样看的，局部来说他可能确实看起来会存在一定的影响。但是从另一个角度来说，在我们使用函数式编程的时候，不用担心全局变量被破坏，没有执行顺序的依赖。我们在并行编程的时候，也不需要依赖于过多的锁的，那么反而最终可以提升最终性能。\n\n\n\n\n参考：\n- [函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)\n- [漫谈函数式编程在前后端开发中的应用](https://mp.weixin.qq.com/s/25Azr08BJivOBmPbkYwKTQ)\n","source":"_posts/函数式编程入门.md","raw":"title: 函数式编程入门\ndate: 2018/06/19\ncategories: 技术思想\ntoc: true\nfront-matter:\n  comments:true\ntags:\n  - 函数式编程\n---\n\n### 什么是函数式编程？\n它详细的解释可以参考维基百科。缘起数学家 Alonzo Church 提出了 Lambda 演算的概念，可以用函数组合的方式来描述计算过程，换句话来说，**如果一个问题能够用一系列函数组合的算法来表达，那么这个问题就认为是可计算的。**\n\n<figure>\n![Gardenia jasminoides](https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/fl.jpeg)\n</figure>\n<!--more-->\n\n它和面向对象编程一样，也是一种编程范式。强调执行的过程而非结果，通过一系列的嵌套的函数调用，完成一个运算过程。它主要有以下几个特点：\n\n- 函数是\"一等公民\"：函数优先，和其他数据类型一样。\n\n- 只用\"表达式\"，不用\"语句\"：通过表达式（expression）计算过程得到一个返回值，而不是通过一个语句（statement）修改某一个状态。\n\n- 无副作用：不污染变量，同一个输入永远得到同一个数据。\n\n- 不可变性：前面一提到，不修改变量，返回一个新的值。\n\n\n### 范畴论与函数式编程\n- 在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。\n- 所以，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。\n- **本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。**\n\n### 函数的合成与柯里化\n函数式编程有两个最基本的运算：**合成和柯里化**。\n#### 函数的合成\n如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做\"函数的合成\"（compose）。\n合成两个函数的简单代码如下。\n```\nconst compose = function (f, g) {\n  return function (x) {\n    return f(g(x));\n  };\n}\n```\n函数的合成还必须满足结合律。\n```\ncompose(f, compose(g, h))\n// 等同于\ncompose(compose(f, g), h)\n// 等同于\ncompose(f, g, h)\n```\n**合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？**\n前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。\n\n#### 柯里化\nf(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。\n**这时就需要函数柯里化了。所谓\"柯里化\"，就是把一个多参数的函数，转化为单参数函数。**\n```\n// 柯里化之前\nfunction add(x, y) {\n  return x + y;\n}\n\nadd(1, 2) // 3\n\n// 柯里化之后\nfunction addX(y) {\n  return function (x) {\n    return x + y;\n  };\n}\n\naddX(2)(1) // 3\n```\n\n有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。\n\n#### 函子\n函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。\n\n\n\n\n\n\n### 函数式编程在前端开发中的应用\n函数式编程的概念其实出来也已经好几十年了，我们能在很多编程语言身上看到它的身影。比如比较纯粹的 Haskell，以及一些语言开始逐渐成为多范式编程语言，比如 Swift，还有 Kotlin，Java，Js 等都开始具备函数式编程的特性。这么多语言开始逐渐有了支持，函数式编程对于我们的生活到底能够带来一些什么好处呢?\n\n提到现代前端开发，那么 React 肯定是逃不开的一个话题。在 React 技术栈中，函数式编程有哪些体现呢？\n\n####  Stateless components\n在 React 0.14 之后推出的，先来看一段代码\n```\nfunction MyComponent(props) {\n  return <div>My props name {props.name}</div>\n}\n```\n这是一个简单的无状态组件，我们没有用createClass或者是extends React.Component来创建一个组件，而是通过一个 Pure function 返回了一个组件。\n那么这里的好处是什么呢？\n\n1. 简洁，一眼可以看出这个组件的作用；\n\n2. 无副作用，只要传入同一个 props 那么 render 出来的组件一定是相同的；\n\n3. 测试更友好；\n\n4. 没有this，要知道this还是难倒了好多英雄好汉的；\n\n5. 更容易实现 SSR（这一点我并未考证，有知道的朋友可以补充）。\n\n当然，使用Stateless component并不是万能的，可以很明显的看到没有了 React 的生命周期，这个问题通常我们会结合 HOC 来解决。你看这一点就印证了前面说的，通过函数的组合完成对结果的表达，是不是很有意思。\n\n####  Redux\n在前端应用越来越复杂的今天，数据流管理是一件很重要的事，Redux 就是来解决这个问题的。它是 Flux 架构的演化实现，官方 GitHub 解释为 **Predictable state container（可预测状态机）。**\n\n在 Redux 中我们存在一个单的树形结构的 state，单一数据源降低了多数据源的信任问题。State 是通过每个 reducer 的结果组合而来的，每个 reducer 都是一个 Pure function，如下：\n```\nexport const isLoading = (state = false, action) => {\n  switch (action.type) {\n    case MarketActionsTypes.FETCH_MARKET_DATA_START: {\n      return false;\n    }\n    default:\n      return false;\n  }\n};\n```\n**在 reducer 中不会直接修改每个 state 中的状态，而是返回一个新的状态，然后整个 state 的结果通过一个个 reducer 的结果归纳出来。** 我们来看 reducer 源码是怎么工作的：\n```\n....\n    // from https://github.com/reduxjs/redux/blob/b02310b359a0832f65873d024570d411b465ced9/src/combineReducers.js#L162\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === 'undefined') {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    return hasChanged ? nextState : state\n....\n```\n我们可以很直观的看到，最后的 state 结果是通过将每个 reducer 生成的局部结果组合起来得到一个新的 nextState，而不是直接在原有的 state 上进行修改。\n\n所以，我们再回过头来看看它的定义——可预测状态机。\n**每个 reducer 都是一个纯函数，只要输入恒定，那么输出肯定是恒定的。同时，无副作用的特性可以保证 state 不会被意外修改，那么整个应用的 state 都是可以准确的知道的。**\n最终的结果可以通过一系列的信息组合得来，这是一个很重要的改变。\n\n在函数式编程中，我们将一个个复杂的问题抽象成一个个过程的表达，然后再将不同的过程结果组合起来，更加容易找到问题的解决办法。对于我们在其他领域的编码也是一样的道理，剥离问题表面，还原问题本质。有了这样的思维的时候，当你和别人在看同一个问题的时候，你会更容易有一种拨云见日的感觉。\n\n除了抽象的能力，分解问题的能力也是很重要的一个启发。将问题化小，分而治之，然后组合结果。当然这个能力不仅仅是函数式编程才具备的，分治法在很多算法里已经体现得淋漓尽致了。不过这里还是想再提一下这个话题，分而治之可以在各个维度的工作上进行运用，小到一个算法的具体实现，然后到一个问题的过程分解，甚至大到一个工作任务的拆解，都可以用分而治之的思维去寻找解题之法。\n\n当然函数式编程还有其他的一些不足之处，比如有人会说在函数式编程中数据复制可能会比较严重，可能会造成性能问题。这个问题我是这样看的，局部来说他可能确实看起来会存在一定的影响。但是从另一个角度来说，在我们使用函数式编程的时候，不用担心全局变量被破坏，没有执行顺序的依赖。我们在并行编程的时候，也不需要依赖于过多的锁的，那么反而最终可以提升最终性能。\n\n\n\n\n参考：\n- [函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)\n- [漫谈函数式编程在前后端开发中的应用](https://mp.weixin.qq.com/s/25Azr08BJivOBmPbkYwKTQ)\n","slug":"函数式编程入门","published":1,"updated":"2018-06-20T13:23:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnn81wg300547q0t2ko92q7v","content":"<h3 id=\"什么是函数式编程？\"><a href=\"#什么是函数式编程？\" class=\"headerlink\" title=\"什么是函数式编程？\"></a>什么是函数式编程？</h3><p>它详细的解释可以参考维基百科。缘起数学家 Alonzo Church 提出了 Lambda 演算的概念，可以用函数组合的方式来描述计算过程，换句话来说，<strong>如果一个问题能够用一系列函数组合的算法来表达，那么这个问题就认为是可计算的。</strong></p>\n<p><figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/fl.jpeg\" alt=\"Gardenia jasminoides\"><br></figure><br><a id=\"more\"></a></p>\n<p>它和面向对象编程一样，也是一种编程范式。强调执行的过程而非结果，通过一系列的嵌套的函数调用，完成一个运算过程。它主要有以下几个特点：</p>\n<ul>\n<li><p>函数是”一等公民”：函数优先，和其他数据类型一样。</p>\n</li>\n<li><p>只用”表达式”，不用”语句”：通过表达式（expression）计算过程得到一个返回值，而不是通过一个语句（statement）修改某一个状态。</p>\n</li>\n<li><p>无副作用：不污染变量，同一个输入永远得到同一个数据。</p>\n</li>\n<li><p>不可变性：前面一提到，不修改变量，返回一个新的值。</p>\n</li>\n</ul>\n<h3 id=\"范畴论与函数式编程\"><a href=\"#范畴论与函数式编程\" class=\"headerlink\" title=\"范畴论与函数式编程\"></a>范畴论与函数式编程</h3><ul>\n<li>在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。</li>\n<li>所以，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</li>\n<li><strong>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。</strong></li>\n</ul>\n<h3 id=\"函数的合成与柯里化\"><a href=\"#函数的合成与柯里化\" class=\"headerlink\" title=\"函数的合成与柯里化\"></a>函数的合成与柯里化</h3><p>函数式编程有两个最基本的运算：<strong>合成和柯里化</strong>。</p>\n<h4 id=\"函数的合成\"><a href=\"#函数的合成\" class=\"headerlink\" title=\"函数的合成\"></a>函数的合成</h4><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。<br>合成两个函数的简单代码如下。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(f, g)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数的合成还必须满足结合律。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(f, compose(g, h)</span></span>)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(compose(f, g)</span></span>, h)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(f, g, h)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？</strong><br>前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。</p>\n<h4 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h4><p>f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。<br><strong>这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</strong><br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 柯里化之前</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 柯里化之后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addX</span><span class=\"params\">(y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addX(<span class=\"number\">2</span>)(<span class=\"number\">1</span>) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。</p>\n<h4 id=\"函子\"><a href=\"#函子\" class=\"headerlink\" title=\"函子\"></a>函子</h4><p>函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。</p>\n<h3 id=\"函数式编程在前端开发中的应用\"><a href=\"#函数式编程在前端开发中的应用\" class=\"headerlink\" title=\"函数式编程在前端开发中的应用\"></a>函数式编程在前端开发中的应用</h3><p>函数式编程的概念其实出来也已经好几十年了，我们能在很多编程语言身上看到它的身影。比如比较纯粹的 Haskell，以及一些语言开始逐渐成为多范式编程语言，比如 Swift，还有 Kotlin，Java，Js 等都开始具备函数式编程的特性。这么多语言开始逐渐有了支持，函数式编程对于我们的生活到底能够带来一些什么好处呢?</p>\n<p>提到现代前端开发，那么 React 肯定是逃不开的一个话题。在 React 技术栈中，函数式编程有哪些体现呢？</p>\n<h4 id=\"Stateless-components\"><a href=\"#Stateless-components\" class=\"headerlink\" title=\"Stateless components\"></a>Stateless components</h4><p>在 React 0.14 之后推出的，先来看一段代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyComponent</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>My props name &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个简单的无状态组件，我们没有用createClass或者是extends React.Component来创建一个组件，而是通过一个 Pure function 返回了一个组件。<br>那么这里的好处是什么呢？</p>\n<ol>\n<li><p>简洁，一眼可以看出这个组件的作用；</p>\n</li>\n<li><p>无副作用，只要传入同一个 props 那么 render 出来的组件一定是相同的；</p>\n</li>\n<li><p>测试更友好；</p>\n</li>\n<li><p>没有this，要知道this还是难倒了好多英雄好汉的；</p>\n</li>\n<li><p>更容易实现 SSR（这一点我并未考证，有知道的朋友可以补充）。</p>\n</li>\n</ol>\n<p>当然，使用Stateless component并不是万能的，可以很明显的看到没有了 React 的生命周期，这个问题通常我们会结合 HOC 来解决。你看这一点就印证了前面说的，通过函数的组合完成对结果的表达，是不是很有意思。</p>\n<h4 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h4><p>在前端应用越来越复杂的今天，数据流管理是一件很重要的事，Redux 就是来解决这个问题的。它是 Flux 架构的演化实现，官方 GitHub 解释为 <strong>Predictable state container（可预测状态机）。</strong></p>\n<p>在 Redux 中我们存在一个单的树形结构的 state，单一数据源降低了多数据源的信任问题。State 是通过每个 reducer 的结果组合而来的，每个 reducer 都是一个 Pure function，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> isLoading = <span class=\"function\">(<span class=\"params\">state = <span class=\"literal\">false</span>, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MarketActionsTypes.FETCH_MARKET_DATA_START: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>在 reducer 中不会直接修改每个 state 中的状态，而是返回一个新的状态，然后整个 state 的结果通过一个个 reducer 的结果归纳出来。</strong> 我们来看 reducer 源码是怎么工作的：<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">....</span><br><span class=\"line\">    <span class=\"comment\">// from https://github.com/reduxjs/redux/blob/b02310b359a0832f65873d024570d411b465ced9/src/combineReducers.js#L162</span></span><br><span class=\"line\">    let hasChanged = <span class=\"keyword\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"built_in\">key</span> = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reducer = finalReducers[<span class=\"built_in\">key</span>]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> previousStateForKey = state[<span class=\"built_in\">key</span>]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (typeof nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> errorMessage = getUndefinedStateErrorMessage(<span class=\"built_in\">key</span>, action)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(errorMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      nextState[<span class=\"built_in\">key</span>] = nextStateForKey</span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure></p>\n<p>我们可以很直观的看到，最后的 state 结果是通过将每个 reducer 生成的局部结果组合起来得到一个新的 nextState，而不是直接在原有的 state 上进行修改。</p>\n<p>所以，我们再回过头来看看它的定义——可预测状态机。<br><strong>每个 reducer 都是一个纯函数，只要输入恒定，那么输出肯定是恒定的。同时，无副作用的特性可以保证 state 不会被意外修改，那么整个应用的 state 都是可以准确的知道的。</strong><br>最终的结果可以通过一系列的信息组合得来，这是一个很重要的改变。</p>\n<p>在函数式编程中，我们将一个个复杂的问题抽象成一个个过程的表达，然后再将不同的过程结果组合起来，更加容易找到问题的解决办法。对于我们在其他领域的编码也是一样的道理，剥离问题表面，还原问题本质。有了这样的思维的时候，当你和别人在看同一个问题的时候，你会更容易有一种拨云见日的感觉。</p>\n<p>除了抽象的能力，分解问题的能力也是很重要的一个启发。将问题化小，分而治之，然后组合结果。当然这个能力不仅仅是函数式编程才具备的，分治法在很多算法里已经体现得淋漓尽致了。不过这里还是想再提一下这个话题，分而治之可以在各个维度的工作上进行运用，小到一个算法的具体实现，然后到一个问题的过程分解，甚至大到一个工作任务的拆解，都可以用分而治之的思维去寻找解题之法。</p>\n<p>当然函数式编程还有其他的一些不足之处，比如有人会说在函数式编程中数据复制可能会比较严重，可能会造成性能问题。这个问题我是这样看的，局部来说他可能确实看起来会存在一定的影响。但是从另一个角度来说，在我们使用函数式编程的时候，不用担心全局变量被破坏，没有执行顺序的依赖。我们在并行编程的时候，也不需要依赖于过多的锁的，那么反而最终可以提升最终性能。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\" target=\"_blank\" rel=\"noopener\">函数式编程入门教程</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/25Azr08BJivOBmPbkYwKTQ\" target=\"_blank\" rel=\"noopener\">漫谈函数式编程在前后端开发中的应用</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是函数式编程？\"><a href=\"#什么是函数式编程？\" class=\"headerlink\" title=\"什么是函数式编程？\"></a>什么是函数式编程？</h3><p>它详细的解释可以参考维基百科。缘起数学家 Alonzo Church 提出了 Lambda 演算的概念，可以用函数组合的方式来描述计算过程，换句话来说，<strong>如果一个问题能够用一系列函数组合的算法来表达，那么这个问题就认为是可计算的。</strong></p>\n<p><figure><br><img src=\"https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/fl.jpeg\" alt=\"Gardenia jasminoides\"><br></figure><br>","more":"</p>\n<p>它和面向对象编程一样，也是一种编程范式。强调执行的过程而非结果，通过一系列的嵌套的函数调用，完成一个运算过程。它主要有以下几个特点：</p>\n<ul>\n<li><p>函数是”一等公民”：函数优先，和其他数据类型一样。</p>\n</li>\n<li><p>只用”表达式”，不用”语句”：通过表达式（expression）计算过程得到一个返回值，而不是通过一个语句（statement）修改某一个状态。</p>\n</li>\n<li><p>无副作用：不污染变量，同一个输入永远得到同一个数据。</p>\n</li>\n<li><p>不可变性：前面一提到，不修改变量，返回一个新的值。</p>\n</li>\n</ul>\n<h3 id=\"范畴论与函数式编程\"><a href=\"#范畴论与函数式编程\" class=\"headerlink\" title=\"范畴论与函数式编程\"></a>范畴论与函数式编程</h3><ul>\n<li>在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。</li>\n<li>所以，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</li>\n<li><strong>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。</strong></li>\n</ul>\n<h3 id=\"函数的合成与柯里化\"><a href=\"#函数的合成与柯里化\" class=\"headerlink\" title=\"函数的合成与柯里化\"></a>函数的合成与柯里化</h3><p>函数式编程有两个最基本的运算：<strong>合成和柯里化</strong>。</p>\n<h4 id=\"函数的合成\"><a href=\"#函数的合成\" class=\"headerlink\" title=\"函数的合成\"></a>函数的合成</h4><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。<br>合成两个函数的简单代码如下。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(f, g)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数的合成还必须满足结合律。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(f, compose(g, h)</span></span>)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(compose(f, g)</span></span>, h)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">compose</span><span class=\"params\">(f, g, h)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？</strong><br>前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。</p>\n<h4 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h4><p>f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。<br><strong>这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</strong><br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 柯里化之前</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 柯里化之后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addX</span><span class=\"params\">(y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addX(<span class=\"number\">2</span>)(<span class=\"number\">1</span>) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。</p>\n<h4 id=\"函子\"><a href=\"#函子\" class=\"headerlink\" title=\"函子\"></a>函子</h4><p>函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。</p>\n<h3 id=\"函数式编程在前端开发中的应用\"><a href=\"#函数式编程在前端开发中的应用\" class=\"headerlink\" title=\"函数式编程在前端开发中的应用\"></a>函数式编程在前端开发中的应用</h3><p>函数式编程的概念其实出来也已经好几十年了，我们能在很多编程语言身上看到它的身影。比如比较纯粹的 Haskell，以及一些语言开始逐渐成为多范式编程语言，比如 Swift，还有 Kotlin，Java，Js 等都开始具备函数式编程的特性。这么多语言开始逐渐有了支持，函数式编程对于我们的生活到底能够带来一些什么好处呢?</p>\n<p>提到现代前端开发，那么 React 肯定是逃不开的一个话题。在 React 技术栈中，函数式编程有哪些体现呢？</p>\n<h4 id=\"Stateless-components\"><a href=\"#Stateless-components\" class=\"headerlink\" title=\"Stateless components\"></a>Stateless components</h4><p>在 React 0.14 之后推出的，先来看一段代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyComponent</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>My props name &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个简单的无状态组件，我们没有用createClass或者是extends React.Component来创建一个组件，而是通过一个 Pure function 返回了一个组件。<br>那么这里的好处是什么呢？</p>\n<ol>\n<li><p>简洁，一眼可以看出这个组件的作用；</p>\n</li>\n<li><p>无副作用，只要传入同一个 props 那么 render 出来的组件一定是相同的；</p>\n</li>\n<li><p>测试更友好；</p>\n</li>\n<li><p>没有this，要知道this还是难倒了好多英雄好汉的；</p>\n</li>\n<li><p>更容易实现 SSR（这一点我并未考证，有知道的朋友可以补充）。</p>\n</li>\n</ol>\n<p>当然，使用Stateless component并不是万能的，可以很明显的看到没有了 React 的生命周期，这个问题通常我们会结合 HOC 来解决。你看这一点就印证了前面说的，通过函数的组合完成对结果的表达，是不是很有意思。</p>\n<h4 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h4><p>在前端应用越来越复杂的今天，数据流管理是一件很重要的事，Redux 就是来解决这个问题的。它是 Flux 架构的演化实现，官方 GitHub 解释为 <strong>Predictable state container（可预测状态机）。</strong></p>\n<p>在 Redux 中我们存在一个单的树形结构的 state，单一数据源降低了多数据源的信任问题。State 是通过每个 reducer 的结果组合而来的，每个 reducer 都是一个 Pure function，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> isLoading = <span class=\"function\">(<span class=\"params\">state = <span class=\"literal\">false</span>, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MarketActionsTypes.FETCH_MARKET_DATA_START: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>在 reducer 中不会直接修改每个 state 中的状态，而是返回一个新的状态，然后整个 state 的结果通过一个个 reducer 的结果归纳出来。</strong> 我们来看 reducer 源码是怎么工作的：<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">....</span><br><span class=\"line\">    <span class=\"comment\">// from https://github.com/reduxjs/redux/blob/b02310b359a0832f65873d024570d411b465ced9/src/combineReducers.js#L162</span></span><br><span class=\"line\">    let hasChanged = <span class=\"keyword\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"built_in\">key</span> = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reducer = finalReducers[<span class=\"built_in\">key</span>]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> previousStateForKey = state[<span class=\"built_in\">key</span>]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (typeof nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> errorMessage = getUndefinedStateErrorMessage(<span class=\"built_in\">key</span>, action)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(errorMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      nextState[<span class=\"built_in\">key</span>] = nextStateForKey</span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure></p>\n<p>我们可以很直观的看到，最后的 state 结果是通过将每个 reducer 生成的局部结果组合起来得到一个新的 nextState，而不是直接在原有的 state 上进行修改。</p>\n<p>所以，我们再回过头来看看它的定义——可预测状态机。<br><strong>每个 reducer 都是一个纯函数，只要输入恒定，那么输出肯定是恒定的。同时，无副作用的特性可以保证 state 不会被意外修改，那么整个应用的 state 都是可以准确的知道的。</strong><br>最终的结果可以通过一系列的信息组合得来，这是一个很重要的改变。</p>\n<p>在函数式编程中，我们将一个个复杂的问题抽象成一个个过程的表达，然后再将不同的过程结果组合起来，更加容易找到问题的解决办法。对于我们在其他领域的编码也是一样的道理，剥离问题表面，还原问题本质。有了这样的思维的时候，当你和别人在看同一个问题的时候，你会更容易有一种拨云见日的感觉。</p>\n<p>除了抽象的能力，分解问题的能力也是很重要的一个启发。将问题化小，分而治之，然后组合结果。当然这个能力不仅仅是函数式编程才具备的，分治法在很多算法里已经体现得淋漓尽致了。不过这里还是想再提一下这个话题，分而治之可以在各个维度的工作上进行运用，小到一个算法的具体实现，然后到一个问题的过程分解，甚至大到一个工作任务的拆解，都可以用分而治之的思维去寻找解题之法。</p>\n<p>当然函数式编程还有其他的一些不足之处，比如有人会说在函数式编程中数据复制可能会比较严重，可能会造成性能问题。这个问题我是这样看的，局部来说他可能确实看起来会存在一定的影响。但是从另一个角度来说，在我们使用函数式编程的时候，不用担心全局变量被破坏，没有执行顺序的依赖。我们在并行编程的时候，也不需要依赖于过多的锁的，那么反而最终可以提升最终性能。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\" target=\"_blank\" rel=\"noopener\">函数式编程入门教程</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/25Azr08BJivOBmPbkYwKTQ\" target=\"_blank\" rel=\"noopener\">漫谈函数式编程在前后端开发中的应用</a></li>\n</ul>"},{"title":"对象与数组的深浅拷贝","date":"2018-06-12T16:00:00.000Z","toc":true,"_content":"<!-- <img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\" style=\"width:56%\"></img> -->\n\n\n使用场景：\n\n引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。\n\n当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作\n<!--more-->\n\n## Javascript中的深拷贝与浅拷贝为什么会有区别？\n对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。\n\n首先了解一些javascript的基本知识。\n### 1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。\n**基本类型** 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：\n\nnumber、string、boolean、null、undefined、symbol\n\n**引用类型** 值指那些可能由多个值构成的对象，只有一种如下：\n\nobject（Array也属于对象）\n\n在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。\n\n引用类型的值是保存在内存中的对象。与其他语言不同，**JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。**\n\n### 2.javascript的变量的存储方式--栈（stack）和堆（heap）\n**栈** ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址\n**堆** ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。\na. 基本类型--名值存储在栈内存中，例如let a=1;call\n\nb.引用数据类型--名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：\n\n\n<!-- <img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\"></img> -->\n### 3.javascript值传递与址传递\n基本类型与引用类型最大的区别实际就是 **传值与传址的区别**\n值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。\n址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。\n\n所以当\n```\nvar obj={};\nvar newObj=obj;\nnewObj={\"name\":\"shengyu\"}\n```\n时候，打印出obj的值，会发现obj的值与newObj一起被修改了\n\n那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。\n\n## 什么是深拷贝/浅拷贝？\n本文认为\n浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，**彼此之间的操作会互相影响**。\n\n深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 **是完全隔离的**。\n由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 **保证复制的对象与源对象完全隔离** 。然而，*还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深*。\n\n\n原文：\n1. [快速浅拷贝一个数组](https://blog.csdn.net/yiifaa/article/details/73438088)\n2. https://www.zhihu.com/question/23031215\n3. [推荐！](https://www.cnblogs.com/tracylin/p/5346314.html)\n4. [JavaScript复制（合并）对象](https://segmentfault.com/a/1190000011492291)\n5. [ES6之扩展运算符与应用](https://www.jianshu.com/p/35f9efe95fff)\n","source":"_posts/数组与对象的深浅拷贝.md","raw":"title: 对象与数组的深浅拷贝\ndate: 2018/06/13\ncategories: 前端基础\ntoc: true\ntags:\n  - Javascript\n---\n<!-- <img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\" style=\"width:56%\"></img> -->\n\n\n使用场景：\n\n引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。\n\n当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作\n<!--more-->\n\n## Javascript中的深拷贝与浅拷贝为什么会有区别？\n对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。\n\n首先了解一些javascript的基本知识。\n### 1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。\n**基本类型** 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：\n\nnumber、string、boolean、null、undefined、symbol\n\n**引用类型** 值指那些可能由多个值构成的对象，只有一种如下：\n\nobject（Array也属于对象）\n\n在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。\n\n引用类型的值是保存在内存中的对象。与其他语言不同，**JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。**\n\n### 2.javascript的变量的存储方式--栈（stack）和堆（heap）\n**栈** ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址\n**堆** ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。\na. 基本类型--名值存储在栈内存中，例如let a=1;call\n\nb.引用数据类型--名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：\n\n\n<!-- <img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\"></img> -->\n### 3.javascript值传递与址传递\n基本类型与引用类型最大的区别实际就是 **传值与传址的区别**\n值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。\n址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。\n\n所以当\n```\nvar obj={};\nvar newObj=obj;\nnewObj={\"name\":\"shengyu\"}\n```\n时候，打印出obj的值，会发现obj的值与newObj一起被修改了\n\n那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。\n\n## 什么是深拷贝/浅拷贝？\n本文认为\n浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，**彼此之间的操作会互相影响**。\n\n深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 **是完全隔离的**。\n由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 **保证复制的对象与源对象完全隔离** 。然而，*还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深*。\n\n\n原文：\n1. [快速浅拷贝一个数组](https://blog.csdn.net/yiifaa/article/details/73438088)\n2. https://www.zhihu.com/question/23031215\n3. [推荐！](https://www.cnblogs.com/tracylin/p/5346314.html)\n4. [JavaScript复制（合并）对象](https://segmentfault.com/a/1190000011492291)\n5. [ES6之扩展运算符与应用](https://www.jianshu.com/p/35f9efe95fff)\n","slug":"数组与对象的深浅拷贝","published":1,"updated":"2018-10-24T16:22:26.000Z","_id":"cjnn81wg700557q0t2xbl4gzx","comments":1,"layout":"post","photos":[],"link":"","content":"<!-- <img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\" style=\"width:56%\"></img> -->\n<p>使用场景：</p>\n<p>引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。</p>\n<p>当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作<br><a id=\"more\"></a></p>\n<h2 id=\"Javascript中的深拷贝与浅拷贝为什么会有区别？\"><a href=\"#Javascript中的深拷贝与浅拷贝为什么会有区别？\" class=\"headerlink\" title=\"Javascript中的深拷贝与浅拷贝为什么会有区别？\"></a>Javascript中的深拷贝与浅拷贝为什么会有区别？</h2><p>对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。</p>\n<p>首先了解一些javascript的基本知识。</p>\n<h3 id=\"1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。\"><a href=\"#1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。\" class=\"headerlink\" title=\"1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。\"></a>1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。</h3><p><strong>基本类型</strong> 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：</p>\n<p>number、string、boolean、null、undefined、symbol</p>\n<p><strong>引用类型</strong> 值指那些可能由多个值构成的对象，只有一种如下：</p>\n<p>object（Array也属于对象）</p>\n<p>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p>\n<p>引用类型的值是保存在内存中的对象。与其他语言不同，<strong>JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。</strong></p>\n<h3 id=\"2-javascript的变量的存储方式–栈（stack）和堆（heap）\"><a href=\"#2-javascript的变量的存储方式–栈（stack）和堆（heap）\" class=\"headerlink\" title=\"2.javascript的变量的存储方式–栈（stack）和堆（heap）\"></a>2.javascript的变量的存储方式–栈（stack）和堆（heap）</h3><p><strong>栈</strong> ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址<br><strong>堆</strong> ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。<br>a. 基本类型–名值存储在栈内存中，例如let a=1;call</p>\n<p>b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：</p>\n<!-- <img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\"></img> -->\n<h3 id=\"3-javascript值传递与址传递\"><a href=\"#3-javascript值传递与址传递\" class=\"headerlink\" title=\"3.javascript值传递与址传递\"></a>3.javascript值传递与址传递</h3><p>基本类型与引用类型最大的区别实际就是 <strong>传值与传址的区别</strong><br>值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。<br>址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。</p>\n<p>所以当<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var obj</span>=&#123;&#125;;</span><br><span class=\"line\"><span class=\"attribute\">var newObj</span>=obj;</span><br><span class=\"line\"><span class=\"attribute\">newObj</span>=&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"shengyu\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时候，打印出obj的值，会发现obj的值与newObj一起被修改了</p>\n<p>那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。</p>\n<h2 id=\"什么是深拷贝-浅拷贝？\"><a href=\"#什么是深拷贝-浅拷贝？\" class=\"headerlink\" title=\"什么是深拷贝/浅拷贝？\"></a>什么是深拷贝/浅拷贝？</h2><p>本文认为<br>浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，<strong>彼此之间的操作会互相影响</strong>。</p>\n<p>深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 <strong>是完全隔离的</strong>。<br>由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 <strong>保证复制的对象与源对象完全隔离</strong> 。然而，<em>还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深</em>。</p>\n<p>原文：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/yiifaa/article/details/73438088\" target=\"_blank\" rel=\"noopener\">快速浅拷贝一个数组</a></li>\n<li><a href=\"https://www.zhihu.com/question/23031215\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/23031215</a></li>\n<li><a href=\"https://www.cnblogs.com/tracylin/p/5346314.html\" target=\"_blank\" rel=\"noopener\">推荐！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011492291\" target=\"_blank\" rel=\"noopener\">JavaScript复制（合并）对象</a></li>\n<li><a href=\"https://www.jianshu.com/p/35f9efe95fff\" target=\"_blank\" rel=\"noopener\">ES6之扩展运算符与应用</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<!-- <img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\" style=\"width:56%\"></img> -->\n<p>使用场景：</p>\n<p>引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。</p>\n<p>当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作<br>","more":"</p>\n<h2 id=\"Javascript中的深拷贝与浅拷贝为什么会有区别？\"><a href=\"#Javascript中的深拷贝与浅拷贝为什么会有区别？\" class=\"headerlink\" title=\"Javascript中的深拷贝与浅拷贝为什么会有区别？\"></a>Javascript中的深拷贝与浅拷贝为什么会有区别？</h2><p>对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。</p>\n<p>首先了解一些javascript的基本知识。</p>\n<h3 id=\"1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。\"><a href=\"#1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。\" class=\"headerlink\" title=\"1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。\"></a>1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。</h3><p><strong>基本类型</strong> 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：</p>\n<p>number、string、boolean、null、undefined、symbol</p>\n<p><strong>引用类型</strong> 值指那些可能由多个值构成的对象，只有一种如下：</p>\n<p>object（Array也属于对象）</p>\n<p>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p>\n<p>引用类型的值是保存在内存中的对象。与其他语言不同，<strong>JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。</strong></p>\n<h3 id=\"2-javascript的变量的存储方式–栈（stack）和堆（heap）\"><a href=\"#2-javascript的变量的存储方式–栈（stack）和堆（heap）\" class=\"headerlink\" title=\"2.javascript的变量的存储方式–栈（stack）和堆（heap）\"></a>2.javascript的变量的存储方式–栈（stack）和堆（heap）</h3><p><strong>栈</strong> ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址<br><strong>堆</strong> ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。<br>a. 基本类型–名值存储在栈内存中，例如let a=1;call</p>\n<p>b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：</p>\n<!-- <img src=\"https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg\"></img> -->\n<h3 id=\"3-javascript值传递与址传递\"><a href=\"#3-javascript值传递与址传递\" class=\"headerlink\" title=\"3.javascript值传递与址传递\"></a>3.javascript值传递与址传递</h3><p>基本类型与引用类型最大的区别实际就是 <strong>传值与传址的区别</strong><br>值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。<br>址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。</p>\n<p>所以当<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var obj</span>=&#123;&#125;;</span><br><span class=\"line\"><span class=\"attribute\">var newObj</span>=obj;</span><br><span class=\"line\"><span class=\"attribute\">newObj</span>=&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"shengyu\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时候，打印出obj的值，会发现obj的值与newObj一起被修改了</p>\n<p>那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。</p>\n<h2 id=\"什么是深拷贝-浅拷贝？\"><a href=\"#什么是深拷贝-浅拷贝？\" class=\"headerlink\" title=\"什么是深拷贝/浅拷贝？\"></a>什么是深拷贝/浅拷贝？</h2><p>本文认为<br>浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，<strong>彼此之间的操作会互相影响</strong>。</p>\n<p>深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 <strong>是完全隔离的</strong>。<br>由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 <strong>保证复制的对象与源对象完全隔离</strong> 。然而，<em>还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深</em>。</p>\n<p>原文：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/yiifaa/article/details/73438088\" target=\"_blank\" rel=\"noopener\">快速浅拷贝一个数组</a></li>\n<li><a href=\"https://www.zhihu.com/question/23031215\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/23031215</a></li>\n<li><a href=\"https://www.cnblogs.com/tracylin/p/5346314.html\" target=\"_blank\" rel=\"noopener\">推荐！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011492291\" target=\"_blank\" rel=\"noopener\">JavaScript复制（合并）对象</a></li>\n<li><a href=\"https://www.jianshu.com/p/35f9efe95fff\" target=\"_blank\" rel=\"noopener\">ES6之扩展运算符与应用</a></li>\n</ol>"},{"title":"浏览器解析渲染过程解析","date":"2018-09-28T16:00:00.000Z","toc":true,"_content":"\n在浏览器从获取到HTML，然后解析，渲染的过程中，到底发生了什么？\n\n## 页面呈现六部曲\n1.解析HTML,构建DOM树。\n2.解析CSS,生成CSS规则树。\n*在chrome的Timeline 工具中对应的阶段是：Re-caculate。为什么是 Re-caculate Style 呢？这是因为浏览器本身有 User Agent StyleSheet，所以最终的样式是我们的样式代码样式与用户代理默认样式覆盖/重新计算得到的。*\n3.合并 DOM 树与 CSSOM 树为 Render 树\n4.布局（Layout）\n5.绘制（Paint）\n6.复合图层化（Composite）\n多个复合层的合成，最终合成的页面被用户看到。\n\n<!--more-->\n## 六部曲中存在的阻塞\n虽然六部曲看似和谐，分工合作，有序进行。但是实际上这里面却是波云诡谲，风起云涌，就像平时的工作一样，看似你和我各司其职，分工明确，但是实际干起活来却可能因为某一个人的某一环而阻滞整个进度。\n\n那么下面我们来分析一下六部曲中存在的阻塞：\n1. 当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（阻塞1）\n然而，是否停下 DOM 的构建的同时，立马就执行 JavaScript 代码或者下载外部脚本执行，其实还是要视情况而定\n2. 当遇到 &lt;script&gt;标签需要执行脚本代码时，浏览器会检查是否这个 &lt;script&gt;标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 &lt;script&gt;上部还有 CSS 样式没加载，则浏览器会等待 &lt;script&gt;上方样式的加载完成才会执行该 &lt;script&gt;内的脚本，（阻塞2）\n3. DOM 树与 CSSOM 树的成功构建是后面步骤的根基（同步阻塞）\n4. 同时外部脚本、外部样式表的下载也是耗费时间较多的点\n\n## 六部曲之——DOM树的构建\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/DOM%20tree.png\"></img>\n\n\n浏览器构建DOM树可以简单的总结为以下几步：\n1. 转码（Bytes -> Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串\n2. Tokens 化（Characters -> Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则\n3. 构建 Nodes（Tokens -> Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/htmlParse.png\"></img>\n4. 构建 DOM 树（Nodes -> DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系\n```\n在 Chrome 开发者工具下 Timeline 面板的 Parse HTML 阶段对应着 DOM 树的构建。\n```\n\n扩展阅读：[从Chrome源码看浏览器如何构建DOM树 ](https://zhuanlan.zhihu.com/p/24911872?refer=dreawer)\n留意这篇文章的这些点：\n1. DOM 构建时对 DOCType 处理\n2. DOCType 的不同或漏缺带来的文档解析模式（怪异模式、有限怪异模式、标准模式）的影响\n3. 处理开标签与闭标签的压栈、弹栈处理\n4. Chromium 对待自定义标签的处理\n5. JavaScript 方法查找 DOM 的过程，使用 ID、类名、复杂选择器查找 DOM 的对比\n\n\n## 六部曲之——CSSOM树的构建\nCSSOM 树的构建 “原料” 的来源有：外部 CSS 文件、内部样式、内联样式。\n\n*CSSOM 树的构建其实是一个 样式的重新计算 的过程，为什么是重新计算呢？*\n```\n用户代理（即浏览器）本身有一套内置样式表，所以我们最终的 CSSOM 树其实是用户代理样式与页面所有样式的重新计算。\n所以在 Chrome 浏览器开发者工具的 Timeline 面板下，CSSOM 树的构建对应的是 Recalculate Style 阶段\n```\n与 DOM 树的构建过程相似，CSSOM 的构建也要经历以下过程：\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom.png\"></src>\n\n最终构建的 CSSOM 树大致如下：\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom_end.png\"></img>\n## 六部曲之——渲染树的构建\n1.DOM 树与 CSSOM 树融合成渲染树\n2.渲染树只包括渲染页面需要的节点\n```\n排除 <script> <meta> 等功能化、非视觉节点\n排除 display: none 的节点\n```\n过程大致如下：\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/renderTree.png\"></img>\n## 六部曲之——布局\nLayout 阶段做的工作：确定页面各元素的位置、尺寸。\n```\nLayout 在 Chrome 开发者工具 Timeline 面板中被归并到 Paint 阶段\n```\n当元素某些样式变更/JavaScript 执行某些样式请求，会导致 Layout trashing，又叫做回流（Reflow）。\n\n## 六部曲之——绘制\n一旦布局（Layout）步骤完成，浏览器便触发 *Paint Setup* 与 *Paint* 事件（渲染引擎底层概念），执行 paint 操作，结合渲染树与布局信息绘制实际像素。\n```\n注：在 Timeline 工具内，Layout 与 Paint 两个过程被统一归并到 Paint 阶段。\n```\n\n## 六部曲之——复合图层化\n在很多情况下，我们不会将复合图层化归入页面呈现的必要过程。图层化是浏览器为了充分利用已有渲染成果（缓存渲染成果），最小化 GPU 运算，将“脏区”提升为复合图层，隔离变化影响的操作。\n\n详情见[https://segmentfault.com/a/1190000008015671]( 一篇文章说清浏览器解析和CSS（GPU）动画优化)\n\n### 如何创建layer\n1.3D 或透视变换(perspective transform) CSS 属性\n2.使用加速视频解码的元素，如&lt;video&gt;\n3.拥有 3D (WebGL) 上下文或加速的 2D 上下文的，如&lt;canvas&gt;\n4.混合插件(如 Flash)\n5.对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素\n6.拥有加速 CSS 过滤器的元素，如CSS filters\n7.元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)\n8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)\n9.在webkit内核的浏览器中，如果有上述情况，则会创建一个独立的layer。\n### 拒绝layer泛滥\n**当对元素创建layer之后，会节省layout和paint阶段，但是layer不能泛滥。 layer跟psd中图层很像，我们知道在psd中图层越多，psd图片就会越大。 同理，layer越多，占用的内存就越多，当在内存有限的移动设备上（手机），过多的渲染带来的开销超过了它在性能上的改善,得不偿失； 白白的给元素添加layer，一般通过* {-webkit-transform: translateZ(0);}为元素添加layer 但创建layer的原则：当且仅当需要的时候才为元素创建渲染层。**\n\n## 注意事项\n**渲染分为三阶段：layout，paint，composite layer，修改不同的css属性会触发不同的阶段，触发的阶段越靠前，渲染的代价越高。**\n1：尽量避免触发layout（位置相关的可通过transform代替 top left），paint。 除写css属性外，读取css的位置大小相关属性会导致触发layout阶段，要分离读写，减少layout。\n2：应该尽量避免重绘，并且尽可能的使绘制区域最小，以提升页面性能。 但是有些必须使用的样式效果还是要用的，比如fixed等重要的是作为前端人员，能够预估这些代码所带来的性能损耗及所造成的影响。\n3：避免组合触发 比如滚动和hover效果，hover中若使用border-shadow，border-style修改，则会损耗较大的性能，有可能会触发丢帧的现象。 改进办法：在滚动时，增加计时器，可先把hover效果禁掉，滚动结束后再打开hover效果。\n\n## 浏览器的渲染流程方向的优化手段\n知道了页面渲染的原理，那么我们也就得到了页面性能优化的依据。提炼六部曲中每一步的优化空间，针对六部曲中的每一步提出针对性的优化方案也就能达到我们最终的优化目的。\n\n### 优化不可避免的阻塞：优化关键呈现路径\n#### 关键呈现路径里的一些概念：\n- **关键资源**：可能阻止网页首次呈现的资源。\n- **关键路径长度**：即往返过程数量，或提取所有关键资源所需的总时间。\n- **关键字节**：实现网页首次呈现所需的总字节数，是所有关键资源的传输文件大小总和。 带有一个 HTML 网页的首个示例包含一项关键资源（HTML 文档），关键路径长度也与 1 个网络往返过程（假设文件较小）相等，而且总的关键字节数正好是 HTML 文档本身的传输大小。\n\n#### 优化关键呈现路径的指导原则：\n- 尽量减少关键资源数量。\n- 尽量减少关键字节数。\n- 尽量缩短关键路径的长度。\n\n#### 优化关键呈现路径常规步骤：\n- 分析和描述关键路径：资源数量、字节数、长度。\n- 尽量减少关键资源数量：删除相应资源、延迟下载、标记为异步资源等等。\n- 优化剩余关键资源的加载顺序：你需要尽早下载所有关键资源，以缩短关键路径长度。\n- 尽量减少关键字节数，以缩短下载时间（和往返次数）。\n\n#### 优化关键呈现路径的具体建议：\n- 文件合并、压缩\n\n- 推荐使用异步（async） JavaScript 资源，或使用延迟（defer）执行的 JavaScript\n\n- 一般 &lt;script&gt;脚本的靠后书写\n\n- 避免运行时间长的 JavaScript，耗时任务的拆分，chunk 化运行\n```\n例如：使用定时器将大任务拆分为小任务，使得浏览器得到空隙做其他事情。\n```\n- 避免使用 CSS import\n- 内联、内部化阻止呈现的 CSS\n```\n一般不采用，百度、Google 这样的极度重视性能与体验的服务才可能这样做。\n```\n\n\n### 针对复合图层化的优化\n因为浏览器有图层化这个机制，那么我们就搞懂它并充分利用吧。\n#### 复合图层化机制是怎样的呢？\n如果某些属性的变更（transform、opacity）满足以下条件:\n- 不影响文档流\n- 不依赖文档流\n- 不会造成重绘\n\n那么，这些属性变更时，就需要一种机制：\n能将属性变更的部分与页面其他部分隔离开来，对其他部分已经渲染完的进行缓存，变更的部分在单独的图层上进行，然后对缓存的部分与变更的图层进行合成。\n关键字：**缓存、隔离、图层合成**\n使用 transform 与 opacity 进行属性变更是经典的复合图层优化方法，以下是其他会提升元素为复合图层的场景：\n1.3d 或透视变换 CSS 属性，例如 translate3d, translateZ 等等（JS 一般通过这种方式，使元素获得复合图层）\n2.&lt;video&gt; &lt;iframe&gt; &lt;canvas&gt; &lt;webgl&gt;等元素\n3.混合插件（如flash）\n4.元素自身的 opacity 和 transform 做 CSS 动画\n5.拥有[CSS Filter](http://www.runoob.com/cssref/css3-pr-filter.html)的元素\n6.使用 will-change 属性\n7.position:fixed\n8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上方)\n\n#### 图层化的优势\n很容易看出来：充分利用缓存、隔离的思想，无需像回流、重绘那么大性能（GPU、CPU）开支，图层化能带来 **动画性能的提升**。\n\n图层化的潜在问题/弊端 —— 内存开销\n因为图层化的存在，每个图层对需要在内存中存储该图层相关的信息，当图层太多会造成内存开销过大的情况。\n\n#### 因为开销，所以节制\n内存开销在桌面端可能还能接受，但是在资源有限的移动端，复合图层过多便可能导致内存开支过大，页面反而变得停滞、卡顿，甚至浏览器假死，系统无法正常运行。\n\n\n### 针对回流的优化\n首先，我们需要知道什么情况下会触发浏览器的repaint/reflow：\n查询哪些属性会触发Layout/Paing/Composite,可参考：\nhttps://csstriggers.com/\n\n#### 技术使用优先级：\n1.CSS3 > JavaScript\n2.属性变更优先考虑顺序（性能表现排序）\n- transfrom, opacity\n- background-color等\n- position top、bottom、left、right\n- width、height等\n- margin、padding、border\n\n#### What forces layout\n\n能够引起重绘和回流的属性修改/查找：\n- Element\n**Box metrics**\nelem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParent\nelem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeight\nelem.getClientRects(), elem.getBoundingClientRect()\n\n**Scroll stuff**\nelem.scrollBy(), elem.scrollTo()\nelem.scrollIntoView(), elem.scrollIntoViewIfNeeded()\nelem.scrollWidth, elem.scrollHeight\nelem.scrollLeft, elem.scrollTop also, setting them\n\n**Focus**\nelem.focus() can trigger a double forced layout (source)\n\n**Also…**\nelem.computedRole, elem.computedName\nelem.innerText (source)\n\n- getComputedStyle\n\n- ......\n\n详情查看：https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9\n**JavaScript 存在这样的机制：当连续有大量 DOM 样式的操作时，出于性能考虑，防止零碎变更导致频繁的回流、重绘，会尽可能地将这些操作先缓存起来，然后一次性地变更。这个机制我们难以察觉但是确实存在。\n然而当我们进行某些 DOM 样式的读、写时，出于时效性的考虑，则会立即触发浏览器回流、重绘以返回正确、合理的值。**\n\n\n\n### 减少渲染时的内存消耗\n1.避免浏览器的隐式合成。\n- 保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。\n- 将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。\n\n2.减小复合层的尺寸\n看一下两张图片，有什么不同吗？\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/MinComposite.png\"></img>\n这两张图片视觉上是一样的，但是它们的尺寸一个是39kb；另外一个是400b。不同之处在于，第二个纯色层是通过scale放大10倍做到的。\n```\n<div id=\"a\"></div>\n<div id=\"b\"></div>\n\n<style>\n#a, #b {\n will-change: transform;\n}\n\n#a {\n width: 100px;\n height: 100px;\n}\n\n#b {\n width: 10px;\n height: 10px;\n transform: scale(10);\n}\n</style>\n```\n对于图片，你要怎么做呢？你可以将图片的尺寸减少5%——10%，然后使用scale将它们放大；用户不会看到什么区别，但是你可以减少大量的存储空间。\n\n\n### 减少渲染时的计算数量\n1.用css动画而不是js动画\ncss动画有一个重要的特性，它是完全工作在GPU上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给GPU。\n而如果使用js动画，浏览器必须计算每一帧的状态；\n为了保证平滑的动画，我们必须在浏览器主线程计算新状态；\n把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画；\n当主线程的计算任务过多时，会造成动画的延迟、卡顿。\n\n所以尽可能地使用基于css的动画，不仅仅更快；也不会被大量的js计算所阻塞。\n\n### 节流函数\n### 惰性载入函数\n### [重任务分片多帧](https://zhuanlan.zhihu.com/p/25166666?refer=dreawer)\n\n\n知道原理之后，常用的有如下几点优化方法：\n\n1.避免在document上直接进行频繁的DOM操作，如果确实需要可以采用off-document的方式进行，具体的方法包括但不完全包括以下几种：\n(1). 先将元素从document中删除，完成修改后再把元素放回原来的位置\n\n(2). 将元素的display设置为”none”，完成修改后再把display修改为原来的值\n\n(3). 如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document\n\n2.集中修改样式\n(1). 尽可能少的修改元素style上的属性\n\n(2). 尽量通过修改className来修改样式\n\n(3). 通过cssText属性/className来设置样式值\n\n```\ndocument.getElementById(\"d1\").style.cssText = \"color:red; font-size:13px;\";\n```\n\n3.缓存Layout属性值\n对于Layout属性中非引用类型的值（数字型），如果需要多次访问则可以在一次访问时先存储到局部变量中，之后都使用局部变量，这样可以避免每次读取属性时造成浏览器的渲染。\n```\nvar width = el.offsetWidth; var scrollLeft = el.scrollLeft;\n```\n\n4.设置元素的position为absolute或fixed\n\n\n5.不要使用table布局。\n\n6.css动画中尽量只使用transform和opacity，这不会发生重排和重绘。\n如上所说，transform和opacity保证了元素属性的变化不影响文档流、也不受文档流影响；并且不会造成repaint。\n有些时候你可能想要改变其他的css属性，作为动画。例如：你可能想使用background属性改变背景：\n```\n<div class=\"bg-change\"></div>\n.bg-change {\n  width: 100px;\n  height: 100px;\n  background: red;\n  transition: opacity 2s;\n}\n.bg-change:hover {\n  background: blue;\n}\n```\n在这个例子中，在动画的每一步；浏览器都会进行一次重绘。我们可以使用一个复层在这个元素上面，并且仅仅变换opacity属性：\n```html\n<div class=\"bg-change\"></div>\n<style>\n.bg-change {\n  width: 100px;\n  height: 100px;\n  background: red;\n}\n.bg-change::before {\n  content: '';\n  display: block;\n  width: 100%;\n  height: 100%;\n  background: blue;\n  opacity: 0;\n  transition: opacity 20s;\n}\n.bg-change:hover::before {\n  opacity: 1;\n}\n</style>\n```\n\n\n\n\n\n\n## 回答几个问题 自测\n\n### 如何理解 getComputedStyle?\n\n在尚未梳理知识体系前，大概会这样回答：\n\n普通版本： getComputedStyle会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过 window.getComputedStyle等价于 document.defaultView.getComputedStyle调用\n\n详细版本： window.getComputedStyle(elem,null).getPropertyValue(\"height\")可能的值为 100px，而且，就算是css上写的是 inherit， getComputedStyle也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么 getComputedStyle获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。\n\n就这个API来说，上述的回答已经比较全面了。\n\n但是，其实它是可以继续延伸的。\n\n譬如现在会这样回答：\n\ngetComputedStyle会获取当前元素所有最终使用的CSS属性值， window.和 document.defaultView.等价...\n\ngetComputedStyle会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如 offsetXXX， scrollXXX， clientXXX， currentStyle等等\n\n### visibility:hidden和 display:none的区别?\n\n可以如下回答：\n\n普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置\n\n进一步， display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大\n\n再进一步，当一个页面某个元素经常需要切换 display时如何优化，一般会用复合层优化，或者要求低一点用 absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流， absolute文档流，复合图层的区别，\n\n再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）\n\n上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖\n\n\n参考：\n- [https://www.cnblogs.com/fullhouse/archive/2012/02/20/2360301.html](如何减少浏览器repaint和reflow)\n- [https://mp.weixin.qq.com/s/LIfvU8j0gBVIFF8AYYtfFg](从输入URL到页面加载的过程？)\n- [https://www.cnblogs.com/ys-wuhan/p/6985624.html](浏览器内核、页面呈现原理及其优化)\n- [https://zhuanlan.zhihu.com/p/24911872?refer=dreawer](从Chrome源码看浏览器如何构建DOM树)\n- [https://segmentfault.com/a/1190000008015671#articleHeader9](一篇文章说清浏览器解析和CSS（GPU）动画优化)\n","source":"_posts/浏览器解析渲染过程解析.md","raw":"title: 浏览器解析渲染过程解析\ndate: 2018/09/29\ncategories: 前端基础\ntoc: true\n---\n\n在浏览器从获取到HTML，然后解析，渲染的过程中，到底发生了什么？\n\n## 页面呈现六部曲\n1.解析HTML,构建DOM树。\n2.解析CSS,生成CSS规则树。\n*在chrome的Timeline 工具中对应的阶段是：Re-caculate。为什么是 Re-caculate Style 呢？这是因为浏览器本身有 User Agent StyleSheet，所以最终的样式是我们的样式代码样式与用户代理默认样式覆盖/重新计算得到的。*\n3.合并 DOM 树与 CSSOM 树为 Render 树\n4.布局（Layout）\n5.绘制（Paint）\n6.复合图层化（Composite）\n多个复合层的合成，最终合成的页面被用户看到。\n\n<!--more-->\n## 六部曲中存在的阻塞\n虽然六部曲看似和谐，分工合作，有序进行。但是实际上这里面却是波云诡谲，风起云涌，就像平时的工作一样，看似你和我各司其职，分工明确，但是实际干起活来却可能因为某一个人的某一环而阻滞整个进度。\n\n那么下面我们来分析一下六部曲中存在的阻塞：\n1. 当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（阻塞1）\n然而，是否停下 DOM 的构建的同时，立马就执行 JavaScript 代码或者下载外部脚本执行，其实还是要视情况而定\n2. 当遇到 &lt;script&gt;标签需要执行脚本代码时，浏览器会检查是否这个 &lt;script&gt;标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 &lt;script&gt;上部还有 CSS 样式没加载，则浏览器会等待 &lt;script&gt;上方样式的加载完成才会执行该 &lt;script&gt;内的脚本，（阻塞2）\n3. DOM 树与 CSSOM 树的成功构建是后面步骤的根基（同步阻塞）\n4. 同时外部脚本、外部样式表的下载也是耗费时间较多的点\n\n## 六部曲之——DOM树的构建\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/DOM%20tree.png\"></img>\n\n\n浏览器构建DOM树可以简单的总结为以下几步：\n1. 转码（Bytes -> Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串\n2. Tokens 化（Characters -> Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则\n3. 构建 Nodes（Tokens -> Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/htmlParse.png\"></img>\n4. 构建 DOM 树（Nodes -> DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系\n```\n在 Chrome 开发者工具下 Timeline 面板的 Parse HTML 阶段对应着 DOM 树的构建。\n```\n\n扩展阅读：[从Chrome源码看浏览器如何构建DOM树 ](https://zhuanlan.zhihu.com/p/24911872?refer=dreawer)\n留意这篇文章的这些点：\n1. DOM 构建时对 DOCType 处理\n2. DOCType 的不同或漏缺带来的文档解析模式（怪异模式、有限怪异模式、标准模式）的影响\n3. 处理开标签与闭标签的压栈、弹栈处理\n4. Chromium 对待自定义标签的处理\n5. JavaScript 方法查找 DOM 的过程，使用 ID、类名、复杂选择器查找 DOM 的对比\n\n\n## 六部曲之——CSSOM树的构建\nCSSOM 树的构建 “原料” 的来源有：外部 CSS 文件、内部样式、内联样式。\n\n*CSSOM 树的构建其实是一个 样式的重新计算 的过程，为什么是重新计算呢？*\n```\n用户代理（即浏览器）本身有一套内置样式表，所以我们最终的 CSSOM 树其实是用户代理样式与页面所有样式的重新计算。\n所以在 Chrome 浏览器开发者工具的 Timeline 面板下，CSSOM 树的构建对应的是 Recalculate Style 阶段\n```\n与 DOM 树的构建过程相似，CSSOM 的构建也要经历以下过程：\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom.png\"></src>\n\n最终构建的 CSSOM 树大致如下：\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom_end.png\"></img>\n## 六部曲之——渲染树的构建\n1.DOM 树与 CSSOM 树融合成渲染树\n2.渲染树只包括渲染页面需要的节点\n```\n排除 <script> <meta> 等功能化、非视觉节点\n排除 display: none 的节点\n```\n过程大致如下：\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/renderTree.png\"></img>\n## 六部曲之——布局\nLayout 阶段做的工作：确定页面各元素的位置、尺寸。\n```\nLayout 在 Chrome 开发者工具 Timeline 面板中被归并到 Paint 阶段\n```\n当元素某些样式变更/JavaScript 执行某些样式请求，会导致 Layout trashing，又叫做回流（Reflow）。\n\n## 六部曲之——绘制\n一旦布局（Layout）步骤完成，浏览器便触发 *Paint Setup* 与 *Paint* 事件（渲染引擎底层概念），执行 paint 操作，结合渲染树与布局信息绘制实际像素。\n```\n注：在 Timeline 工具内，Layout 与 Paint 两个过程被统一归并到 Paint 阶段。\n```\n\n## 六部曲之——复合图层化\n在很多情况下，我们不会将复合图层化归入页面呈现的必要过程。图层化是浏览器为了充分利用已有渲染成果（缓存渲染成果），最小化 GPU 运算，将“脏区”提升为复合图层，隔离变化影响的操作。\n\n详情见[https://segmentfault.com/a/1190000008015671]( 一篇文章说清浏览器解析和CSS（GPU）动画优化)\n\n### 如何创建layer\n1.3D 或透视变换(perspective transform) CSS 属性\n2.使用加速视频解码的元素，如&lt;video&gt;\n3.拥有 3D (WebGL) 上下文或加速的 2D 上下文的，如&lt;canvas&gt;\n4.混合插件(如 Flash)\n5.对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素\n6.拥有加速 CSS 过滤器的元素，如CSS filters\n7.元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)\n8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)\n9.在webkit内核的浏览器中，如果有上述情况，则会创建一个独立的layer。\n### 拒绝layer泛滥\n**当对元素创建layer之后，会节省layout和paint阶段，但是layer不能泛滥。 layer跟psd中图层很像，我们知道在psd中图层越多，psd图片就会越大。 同理，layer越多，占用的内存就越多，当在内存有限的移动设备上（手机），过多的渲染带来的开销超过了它在性能上的改善,得不偿失； 白白的给元素添加layer，一般通过* {-webkit-transform: translateZ(0);}为元素添加layer 但创建layer的原则：当且仅当需要的时候才为元素创建渲染层。**\n\n## 注意事项\n**渲染分为三阶段：layout，paint，composite layer，修改不同的css属性会触发不同的阶段，触发的阶段越靠前，渲染的代价越高。**\n1：尽量避免触发layout（位置相关的可通过transform代替 top left），paint。 除写css属性外，读取css的位置大小相关属性会导致触发layout阶段，要分离读写，减少layout。\n2：应该尽量避免重绘，并且尽可能的使绘制区域最小，以提升页面性能。 但是有些必须使用的样式效果还是要用的，比如fixed等重要的是作为前端人员，能够预估这些代码所带来的性能损耗及所造成的影响。\n3：避免组合触发 比如滚动和hover效果，hover中若使用border-shadow，border-style修改，则会损耗较大的性能，有可能会触发丢帧的现象。 改进办法：在滚动时，增加计时器，可先把hover效果禁掉，滚动结束后再打开hover效果。\n\n## 浏览器的渲染流程方向的优化手段\n知道了页面渲染的原理，那么我们也就得到了页面性能优化的依据。提炼六部曲中每一步的优化空间，针对六部曲中的每一步提出针对性的优化方案也就能达到我们最终的优化目的。\n\n### 优化不可避免的阻塞：优化关键呈现路径\n#### 关键呈现路径里的一些概念：\n- **关键资源**：可能阻止网页首次呈现的资源。\n- **关键路径长度**：即往返过程数量，或提取所有关键资源所需的总时间。\n- **关键字节**：实现网页首次呈现所需的总字节数，是所有关键资源的传输文件大小总和。 带有一个 HTML 网页的首个示例包含一项关键资源（HTML 文档），关键路径长度也与 1 个网络往返过程（假设文件较小）相等，而且总的关键字节数正好是 HTML 文档本身的传输大小。\n\n#### 优化关键呈现路径的指导原则：\n- 尽量减少关键资源数量。\n- 尽量减少关键字节数。\n- 尽量缩短关键路径的长度。\n\n#### 优化关键呈现路径常规步骤：\n- 分析和描述关键路径：资源数量、字节数、长度。\n- 尽量减少关键资源数量：删除相应资源、延迟下载、标记为异步资源等等。\n- 优化剩余关键资源的加载顺序：你需要尽早下载所有关键资源，以缩短关键路径长度。\n- 尽量减少关键字节数，以缩短下载时间（和往返次数）。\n\n#### 优化关键呈现路径的具体建议：\n- 文件合并、压缩\n\n- 推荐使用异步（async） JavaScript 资源，或使用延迟（defer）执行的 JavaScript\n\n- 一般 &lt;script&gt;脚本的靠后书写\n\n- 避免运行时间长的 JavaScript，耗时任务的拆分，chunk 化运行\n```\n例如：使用定时器将大任务拆分为小任务，使得浏览器得到空隙做其他事情。\n```\n- 避免使用 CSS import\n- 内联、内部化阻止呈现的 CSS\n```\n一般不采用，百度、Google 这样的极度重视性能与体验的服务才可能这样做。\n```\n\n\n### 针对复合图层化的优化\n因为浏览器有图层化这个机制，那么我们就搞懂它并充分利用吧。\n#### 复合图层化机制是怎样的呢？\n如果某些属性的变更（transform、opacity）满足以下条件:\n- 不影响文档流\n- 不依赖文档流\n- 不会造成重绘\n\n那么，这些属性变更时，就需要一种机制：\n能将属性变更的部分与页面其他部分隔离开来，对其他部分已经渲染完的进行缓存，变更的部分在单独的图层上进行，然后对缓存的部分与变更的图层进行合成。\n关键字：**缓存、隔离、图层合成**\n使用 transform 与 opacity 进行属性变更是经典的复合图层优化方法，以下是其他会提升元素为复合图层的场景：\n1.3d 或透视变换 CSS 属性，例如 translate3d, translateZ 等等（JS 一般通过这种方式，使元素获得复合图层）\n2.&lt;video&gt; &lt;iframe&gt; &lt;canvas&gt; &lt;webgl&gt;等元素\n3.混合插件（如flash）\n4.元素自身的 opacity 和 transform 做 CSS 动画\n5.拥有[CSS Filter](http://www.runoob.com/cssref/css3-pr-filter.html)的元素\n6.使用 will-change 属性\n7.position:fixed\n8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上方)\n\n#### 图层化的优势\n很容易看出来：充分利用缓存、隔离的思想，无需像回流、重绘那么大性能（GPU、CPU）开支，图层化能带来 **动画性能的提升**。\n\n图层化的潜在问题/弊端 —— 内存开销\n因为图层化的存在，每个图层对需要在内存中存储该图层相关的信息，当图层太多会造成内存开销过大的情况。\n\n#### 因为开销，所以节制\n内存开销在桌面端可能还能接受，但是在资源有限的移动端，复合图层过多便可能导致内存开支过大，页面反而变得停滞、卡顿，甚至浏览器假死，系统无法正常运行。\n\n\n### 针对回流的优化\n首先，我们需要知道什么情况下会触发浏览器的repaint/reflow：\n查询哪些属性会触发Layout/Paing/Composite,可参考：\nhttps://csstriggers.com/\n\n#### 技术使用优先级：\n1.CSS3 > JavaScript\n2.属性变更优先考虑顺序（性能表现排序）\n- transfrom, opacity\n- background-color等\n- position top、bottom、left、right\n- width、height等\n- margin、padding、border\n\n#### What forces layout\n\n能够引起重绘和回流的属性修改/查找：\n- Element\n**Box metrics**\nelem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParent\nelem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeight\nelem.getClientRects(), elem.getBoundingClientRect()\n\n**Scroll stuff**\nelem.scrollBy(), elem.scrollTo()\nelem.scrollIntoView(), elem.scrollIntoViewIfNeeded()\nelem.scrollWidth, elem.scrollHeight\nelem.scrollLeft, elem.scrollTop also, setting them\n\n**Focus**\nelem.focus() can trigger a double forced layout (source)\n\n**Also…**\nelem.computedRole, elem.computedName\nelem.innerText (source)\n\n- getComputedStyle\n\n- ......\n\n详情查看：https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9\n**JavaScript 存在这样的机制：当连续有大量 DOM 样式的操作时，出于性能考虑，防止零碎变更导致频繁的回流、重绘，会尽可能地将这些操作先缓存起来，然后一次性地变更。这个机制我们难以察觉但是确实存在。\n然而当我们进行某些 DOM 样式的读、写时，出于时效性的考虑，则会立即触发浏览器回流、重绘以返回正确、合理的值。**\n\n\n\n### 减少渲染时的内存消耗\n1.避免浏览器的隐式合成。\n- 保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。\n- 将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。\n\n2.减小复合层的尺寸\n看一下两张图片，有什么不同吗？\n<img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/MinComposite.png\"></img>\n这两张图片视觉上是一样的，但是它们的尺寸一个是39kb；另外一个是400b。不同之处在于，第二个纯色层是通过scale放大10倍做到的。\n```\n<div id=\"a\"></div>\n<div id=\"b\"></div>\n\n<style>\n#a, #b {\n will-change: transform;\n}\n\n#a {\n width: 100px;\n height: 100px;\n}\n\n#b {\n width: 10px;\n height: 10px;\n transform: scale(10);\n}\n</style>\n```\n对于图片，你要怎么做呢？你可以将图片的尺寸减少5%——10%，然后使用scale将它们放大；用户不会看到什么区别，但是你可以减少大量的存储空间。\n\n\n### 减少渲染时的计算数量\n1.用css动画而不是js动画\ncss动画有一个重要的特性，它是完全工作在GPU上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给GPU。\n而如果使用js动画，浏览器必须计算每一帧的状态；\n为了保证平滑的动画，我们必须在浏览器主线程计算新状态；\n把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画；\n当主线程的计算任务过多时，会造成动画的延迟、卡顿。\n\n所以尽可能地使用基于css的动画，不仅仅更快；也不会被大量的js计算所阻塞。\n\n### 节流函数\n### 惰性载入函数\n### [重任务分片多帧](https://zhuanlan.zhihu.com/p/25166666?refer=dreawer)\n\n\n知道原理之后，常用的有如下几点优化方法：\n\n1.避免在document上直接进行频繁的DOM操作，如果确实需要可以采用off-document的方式进行，具体的方法包括但不完全包括以下几种：\n(1). 先将元素从document中删除，完成修改后再把元素放回原来的位置\n\n(2). 将元素的display设置为”none”，完成修改后再把display修改为原来的值\n\n(3). 如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document\n\n2.集中修改样式\n(1). 尽可能少的修改元素style上的属性\n\n(2). 尽量通过修改className来修改样式\n\n(3). 通过cssText属性/className来设置样式值\n\n```\ndocument.getElementById(\"d1\").style.cssText = \"color:red; font-size:13px;\";\n```\n\n3.缓存Layout属性值\n对于Layout属性中非引用类型的值（数字型），如果需要多次访问则可以在一次访问时先存储到局部变量中，之后都使用局部变量，这样可以避免每次读取属性时造成浏览器的渲染。\n```\nvar width = el.offsetWidth; var scrollLeft = el.scrollLeft;\n```\n\n4.设置元素的position为absolute或fixed\n\n\n5.不要使用table布局。\n\n6.css动画中尽量只使用transform和opacity，这不会发生重排和重绘。\n如上所说，transform和opacity保证了元素属性的变化不影响文档流、也不受文档流影响；并且不会造成repaint。\n有些时候你可能想要改变其他的css属性，作为动画。例如：你可能想使用background属性改变背景：\n```\n<div class=\"bg-change\"></div>\n.bg-change {\n  width: 100px;\n  height: 100px;\n  background: red;\n  transition: opacity 2s;\n}\n.bg-change:hover {\n  background: blue;\n}\n```\n在这个例子中，在动画的每一步；浏览器都会进行一次重绘。我们可以使用一个复层在这个元素上面，并且仅仅变换opacity属性：\n```html\n<div class=\"bg-change\"></div>\n<style>\n.bg-change {\n  width: 100px;\n  height: 100px;\n  background: red;\n}\n.bg-change::before {\n  content: '';\n  display: block;\n  width: 100%;\n  height: 100%;\n  background: blue;\n  opacity: 0;\n  transition: opacity 20s;\n}\n.bg-change:hover::before {\n  opacity: 1;\n}\n</style>\n```\n\n\n\n\n\n\n## 回答几个问题 自测\n\n### 如何理解 getComputedStyle?\n\n在尚未梳理知识体系前，大概会这样回答：\n\n普通版本： getComputedStyle会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过 window.getComputedStyle等价于 document.defaultView.getComputedStyle调用\n\n详细版本： window.getComputedStyle(elem,null).getPropertyValue(\"height\")可能的值为 100px，而且，就算是css上写的是 inherit， getComputedStyle也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么 getComputedStyle获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。\n\n就这个API来说，上述的回答已经比较全面了。\n\n但是，其实它是可以继续延伸的。\n\n譬如现在会这样回答：\n\ngetComputedStyle会获取当前元素所有最终使用的CSS属性值， window.和 document.defaultView.等价...\n\ngetComputedStyle会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如 offsetXXX， scrollXXX， clientXXX， currentStyle等等\n\n### visibility:hidden和 display:none的区别?\n\n可以如下回答：\n\n普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置\n\n进一步， display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大\n\n再进一步，当一个页面某个元素经常需要切换 display时如何优化，一般会用复合层优化，或者要求低一点用 absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流， absolute文档流，复合图层的区别，\n\n再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）\n\n上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖\n\n\n参考：\n- [https://www.cnblogs.com/fullhouse/archive/2012/02/20/2360301.html](如何减少浏览器repaint和reflow)\n- [https://mp.weixin.qq.com/s/LIfvU8j0gBVIFF8AYYtfFg](从输入URL到页面加载的过程？)\n- [https://www.cnblogs.com/ys-wuhan/p/6985624.html](浏览器内核、页面呈现原理及其优化)\n- [https://zhuanlan.zhihu.com/p/24911872?refer=dreawer](从Chrome源码看浏览器如何构建DOM树)\n- [https://segmentfault.com/a/1190000008015671#articleHeader9](一篇文章说清浏览器解析和CSS（GPU）动画优化)\n","slug":"浏览器解析渲染过程解析","published":1,"updated":"2018-10-24T13:56:07.000Z","_id":"cjnn81wh4005d7q0t9rui7r3z","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在浏览器从获取到HTML，然后解析，渲染的过程中，到底发生了什么？</p>\n<h2 id=\"页面呈现六部曲\"><a href=\"#页面呈现六部曲\" class=\"headerlink\" title=\"页面呈现六部曲\"></a>页面呈现六部曲</h2><p>1.解析HTML,构建DOM树。<br>2.解析CSS,生成CSS规则树。<br><em>在chrome的Timeline 工具中对应的阶段是：Re-caculate。为什么是 Re-caculate Style 呢？这是因为浏览器本身有 User Agent StyleSheet，所以最终的样式是我们的样式代码样式与用户代理默认样式覆盖/重新计算得到的。</em><br>3.合并 DOM 树与 CSSOM 树为 Render 树<br>4.布局（Layout）<br>5.绘制（Paint）<br>6.复合图层化（Composite）<br>多个复合层的合成，最终合成的页面被用户看到。</p>\n<a id=\"more\"></a>\n<h2 id=\"六部曲中存在的阻塞\"><a href=\"#六部曲中存在的阻塞\" class=\"headerlink\" title=\"六部曲中存在的阻塞\"></a>六部曲中存在的阻塞</h2><p>虽然六部曲看似和谐，分工合作，有序进行。但是实际上这里面却是波云诡谲，风起云涌，就像平时的工作一样，看似你和我各司其职，分工明确，但是实际干起活来却可能因为某一个人的某一环而阻滞整个进度。</p>\n<p>那么下面我们来分析一下六部曲中存在的阻塞：</p>\n<ol>\n<li>当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（阻塞1）<br>然而，是否停下 DOM 的构建的同时，立马就执行 JavaScript 代码或者下载外部脚本执行，其实还是要视情况而定</li>\n<li>当遇到 &lt;script&gt;标签需要执行脚本代码时，浏览器会检查是否这个 &lt;script&gt;标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 &lt;script&gt;上部还有 CSS 样式没加载，则浏览器会等待 &lt;script&gt;上方样式的加载完成才会执行该 &lt;script&gt;内的脚本，（阻塞2）</li>\n<li>DOM 树与 CSSOM 树的成功构建是后面步骤的根基（同步阻塞）</li>\n<li>同时外部脚本、外部样式表的下载也是耗费时间较多的点</li>\n</ol>\n<h2 id=\"六部曲之——DOM树的构建\"><a href=\"#六部曲之——DOM树的构建\" class=\"headerlink\" title=\"六部曲之——DOM树的构建\"></a>六部曲之——DOM树的构建</h2><p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/DOM%20tree.png\"></p>\n<p>浏览器构建DOM树可以简单的总结为以下几步：</p>\n<ol>\n<li>转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</li>\n<li>Tokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</li>\n<li>构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/htmlParse.png\"></li>\n<li>构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 Chrome 开发者工具下 Timeline 面板的 <span class=\"built_in\">Parse</span> HTML 阶段对应着 DOM 树的构建。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>扩展阅读：<a href=\"https://zhuanlan.zhihu.com/p/24911872?refer=dreawer\" target=\"_blank\" rel=\"noopener\">从Chrome源码看浏览器如何构建DOM树 </a><br>留意这篇文章的这些点：</p>\n<ol>\n<li>DOM 构建时对 DOCType 处理</li>\n<li>DOCType 的不同或漏缺带来的文档解析模式（怪异模式、有限怪异模式、标准模式）的影响</li>\n<li>处理开标签与闭标签的压栈、弹栈处理</li>\n<li>Chromium 对待自定义标签的处理</li>\n<li>JavaScript 方法查找 DOM 的过程，使用 ID、类名、复杂选择器查找 DOM 的对比</li>\n</ol>\n<h2 id=\"六部曲之——CSSOM树的构建\"><a href=\"#六部曲之——CSSOM树的构建\" class=\"headerlink\" title=\"六部曲之——CSSOM树的构建\"></a>六部曲之——CSSOM树的构建</h2><p>CSSOM 树的构建 “原料” 的来源有：外部 CSS 文件、内部样式、内联样式。</p>\n<p><em>CSSOM 树的构建其实是一个 样式的重新计算 的过程，为什么是重新计算呢？</em><br><figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户代理（即浏览器）本身有一套内置样式表，所以我们最终的 CSSOM 树其实是用户代理样式与页面所有样式的重新计算。</span><br><span class=\"line\">所以在 Chrome 浏览器开发者工具的 Timeline 面板下，CSSOM 树的构建对应的是 Recalculate <span class=\"keyword\">Style</span> 阶段</span><br></pre></td></tr></table></figure></p>\n<p>与 DOM 树的构建过程相似，CSSOM 的构建也要经历以下过程：<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom.png\"></p>\n<p>最终构建的 CSSOM 树大致如下：<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom_end.png\"></p>\n<h2 id=\"六部曲之——渲染树的构建\"><a href=\"#六部曲之——渲染树的构建\" class=\"headerlink\" title=\"六部曲之——渲染树的构建\"></a>六部曲之——渲染树的构建</h2><p>1.DOM 树与 CSSOM 树融合成渲染树<br>2.渲染树只包括渲染页面需要的节点<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">排除 <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"handlebars\"><span class=\"xml\"> <span class=\"tag\">&lt;<span class=\"name\">meta</span>&gt;</span> 等功能化、非视觉节点</span></span></span><br><span class=\"line\"><span class=\"undefined\">排除 display: none 的节点</span></span><br></pre></td></tr></table></figure></p>\n<p>过程大致如下：<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/renderTree.png\"></p>\n<h2 id=\"六部曲之——布局\"><a href=\"#六部曲之——布局\" class=\"headerlink\" title=\"六部曲之——布局\"></a>六部曲之——布局</h2><p>Layout 阶段做的工作：确定页面各元素的位置、尺寸。<br><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Layout</span> 在 Chrome 开发者工具 Timeline 面板中被归并到 Paint 阶段</span><br></pre></td></tr></table></figure></p>\n<p>当元素某些样式变更/JavaScript 执行某些样式请求，会导致 Layout trashing，又叫做回流（Reflow）。</p>\n<h2 id=\"六部曲之——绘制\"><a href=\"#六部曲之——绘制\" class=\"headerlink\" title=\"六部曲之——绘制\"></a>六部曲之——绘制</h2><p>一旦布局（Layout）步骤完成，浏览器便触发 <em>Paint Setup</em> 与 <em>Paint</em> 事件（渲染引擎底层概念），执行 paint 操作，结合渲染树与布局信息绘制实际像素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：在 Timeline 工具内，Layout 与 Paint 两个过程被统一归并到 Paint 阶段。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"六部曲之——复合图层化\"><a href=\"#六部曲之——复合图层化\" class=\"headerlink\" title=\"六部曲之——复合图层化\"></a>六部曲之——复合图层化</h2><p>在很多情况下，我们不会将复合图层化归入页面呈现的必要过程。图层化是浏览器为了充分利用已有渲染成果（缓存渲染成果），最小化 GPU 运算，将“脏区”提升为复合图层，隔离变化影响的操作。</p>\n<p>详情见<a href=\"一篇文章说清浏览器解析和CSS（GPU）动画优化\">https://segmentfault.com/a/1190000008015671</a></p>\n<h3 id=\"如何创建layer\"><a href=\"#如何创建layer\" class=\"headerlink\" title=\"如何创建layer\"></a>如何创建layer</h3><p>1.3D 或透视变换(perspective transform) CSS 属性<br>2.使用加速视频解码的元素，如&lt;video&gt;<br>3.拥有 3D (WebGL) 上下文或加速的 2D 上下文的，如&lt;canvas&gt;<br>4.混合插件(如 Flash)<br>5.对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素<br>6.拥有加速 CSS 过滤器的元素，如CSS filters<br>7.元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)<br>8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)<br>9.在webkit内核的浏览器中，如果有上述情况，则会创建一个独立的layer。</p>\n<h3 id=\"拒绝layer泛滥\"><a href=\"#拒绝layer泛滥\" class=\"headerlink\" title=\"拒绝layer泛滥\"></a>拒绝layer泛滥</h3><p><strong>当对元素创建layer之后，会节省layout和paint阶段，但是layer不能泛滥。 layer跟psd中图层很像，我们知道在psd中图层越多，psd图片就会越大。 同理，layer越多，占用的内存就越多，当在内存有限的移动设备上（手机），过多的渲染带来的开销超过了它在性能上的改善,得不偿失； 白白的给元素添加layer，一般通过* {-webkit-transform: translateZ(0);}为元素添加layer 但创建layer的原则：当且仅当需要的时候才为元素创建渲染层。</strong></p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>渲染分为三阶段：layout，paint，composite layer，修改不同的css属性会触发不同的阶段，触发的阶段越靠前，渲染的代价越高。</strong><br>1：尽量避免触发layout（位置相关的可通过transform代替 top left），paint。 除写css属性外，读取css的位置大小相关属性会导致触发layout阶段，要分离读写，减少layout。<br>2：应该尽量避免重绘，并且尽可能的使绘制区域最小，以提升页面性能。 但是有些必须使用的样式效果还是要用的，比如fixed等重要的是作为前端人员，能够预估这些代码所带来的性能损耗及所造成的影响。<br>3：避免组合触发 比如滚动和hover效果，hover中若使用border-shadow，border-style修改，则会损耗较大的性能，有可能会触发丢帧的现象。 改进办法：在滚动时，增加计时器，可先把hover效果禁掉，滚动结束后再打开hover效果。</p>\n<h2 id=\"浏览器的渲染流程方向的优化手段\"><a href=\"#浏览器的渲染流程方向的优化手段\" class=\"headerlink\" title=\"浏览器的渲染流程方向的优化手段\"></a>浏览器的渲染流程方向的优化手段</h2><p>知道了页面渲染的原理，那么我们也就得到了页面性能优化的依据。提炼六部曲中每一步的优化空间，针对六部曲中的每一步提出针对性的优化方案也就能达到我们最终的优化目的。</p>\n<h3 id=\"优化不可避免的阻塞：优化关键呈现路径\"><a href=\"#优化不可避免的阻塞：优化关键呈现路径\" class=\"headerlink\" title=\"优化不可避免的阻塞：优化关键呈现路径\"></a>优化不可避免的阻塞：优化关键呈现路径</h3><h4 id=\"关键呈现路径里的一些概念：\"><a href=\"#关键呈现路径里的一些概念：\" class=\"headerlink\" title=\"关键呈现路径里的一些概念：\"></a>关键呈现路径里的一些概念：</h4><ul>\n<li><strong>关键资源</strong>：可能阻止网页首次呈现的资源。</li>\n<li><strong>关键路径长度</strong>：即往返过程数量，或提取所有关键资源所需的总时间。</li>\n<li><strong>关键字节</strong>：实现网页首次呈现所需的总字节数，是所有关键资源的传输文件大小总和。 带有一个 HTML 网页的首个示例包含一项关键资源（HTML 文档），关键路径长度也与 1 个网络往返过程（假设文件较小）相等，而且总的关键字节数正好是 HTML 文档本身的传输大小。</li>\n</ul>\n<h4 id=\"优化关键呈现路径的指导原则：\"><a href=\"#优化关键呈现路径的指导原则：\" class=\"headerlink\" title=\"优化关键呈现路径的指导原则：\"></a>优化关键呈现路径的指导原则：</h4><ul>\n<li>尽量减少关键资源数量。</li>\n<li>尽量减少关键字节数。</li>\n<li>尽量缩短关键路径的长度。</li>\n</ul>\n<h4 id=\"优化关键呈现路径常规步骤：\"><a href=\"#优化关键呈现路径常规步骤：\" class=\"headerlink\" title=\"优化关键呈现路径常规步骤：\"></a>优化关键呈现路径常规步骤：</h4><ul>\n<li>分析和描述关键路径：资源数量、字节数、长度。</li>\n<li>尽量减少关键资源数量：删除相应资源、延迟下载、标记为异步资源等等。</li>\n<li>优化剩余关键资源的加载顺序：你需要尽早下载所有关键资源，以缩短关键路径长度。</li>\n<li>尽量减少关键字节数，以缩短下载时间（和往返次数）。</li>\n</ul>\n<h4 id=\"优化关键呈现路径的具体建议：\"><a href=\"#优化关键呈现路径的具体建议：\" class=\"headerlink\" title=\"优化关键呈现路径的具体建议：\"></a>优化关键呈现路径的具体建议：</h4><ul>\n<li><p>文件合并、压缩</p>\n</li>\n<li><p>推荐使用异步（async） JavaScript 资源，或使用延迟（defer）执行的 JavaScript</p>\n</li>\n<li><p>一般 &lt;script&gt;脚本的靠后书写</p>\n</li>\n<li><p>避免运行时间长的 JavaScript，耗时任务的拆分，chunk 化运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如：使用定时器将大任务拆分为小任务，使得浏览器得到空隙做其他事情。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>避免使用 CSS import</p>\n</li>\n<li>内联、内部化阻止呈现的 CSS<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一般不采用，百度、Google 这样的极度重视性能与体验的服务才可能这样做。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"针对复合图层化的优化\"><a href=\"#针对复合图层化的优化\" class=\"headerlink\" title=\"针对复合图层化的优化\"></a>针对复合图层化的优化</h3><p>因为浏览器有图层化这个机制，那么我们就搞懂它并充分利用吧。</p>\n<h4 id=\"复合图层化机制是怎样的呢？\"><a href=\"#复合图层化机制是怎样的呢？\" class=\"headerlink\" title=\"复合图层化机制是怎样的呢？\"></a>复合图层化机制是怎样的呢？</h4><p>如果某些属性的变更（transform、opacity）满足以下条件:</p>\n<ul>\n<li>不影响文档流</li>\n<li>不依赖文档流</li>\n<li>不会造成重绘</li>\n</ul>\n<p>那么，这些属性变更时，就需要一种机制：<br>能将属性变更的部分与页面其他部分隔离开来，对其他部分已经渲染完的进行缓存，变更的部分在单独的图层上进行，然后对缓存的部分与变更的图层进行合成。<br>关键字：<strong>缓存、隔离、图层合成</strong><br>使用 transform 与 opacity 进行属性变更是经典的复合图层优化方法，以下是其他会提升元素为复合图层的场景：<br>1.3d 或透视变换 CSS 属性，例如 translate3d, translateZ 等等（JS 一般通过这种方式，使元素获得复合图层）<br>2.&lt;video&gt; &lt;iframe&gt; &lt;canvas&gt; &lt;webgl&gt;等元素<br>3.混合插件（如flash）<br>4.元素自身的 opacity 和 transform 做 CSS 动画<br>5.拥有<a href=\"http://www.runoob.com/cssref/css3-pr-filter.html\" target=\"_blank\" rel=\"noopener\">CSS Filter</a>的元素<br>6.使用 will-change 属性<br>7.position:fixed<br>8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上方)</p>\n<h4 id=\"图层化的优势\"><a href=\"#图层化的优势\" class=\"headerlink\" title=\"图层化的优势\"></a>图层化的优势</h4><p>很容易看出来：充分利用缓存、隔离的思想，无需像回流、重绘那么大性能（GPU、CPU）开支，图层化能带来 <strong>动画性能的提升</strong>。</p>\n<p>图层化的潜在问题/弊端 —— 内存开销<br>因为图层化的存在，每个图层对需要在内存中存储该图层相关的信息，当图层太多会造成内存开销过大的情况。</p>\n<h4 id=\"因为开销，所以节制\"><a href=\"#因为开销，所以节制\" class=\"headerlink\" title=\"因为开销，所以节制\"></a>因为开销，所以节制</h4><p>内存开销在桌面端可能还能接受，但是在资源有限的移动端，复合图层过多便可能导致内存开支过大，页面反而变得停滞、卡顿，甚至浏览器假死，系统无法正常运行。</p>\n<h3 id=\"针对回流的优化\"><a href=\"#针对回流的优化\" class=\"headerlink\" title=\"针对回流的优化\"></a>针对回流的优化</h3><p>首先，我们需要知道什么情况下会触发浏览器的repaint/reflow：<br>查询哪些属性会触发Layout/Paing/Composite,可参考：<br><a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">https://csstriggers.com/</a></p>\n<h4 id=\"技术使用优先级：\"><a href=\"#技术使用优先级：\" class=\"headerlink\" title=\"技术使用优先级：\"></a>技术使用优先级：</h4><p>1.CSS3 &gt; JavaScript<br>2.属性变更优先考虑顺序（性能表现排序）</p>\n<ul>\n<li>transfrom, opacity</li>\n<li>background-color等</li>\n<li>position top、bottom、left、right</li>\n<li>width、height等</li>\n<li>margin、padding、border</li>\n</ul>\n<h4 id=\"What-forces-layout\"><a href=\"#What-forces-layout\" class=\"headerlink\" title=\"What forces layout\"></a>What forces layout</h4><p>能够引起重绘和回流的属性修改/查找：</p>\n<ul>\n<li>Element<br><strong>Box metrics</strong><br>elem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParent<br>elem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeight<br>elem.getClientRects(), elem.getBoundingClientRect()</li>\n</ul>\n<p><strong>Scroll stuff</strong><br>elem.scrollBy(), elem.scrollTo()<br>elem.scrollIntoView(), elem.scrollIntoViewIfNeeded()<br>elem.scrollWidth, elem.scrollHeight<br>elem.scrollLeft, elem.scrollTop also, setting them</p>\n<p><strong>Focus</strong><br>elem.focus() can trigger a double forced layout (source)</p>\n<p><strong>Also…</strong><br>elem.computedRole, elem.computedName<br>elem.innerText (source)</p>\n<ul>\n<li><p>getComputedStyle</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<p>详情查看：<a href=\"https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9</a><br><strong>JavaScript 存在这样的机制：当连续有大量 DOM 样式的操作时，出于性能考虑，防止零碎变更导致频繁的回流、重绘，会尽可能地将这些操作先缓存起来，然后一次性地变更。这个机制我们难以察觉但是确实存在。<br>然而当我们进行某些 DOM 样式的读、写时，出于时效性的考虑，则会立即触发浏览器回流、重绘以返回正确、合理的值。</strong></p>\n<h3 id=\"减少渲染时的内存消耗\"><a href=\"#减少渲染时的内存消耗\" class=\"headerlink\" title=\"减少渲染时的内存消耗\"></a>减少渲染时的内存消耗</h3><p>1.避免浏览器的隐式合成。</p>\n<ul>\n<li>保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。</li>\n<li>将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。</li>\n</ul>\n<p>2.减小复合层的尺寸<br>看一下两张图片，有什么不同吗？<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/MinComposite.png\"><br>这两张图片视觉上是一样的，但是它们的尺寸一个是39kb；另外一个是400b。不同之处在于，第二个纯色层是通过scale放大10倍做到的。<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"a\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"b\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#a</span>, <span class=\"selector-id\">#b</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\"> will-change: transform;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#a</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\"> width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\"> height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#b</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\"> width: 10px;</span></span><br><span class=\"line\"><span class=\"undefined\"> height: 10px;</span></span><br><span class=\"line\"><span class=\"undefined\"> transform: scale(10);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>对于图片，你要怎么做呢？你可以将图片的尺寸减少5%——10%，然后使用scale将它们放大；用户不会看到什么区别，但是你可以减少大量的存储空间。</p>\n<h3 id=\"减少渲染时的计算数量\"><a href=\"#减少渲染时的计算数量\" class=\"headerlink\" title=\"减少渲染时的计算数量\"></a>减少渲染时的计算数量</h3><p>1.用css动画而不是js动画<br>css动画有一个重要的特性，它是完全工作在GPU上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给GPU。<br>而如果使用js动画，浏览器必须计算每一帧的状态；<br>为了保证平滑的动画，我们必须在浏览器主线程计算新状态；<br>把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画；<br>当主线程的计算任务过多时，会造成动画的延迟、卡顿。</p>\n<p>所以尽可能地使用基于css的动画，不仅仅更快；也不会被大量的js计算所阻塞。</p>\n<h3 id=\"节流函数\"><a href=\"#节流函数\" class=\"headerlink\" title=\"节流函数\"></a>节流函数</h3><h3 id=\"惰性载入函数\"><a href=\"#惰性载入函数\" class=\"headerlink\" title=\"惰性载入函数\"></a>惰性载入函数</h3><h3 id=\"重任务分片多帧\"><a href=\"#重任务分片多帧\" class=\"headerlink\" title=\"重任务分片多帧\"></a><a href=\"https://zhuanlan.zhihu.com/p/25166666?refer=dreawer\" target=\"_blank\" rel=\"noopener\">重任务分片多帧</a></h3><p>知道原理之后，常用的有如下几点优化方法：</p>\n<p>1.避免在document上直接进行频繁的DOM操作，如果确实需要可以采用off-document的方式进行，具体的方法包括但不完全包括以下几种：<br>(1). 先将元素从document中删除，完成修改后再把元素放回原来的位置</p>\n<p>(2). 将元素的display设置为”none”，完成修改后再把display修改为原来的值</p>\n<p>(3). 如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document</p>\n<p>2.集中修改样式<br>(1). 尽可能少的修改元素style上的属性</p>\n<p>(2). 尽量通过修改className来修改样式</p>\n<p>(3). 通过cssText属性/className来设置样式值</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(<span class=\"string\">\"d1\"</span>).style.cssText = <span class=\"string\">\"color:red; font-size:13px;\"</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>3.缓存Layout属性值<br>对于Layout属性中非引用类型的值（数字型），如果需要多次访问则可以在一次访问时先存储到局部变量中，之后都使用局部变量，这样可以避免每次读取属性时造成浏览器的渲染。<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var width</span> = el.offsetWidth; <span class=\"attribute\">v</span><span class=\"attribute\">a</span><span class=\"attribute\">r</span> <span class=\"attribute\">s</span><span class=\"attribute\">c</span><span class=\"attribute\">r</span><span class=\"attribute\">o</span><span class=\"attribute\">l</span><span class=\"attribute\">l</span><span class=\"attribute\">L</span><span class=\"attribute\">e</span><span class=\"attribute\">f</span><span class=\"attribute\">t</span> = el.scrollLeft;</span><br></pre></td></tr></table></figure></p>\n<p>4.设置元素的position为absolute或fixed</p>\n<p>5.不要使用table布局。</p>\n<p>6.css动画中尽量只使用transform和opacity，这不会发生重排和重绘。<br>如上所说，transform和opacity保证了元素属性的变化不影响文档流、也不受文档流影响；并且不会造成repaint。<br>有些时候你可能想要改变其他的css属性，作为动画。例如：你可能想使用background属性改变背景：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">\"bg-change\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-class\">.bg-change</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">2s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.bg-change</span>:hover &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，在动画的每一步；浏览器都会进行一次重绘。我们可以使用一个复层在这个元素上面，并且仅仅变换opacity属性：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bg-change\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.bg-change</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  background: red;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.bg-change</span><span class=\"selector-pseudo\">::before</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  content: '';</span></span><br><span class=\"line\"><span class=\"undefined\">  display: block;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">  height: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">  background: blue;</span></span><br><span class=\"line\"><span class=\"undefined\">  opacity: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">  transition: opacity 20s;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.bg-change</span><span class=\"selector-pseudo\">:hover</span><span class=\"selector-pseudo\">::before</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  opacity: 1;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"回答几个问题-自测\"><a href=\"#回答几个问题-自测\" class=\"headerlink\" title=\"回答几个问题 自测\"></a>回答几个问题 自测</h2><h3 id=\"如何理解-getComputedStyle\"><a href=\"#如何理解-getComputedStyle\" class=\"headerlink\" title=\"如何理解 getComputedStyle?\"></a>如何理解 getComputedStyle?</h3><p>在尚未梳理知识体系前，大概会这样回答：</p>\n<p>普通版本： getComputedStyle会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过 window.getComputedStyle等价于 document.defaultView.getComputedStyle调用</p>\n<p>详细版本： window.getComputedStyle(elem,null).getPropertyValue(“height”)可能的值为 100px，而且，就算是css上写的是 inherit， getComputedStyle也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么 getComputedStyle获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。</p>\n<p>就这个API来说，上述的回答已经比较全面了。</p>\n<p>但是，其实它是可以继续延伸的。</p>\n<p>譬如现在会这样回答：</p>\n<p>getComputedStyle会获取当前元素所有最终使用的CSS属性值， window.和 document.defaultView.等价…</p>\n<p>getComputedStyle会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如 offsetXXX， scrollXXX， clientXXX， currentStyle等等</p>\n<h3 id=\"visibility-hidden和-display-none的区别\"><a href=\"#visibility-hidden和-display-none的区别\" class=\"headerlink\" title=\"visibility:hidden和 display:none的区别?\"></a>visibility:hidden和 display:none的区别?</h3><p>可以如下回答：</p>\n<p>普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置</p>\n<p>进一步， display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大</p>\n<p>再进一步，当一个页面某个元素经常需要切换 display时如何优化，一般会用复合层优化，或者要求低一点用 absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流， absolute文档流，复合图层的区别，</p>\n<p>再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）</p>\n<p>上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"如何减少浏览器repaint和reflow\">https://www.cnblogs.com/fullhouse/archive/2012/02/20/2360301.html</a></li>\n<li><a href=\"从输入URL到页面加载的过程？\">https://mp.weixin.qq.com/s/LIfvU8j0gBVIFF8AYYtfFg</a></li>\n<li><a href=\"浏览器内核、页面呈现原理及其优化\">https://www.cnblogs.com/ys-wuhan/p/6985624.html</a></li>\n<li><a href=\"从Chrome源码看浏览器如何构建DOM树\">https://zhuanlan.zhihu.com/p/24911872?refer=dreawer</a></li>\n<li><a href=\"一篇文章说清浏览器解析和CSS（GPU）动画优化\">https://segmentfault.com/a/1190000008015671#articleHeader9</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在浏览器从获取到HTML，然后解析，渲染的过程中，到底发生了什么？</p>\n<h2 id=\"页面呈现六部曲\"><a href=\"#页面呈现六部曲\" class=\"headerlink\" title=\"页面呈现六部曲\"></a>页面呈现六部曲</h2><p>1.解析HTML,构建DOM树。<br>2.解析CSS,生成CSS规则树。<br><em>在chrome的Timeline 工具中对应的阶段是：Re-caculate。为什么是 Re-caculate Style 呢？这是因为浏览器本身有 User Agent StyleSheet，所以最终的样式是我们的样式代码样式与用户代理默认样式覆盖/重新计算得到的。</em><br>3.合并 DOM 树与 CSSOM 树为 Render 树<br>4.布局（Layout）<br>5.绘制（Paint）<br>6.复合图层化（Composite）<br>多个复合层的合成，最终合成的页面被用户看到。</p>","more":"<h2 id=\"六部曲中存在的阻塞\"><a href=\"#六部曲中存在的阻塞\" class=\"headerlink\" title=\"六部曲中存在的阻塞\"></a>六部曲中存在的阻塞</h2><p>虽然六部曲看似和谐，分工合作，有序进行。但是实际上这里面却是波云诡谲，风起云涌，就像平时的工作一样，看似你和我各司其职，分工明确，但是实际干起活来却可能因为某一个人的某一环而阻滞整个进度。</p>\n<p>那么下面我们来分析一下六部曲中存在的阻塞：</p>\n<ol>\n<li>当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（阻塞1）<br>然而，是否停下 DOM 的构建的同时，立马就执行 JavaScript 代码或者下载外部脚本执行，其实还是要视情况而定</li>\n<li>当遇到 &lt;script&gt;标签需要执行脚本代码时，浏览器会检查是否这个 &lt;script&gt;标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 &lt;script&gt;上部还有 CSS 样式没加载，则浏览器会等待 &lt;script&gt;上方样式的加载完成才会执行该 &lt;script&gt;内的脚本，（阻塞2）</li>\n<li>DOM 树与 CSSOM 树的成功构建是后面步骤的根基（同步阻塞）</li>\n<li>同时外部脚本、外部样式表的下载也是耗费时间较多的点</li>\n</ol>\n<h2 id=\"六部曲之——DOM树的构建\"><a href=\"#六部曲之——DOM树的构建\" class=\"headerlink\" title=\"六部曲之——DOM树的构建\"></a>六部曲之——DOM树的构建</h2><p><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/DOM%20tree.png\"></p>\n<p>浏览器构建DOM树可以简单的总结为以下几步：</p>\n<ol>\n<li>转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</li>\n<li>Tokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</li>\n<li>构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/htmlParse.png\"></li>\n<li>构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 Chrome 开发者工具下 Timeline 面板的 <span class=\"built_in\">Parse</span> HTML 阶段对应着 DOM 树的构建。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>扩展阅读：<a href=\"https://zhuanlan.zhihu.com/p/24911872?refer=dreawer\" target=\"_blank\" rel=\"noopener\">从Chrome源码看浏览器如何构建DOM树 </a><br>留意这篇文章的这些点：</p>\n<ol>\n<li>DOM 构建时对 DOCType 处理</li>\n<li>DOCType 的不同或漏缺带来的文档解析模式（怪异模式、有限怪异模式、标准模式）的影响</li>\n<li>处理开标签与闭标签的压栈、弹栈处理</li>\n<li>Chromium 对待自定义标签的处理</li>\n<li>JavaScript 方法查找 DOM 的过程，使用 ID、类名、复杂选择器查找 DOM 的对比</li>\n</ol>\n<h2 id=\"六部曲之——CSSOM树的构建\"><a href=\"#六部曲之——CSSOM树的构建\" class=\"headerlink\" title=\"六部曲之——CSSOM树的构建\"></a>六部曲之——CSSOM树的构建</h2><p>CSSOM 树的构建 “原料” 的来源有：外部 CSS 文件、内部样式、内联样式。</p>\n<p><em>CSSOM 树的构建其实是一个 样式的重新计算 的过程，为什么是重新计算呢？</em><br><figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户代理（即浏览器）本身有一套内置样式表，所以我们最终的 CSSOM 树其实是用户代理样式与页面所有样式的重新计算。</span><br><span class=\"line\">所以在 Chrome 浏览器开发者工具的 Timeline 面板下，CSSOM 树的构建对应的是 Recalculate <span class=\"keyword\">Style</span> 阶段</span><br></pre></td></tr></table></figure></p>\n<p>与 DOM 树的构建过程相似，CSSOM 的构建也要经历以下过程：<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom.png\"></p>\n<p>最终构建的 CSSOM 树大致如下：<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/cssom_end.png\"></p>\n<h2 id=\"六部曲之——渲染树的构建\"><a href=\"#六部曲之——渲染树的构建\" class=\"headerlink\" title=\"六部曲之——渲染树的构建\"></a>六部曲之——渲染树的构建</h2><p>1.DOM 树与 CSSOM 树融合成渲染树<br>2.渲染树只包括渲染页面需要的节点<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">排除 <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"handlebars\"><span class=\"xml\"> <span class=\"tag\">&lt;<span class=\"name\">meta</span>&gt;</span> 等功能化、非视觉节点</span></span></span><br><span class=\"line\"><span class=\"undefined\">排除 display: none 的节点</span></span><br></pre></td></tr></table></figure></p>\n<p>过程大致如下：<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/renderTree.png\"></p>\n<h2 id=\"六部曲之——布局\"><a href=\"#六部曲之——布局\" class=\"headerlink\" title=\"六部曲之——布局\"></a>六部曲之——布局</h2><p>Layout 阶段做的工作：确定页面各元素的位置、尺寸。<br><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Layout</span> 在 Chrome 开发者工具 Timeline 面板中被归并到 Paint 阶段</span><br></pre></td></tr></table></figure></p>\n<p>当元素某些样式变更/JavaScript 执行某些样式请求，会导致 Layout trashing，又叫做回流（Reflow）。</p>\n<h2 id=\"六部曲之——绘制\"><a href=\"#六部曲之——绘制\" class=\"headerlink\" title=\"六部曲之——绘制\"></a>六部曲之——绘制</h2><p>一旦布局（Layout）步骤完成，浏览器便触发 <em>Paint Setup</em> 与 <em>Paint</em> 事件（渲染引擎底层概念），执行 paint 操作，结合渲染树与布局信息绘制实际像素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：在 Timeline 工具内，Layout 与 Paint 两个过程被统一归并到 Paint 阶段。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"六部曲之——复合图层化\"><a href=\"#六部曲之——复合图层化\" class=\"headerlink\" title=\"六部曲之——复合图层化\"></a>六部曲之——复合图层化</h2><p>在很多情况下，我们不会将复合图层化归入页面呈现的必要过程。图层化是浏览器为了充分利用已有渲染成果（缓存渲染成果），最小化 GPU 运算，将“脏区”提升为复合图层，隔离变化影响的操作。</p>\n<p>详情见<a href=\"一篇文章说清浏览器解析和CSS（GPU）动画优化\">https://segmentfault.com/a/1190000008015671</a></p>\n<h3 id=\"如何创建layer\"><a href=\"#如何创建layer\" class=\"headerlink\" title=\"如何创建layer\"></a>如何创建layer</h3><p>1.3D 或透视变换(perspective transform) CSS 属性<br>2.使用加速视频解码的元素，如&lt;video&gt;<br>3.拥有 3D (WebGL) 上下文或加速的 2D 上下文的，如&lt;canvas&gt;<br>4.混合插件(如 Flash)<br>5.对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素<br>6.拥有加速 CSS 过滤器的元素，如CSS filters<br>7.元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)<br>8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)<br>9.在webkit内核的浏览器中，如果有上述情况，则会创建一个独立的layer。</p>\n<h3 id=\"拒绝layer泛滥\"><a href=\"#拒绝layer泛滥\" class=\"headerlink\" title=\"拒绝layer泛滥\"></a>拒绝layer泛滥</h3><p><strong>当对元素创建layer之后，会节省layout和paint阶段，但是layer不能泛滥。 layer跟psd中图层很像，我们知道在psd中图层越多，psd图片就会越大。 同理，layer越多，占用的内存就越多，当在内存有限的移动设备上（手机），过多的渲染带来的开销超过了它在性能上的改善,得不偿失； 白白的给元素添加layer，一般通过* {-webkit-transform: translateZ(0);}为元素添加layer 但创建layer的原则：当且仅当需要的时候才为元素创建渲染层。</strong></p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>渲染分为三阶段：layout，paint，composite layer，修改不同的css属性会触发不同的阶段，触发的阶段越靠前，渲染的代价越高。</strong><br>1：尽量避免触发layout（位置相关的可通过transform代替 top left），paint。 除写css属性外，读取css的位置大小相关属性会导致触发layout阶段，要分离读写，减少layout。<br>2：应该尽量避免重绘，并且尽可能的使绘制区域最小，以提升页面性能。 但是有些必须使用的样式效果还是要用的，比如fixed等重要的是作为前端人员，能够预估这些代码所带来的性能损耗及所造成的影响。<br>3：避免组合触发 比如滚动和hover效果，hover中若使用border-shadow，border-style修改，则会损耗较大的性能，有可能会触发丢帧的现象。 改进办法：在滚动时，增加计时器，可先把hover效果禁掉，滚动结束后再打开hover效果。</p>\n<h2 id=\"浏览器的渲染流程方向的优化手段\"><a href=\"#浏览器的渲染流程方向的优化手段\" class=\"headerlink\" title=\"浏览器的渲染流程方向的优化手段\"></a>浏览器的渲染流程方向的优化手段</h2><p>知道了页面渲染的原理，那么我们也就得到了页面性能优化的依据。提炼六部曲中每一步的优化空间，针对六部曲中的每一步提出针对性的优化方案也就能达到我们最终的优化目的。</p>\n<h3 id=\"优化不可避免的阻塞：优化关键呈现路径\"><a href=\"#优化不可避免的阻塞：优化关键呈现路径\" class=\"headerlink\" title=\"优化不可避免的阻塞：优化关键呈现路径\"></a>优化不可避免的阻塞：优化关键呈现路径</h3><h4 id=\"关键呈现路径里的一些概念：\"><a href=\"#关键呈现路径里的一些概念：\" class=\"headerlink\" title=\"关键呈现路径里的一些概念：\"></a>关键呈现路径里的一些概念：</h4><ul>\n<li><strong>关键资源</strong>：可能阻止网页首次呈现的资源。</li>\n<li><strong>关键路径长度</strong>：即往返过程数量，或提取所有关键资源所需的总时间。</li>\n<li><strong>关键字节</strong>：实现网页首次呈现所需的总字节数，是所有关键资源的传输文件大小总和。 带有一个 HTML 网页的首个示例包含一项关键资源（HTML 文档），关键路径长度也与 1 个网络往返过程（假设文件较小）相等，而且总的关键字节数正好是 HTML 文档本身的传输大小。</li>\n</ul>\n<h4 id=\"优化关键呈现路径的指导原则：\"><a href=\"#优化关键呈现路径的指导原则：\" class=\"headerlink\" title=\"优化关键呈现路径的指导原则：\"></a>优化关键呈现路径的指导原则：</h4><ul>\n<li>尽量减少关键资源数量。</li>\n<li>尽量减少关键字节数。</li>\n<li>尽量缩短关键路径的长度。</li>\n</ul>\n<h4 id=\"优化关键呈现路径常规步骤：\"><a href=\"#优化关键呈现路径常规步骤：\" class=\"headerlink\" title=\"优化关键呈现路径常规步骤：\"></a>优化关键呈现路径常规步骤：</h4><ul>\n<li>分析和描述关键路径：资源数量、字节数、长度。</li>\n<li>尽量减少关键资源数量：删除相应资源、延迟下载、标记为异步资源等等。</li>\n<li>优化剩余关键资源的加载顺序：你需要尽早下载所有关键资源，以缩短关键路径长度。</li>\n<li>尽量减少关键字节数，以缩短下载时间（和往返次数）。</li>\n</ul>\n<h4 id=\"优化关键呈现路径的具体建议：\"><a href=\"#优化关键呈现路径的具体建议：\" class=\"headerlink\" title=\"优化关键呈现路径的具体建议：\"></a>优化关键呈现路径的具体建议：</h4><ul>\n<li><p>文件合并、压缩</p>\n</li>\n<li><p>推荐使用异步（async） JavaScript 资源，或使用延迟（defer）执行的 JavaScript</p>\n</li>\n<li><p>一般 &lt;script&gt;脚本的靠后书写</p>\n</li>\n<li><p>避免运行时间长的 JavaScript，耗时任务的拆分，chunk 化运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如：使用定时器将大任务拆分为小任务，使得浏览器得到空隙做其他事情。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>避免使用 CSS import</p>\n</li>\n<li>内联、内部化阻止呈现的 CSS<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一般不采用，百度、Google 这样的极度重视性能与体验的服务才可能这样做。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"针对复合图层化的优化\"><a href=\"#针对复合图层化的优化\" class=\"headerlink\" title=\"针对复合图层化的优化\"></a>针对复合图层化的优化</h3><p>因为浏览器有图层化这个机制，那么我们就搞懂它并充分利用吧。</p>\n<h4 id=\"复合图层化机制是怎样的呢？\"><a href=\"#复合图层化机制是怎样的呢？\" class=\"headerlink\" title=\"复合图层化机制是怎样的呢？\"></a>复合图层化机制是怎样的呢？</h4><p>如果某些属性的变更（transform、opacity）满足以下条件:</p>\n<ul>\n<li>不影响文档流</li>\n<li>不依赖文档流</li>\n<li>不会造成重绘</li>\n</ul>\n<p>那么，这些属性变更时，就需要一种机制：<br>能将属性变更的部分与页面其他部分隔离开来，对其他部分已经渲染完的进行缓存，变更的部分在单独的图层上进行，然后对缓存的部分与变更的图层进行合成。<br>关键字：<strong>缓存、隔离、图层合成</strong><br>使用 transform 与 opacity 进行属性变更是经典的复合图层优化方法，以下是其他会提升元素为复合图层的场景：<br>1.3d 或透视变换 CSS 属性，例如 translate3d, translateZ 等等（JS 一般通过这种方式，使元素获得复合图层）<br>2.&lt;video&gt; &lt;iframe&gt; &lt;canvas&gt; &lt;webgl&gt;等元素<br>3.混合插件（如flash）<br>4.元素自身的 opacity 和 transform 做 CSS 动画<br>5.拥有<a href=\"http://www.runoob.com/cssref/css3-pr-filter.html\" target=\"_blank\" rel=\"noopener\">CSS Filter</a>的元素<br>6.使用 will-change 属性<br>7.position:fixed<br>8.元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上方)</p>\n<h4 id=\"图层化的优势\"><a href=\"#图层化的优势\" class=\"headerlink\" title=\"图层化的优势\"></a>图层化的优势</h4><p>很容易看出来：充分利用缓存、隔离的思想，无需像回流、重绘那么大性能（GPU、CPU）开支，图层化能带来 <strong>动画性能的提升</strong>。</p>\n<p>图层化的潜在问题/弊端 —— 内存开销<br>因为图层化的存在，每个图层对需要在内存中存储该图层相关的信息，当图层太多会造成内存开销过大的情况。</p>\n<h4 id=\"因为开销，所以节制\"><a href=\"#因为开销，所以节制\" class=\"headerlink\" title=\"因为开销，所以节制\"></a>因为开销，所以节制</h4><p>内存开销在桌面端可能还能接受，但是在资源有限的移动端，复合图层过多便可能导致内存开支过大，页面反而变得停滞、卡顿，甚至浏览器假死，系统无法正常运行。</p>\n<h3 id=\"针对回流的优化\"><a href=\"#针对回流的优化\" class=\"headerlink\" title=\"针对回流的优化\"></a>针对回流的优化</h3><p>首先，我们需要知道什么情况下会触发浏览器的repaint/reflow：<br>查询哪些属性会触发Layout/Paing/Composite,可参考：<br><a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">https://csstriggers.com/</a></p>\n<h4 id=\"技术使用优先级：\"><a href=\"#技术使用优先级：\" class=\"headerlink\" title=\"技术使用优先级：\"></a>技术使用优先级：</h4><p>1.CSS3 &gt; JavaScript<br>2.属性变更优先考虑顺序（性能表现排序）</p>\n<ul>\n<li>transfrom, opacity</li>\n<li>background-color等</li>\n<li>position top、bottom、left、right</li>\n<li>width、height等</li>\n<li>margin、padding、border</li>\n</ul>\n<h4 id=\"What-forces-layout\"><a href=\"#What-forces-layout\" class=\"headerlink\" title=\"What forces layout\"></a>What forces layout</h4><p>能够引起重绘和回流的属性修改/查找：</p>\n<ul>\n<li>Element<br><strong>Box metrics</strong><br>elem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParent<br>elem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeight<br>elem.getClientRects(), elem.getBoundingClientRect()</li>\n</ul>\n<p><strong>Scroll stuff</strong><br>elem.scrollBy(), elem.scrollTo()<br>elem.scrollIntoView(), elem.scrollIntoViewIfNeeded()<br>elem.scrollWidth, elem.scrollHeight<br>elem.scrollLeft, elem.scrollTop also, setting them</p>\n<p><strong>Focus</strong><br>elem.focus() can trigger a double forced layout (source)</p>\n<p><strong>Also…</strong><br>elem.computedRole, elem.computedName<br>elem.innerText (source)</p>\n<ul>\n<li><p>getComputedStyle</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<p>详情查看：<a href=\"https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/yangfch3/fc4877b144c8964a9c20efd975de5aa9</a><br><strong>JavaScript 存在这样的机制：当连续有大量 DOM 样式的操作时，出于性能考虑，防止零碎变更导致频繁的回流、重绘，会尽可能地将这些操作先缓存起来，然后一次性地变更。这个机制我们难以察觉但是确实存在。<br>然而当我们进行某些 DOM 样式的读、写时，出于时效性的考虑，则会立即触发浏览器回流、重绘以返回正确、合理的值。</strong></p>\n<h3 id=\"减少渲染时的内存消耗\"><a href=\"#减少渲染时的内存消耗\" class=\"headerlink\" title=\"减少渲染时的内存消耗\"></a>减少渲染时的内存消耗</h3><p>1.避免浏览器的隐式合成。</p>\n<ul>\n<li>保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。</li>\n<li>将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。</li>\n</ul>\n<p>2.减小复合层的尺寸<br>看一下两张图片，有什么不同吗？<br><img src=\"https://raw.githubusercontent.com/shengyur/Images/master/img/parseHtml/MinComposite.png\"><br>这两张图片视觉上是一样的，但是它们的尺寸一个是39kb；另外一个是400b。不同之处在于，第二个纯色层是通过scale放大10倍做到的。<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"a\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"b\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#a</span>, <span class=\"selector-id\">#b</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\"> will-change: transform;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#a</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\"> width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\"> height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#b</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\"> width: 10px;</span></span><br><span class=\"line\"><span class=\"undefined\"> height: 10px;</span></span><br><span class=\"line\"><span class=\"undefined\"> transform: scale(10);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>对于图片，你要怎么做呢？你可以将图片的尺寸减少5%——10%，然后使用scale将它们放大；用户不会看到什么区别，但是你可以减少大量的存储空间。</p>\n<h3 id=\"减少渲染时的计算数量\"><a href=\"#减少渲染时的计算数量\" class=\"headerlink\" title=\"减少渲染时的计算数量\"></a>减少渲染时的计算数量</h3><p>1.用css动画而不是js动画<br>css动画有一个重要的特性，它是完全工作在GPU上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给GPU。<br>而如果使用js动画，浏览器必须计算每一帧的状态；<br>为了保证平滑的动画，我们必须在浏览器主线程计算新状态；<br>把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画；<br>当主线程的计算任务过多时，会造成动画的延迟、卡顿。</p>\n<p>所以尽可能地使用基于css的动画，不仅仅更快；也不会被大量的js计算所阻塞。</p>\n<h3 id=\"节流函数\"><a href=\"#节流函数\" class=\"headerlink\" title=\"节流函数\"></a>节流函数</h3><h3 id=\"惰性载入函数\"><a href=\"#惰性载入函数\" class=\"headerlink\" title=\"惰性载入函数\"></a>惰性载入函数</h3><h3 id=\"重任务分片多帧\"><a href=\"#重任务分片多帧\" class=\"headerlink\" title=\"重任务分片多帧\"></a><a href=\"https://zhuanlan.zhihu.com/p/25166666?refer=dreawer\" target=\"_blank\" rel=\"noopener\">重任务分片多帧</a></h3><p>知道原理之后，常用的有如下几点优化方法：</p>\n<p>1.避免在document上直接进行频繁的DOM操作，如果确实需要可以采用off-document的方式进行，具体的方法包括但不完全包括以下几种：<br>(1). 先将元素从document中删除，完成修改后再把元素放回原来的位置</p>\n<p>(2). 将元素的display设置为”none”，完成修改后再把display修改为原来的值</p>\n<p>(3). 如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document</p>\n<p>2.集中修改样式<br>(1). 尽可能少的修改元素style上的属性</p>\n<p>(2). 尽量通过修改className来修改样式</p>\n<p>(3). 通过cssText属性/className来设置样式值</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(<span class=\"string\">\"d1\"</span>).style.cssText = <span class=\"string\">\"color:red; font-size:13px;\"</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>3.缓存Layout属性值<br>对于Layout属性中非引用类型的值（数字型），如果需要多次访问则可以在一次访问时先存储到局部变量中，之后都使用局部变量，这样可以避免每次读取属性时造成浏览器的渲染。<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var width</span> = el.offsetWidth; <span class=\"attribute\">v</span><span class=\"attribute\">a</span><span class=\"attribute\">r</span> <span class=\"attribute\">s</span><span class=\"attribute\">c</span><span class=\"attribute\">r</span><span class=\"attribute\">o</span><span class=\"attribute\">l</span><span class=\"attribute\">l</span><span class=\"attribute\">L</span><span class=\"attribute\">e</span><span class=\"attribute\">f</span><span class=\"attribute\">t</span> = el.scrollLeft;</span><br></pre></td></tr></table></figure></p>\n<p>4.设置元素的position为absolute或fixed</p>\n<p>5.不要使用table布局。</p>\n<p>6.css动画中尽量只使用transform和opacity，这不会发生重排和重绘。<br>如上所说，transform和opacity保证了元素属性的变化不影响文档流、也不受文档流影响；并且不会造成repaint。<br>有些时候你可能想要改变其他的css属性，作为动画。例如：你可能想使用background属性改变背景：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">\"bg-change\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-class\">.bg-change</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">2s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.bg-change</span>:hover &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，在动画的每一步；浏览器都会进行一次重绘。我们可以使用一个复层在这个元素上面，并且仅仅变换opacity属性：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bg-change\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.bg-change</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">  background: red;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.bg-change</span><span class=\"selector-pseudo\">::before</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  content: '';</span></span><br><span class=\"line\"><span class=\"undefined\">  display: block;</span></span><br><span class=\"line\"><span class=\"undefined\">  width: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">  height: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">  background: blue;</span></span><br><span class=\"line\"><span class=\"undefined\">  opacity: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">  transition: opacity 20s;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.bg-change</span><span class=\"selector-pseudo\">:hover</span><span class=\"selector-pseudo\">::before</span> &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  opacity: 1;</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"回答几个问题-自测\"><a href=\"#回答几个问题-自测\" class=\"headerlink\" title=\"回答几个问题 自测\"></a>回答几个问题 自测</h2><h3 id=\"如何理解-getComputedStyle\"><a href=\"#如何理解-getComputedStyle\" class=\"headerlink\" title=\"如何理解 getComputedStyle?\"></a>如何理解 getComputedStyle?</h3><p>在尚未梳理知识体系前，大概会这样回答：</p>\n<p>普通版本： getComputedStyle会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过 window.getComputedStyle等价于 document.defaultView.getComputedStyle调用</p>\n<p>详细版本： window.getComputedStyle(elem,null).getPropertyValue(“height”)可能的值为 100px，而且，就算是css上写的是 inherit， getComputedStyle也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么 getComputedStyle获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。</p>\n<p>就这个API来说，上述的回答已经比较全面了。</p>\n<p>但是，其实它是可以继续延伸的。</p>\n<p>譬如现在会这样回答：</p>\n<p>getComputedStyle会获取当前元素所有最终使用的CSS属性值， window.和 document.defaultView.等价…</p>\n<p>getComputedStyle会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如 offsetXXX， scrollXXX， clientXXX， currentStyle等等</p>\n<h3 id=\"visibility-hidden和-display-none的区别\"><a href=\"#visibility-hidden和-display-none的区别\" class=\"headerlink\" title=\"visibility:hidden和 display:none的区别?\"></a>visibility:hidden和 display:none的区别?</h3><p>可以如下回答：</p>\n<p>普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置</p>\n<p>进一步， display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大</p>\n<p>再进一步，当一个页面某个元素经常需要切换 display时如何优化，一般会用复合层优化，或者要求低一点用 absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流， absolute文档流，复合图层的区别，</p>\n<p>再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）</p>\n<p>上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"如何减少浏览器repaint和reflow\">https://www.cnblogs.com/fullhouse/archive/2012/02/20/2360301.html</a></li>\n<li><a href=\"从输入URL到页面加载的过程？\">https://mp.weixin.qq.com/s/LIfvU8j0gBVIFF8AYYtfFg</a></li>\n<li><a href=\"浏览器内核、页面呈现原理及其优化\">https://www.cnblogs.com/ys-wuhan/p/6985624.html</a></li>\n<li><a href=\"从Chrome源码看浏览器如何构建DOM树\">https://zhuanlan.zhihu.com/p/24911872?refer=dreawer</a></li>\n<li><a href=\"一篇文章说清浏览器解析和CSS（GPU）动画优化\">https://segmentfault.com/a/1190000008015671#articleHeader9</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjnn81uw600007q0to3pmx7wt","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uwr000d7q0tivdr4sr7"},{"post_id":"cjnn81uwn000b7q0tsext06lt","category_id":"cjnn81uwm00087q0t55s5op88","_id":"cjnn81uwy000i7q0ttvsp18aj"},{"post_id":"cjnn81uwc00027q0t8ksgygrn","category_id":"cjnn81uwm00087q0t55s5op88","_id":"cjnn81ux1000m7q0twna22x39"},{"post_id":"cjnn81uwi00057q0t9e6h4wm0","category_id":"cjnn81uws000e7q0taaw4b611","_id":"cjnn81ux3000r7q0tb04cy121"},{"post_id":"cjnn81uwj00067q0tv9y7vex9","category_id":"cjnn81uwm00087q0t55s5op88","_id":"cjnn81ux8000w7q0t2zqjh0v8"},{"post_id":"cjnn81uwl00077q0th23wx5t1","category_id":"cjnn81uwm00087q0t55s5op88","_id":"cjnn81uxa00117q0tonki31dc"},{"post_id":"cjnn81uwq000c7q0tmou66vc5","category_id":"cjnn81ux7000v7q0t66ezgoos","_id":"cjnn81uxf00187q0ttwe66y93"},{"post_id":"cjnn81uws000g7q0tped9yngl","category_id":"cjnn81uxa00127q0t6wr7v459","_id":"cjnn81uxo001f7q0tubk0z3pt"},{"post_id":"cjnn81uxf00197q0tgtfrnf6l","category_id":"cjnn81uwm00087q0t55s5op88","_id":"cjnn81uxp001j7q0to43n0hob"},{"post_id":"cjnn81uxm001d7q0tocrtihh0","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uxr001m7q0t618dvkab"},{"post_id":"cjnn81uwv000h7q0tmrsfhjtt","category_id":"cjnn81uxl001a7q0tz5oix0uq","_id":"cjnn81uxu001q7q0teoq7sb70"},{"post_id":"cjnn81uxn001e7q0t9l9tiq07","category_id":"cjnn81uxl001a7q0tz5oix0uq","_id":"cjnn81uxw001t7q0t3eb7w12p"},{"post_id":"cjnn81uxp001i7q0t59m5oc0s","category_id":"cjnn81uxo001g7q0t7uls9qrp","_id":"cjnn81uxy001y7q0trm2n2lyn"},{"post_id":"cjnn81ux0000l7q0toe4u70xu","category_id":"cjnn81uxo001g7q0t7uls9qrp","_id":"cjnn81uxz00217q0t3o8ko6tf"},{"post_id":"cjnn81uxq001l7q0tpchyngqd","category_id":"cjnn81uxo001g7q0t7uls9qrp","_id":"cjnn81uy200247q0tdt3l3ljo"},{"post_id":"cjnn81uxt001p7q0ta9y7tqeb","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uy300277q0tvty4bpex"},{"post_id":"cjnn81ux1000o7q0t4xvsigns","category_id":"cjnn81uxl001a7q0tz5oix0uq","_id":"cjnn81uy5002a7q0t2yf1ji6m"},{"post_id":"cjnn81uxv001s7q0ts8ukj2sq","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uy6002d7q0ta8uc89i7"},{"post_id":"cjnn81uxx001x7q0te3pwx02a","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uy8002h7q0tcol7z0n6"},{"post_id":"cjnn81ux4000t7q0t0m9wifwl","category_id":"cjnn81uxl001a7q0tz5oix0uq","_id":"cjnn81uyb002l7q0tyubel5n8"},{"post_id":"cjnn81uy000237q0tiezgml2l","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uye002o7q0tnitz4mm9"},{"post_id":"cjnn81ux6000u7q0tjiv13yab","category_id":"cjnn81uxl001a7q0tz5oix0uq","_id":"cjnn81uyg002r7q0t0lmpp70r"},{"post_id":"cjnn81uy200267q0te5m3b4yd","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uyi002v7q0tkh5ky3q9"},{"post_id":"cjnn81uy400297q0t2xxxx3sk","category_id":"cjnn81uxo001g7q0t7uls9qrp","_id":"cjnn81uyk002z7q0tyyqmhv8k"},{"post_id":"cjnn81ux8000x7q0tajp0z6jz","category_id":"cjnn81uxl001a7q0tz5oix0uq","_id":"cjnn81uym00337q0t75ie38he"},{"post_id":"cjnn81uy5002c7q0tiuu2m9kl","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uyq00377q0tc23ch3ll"},{"post_id":"cjnn81uy7002g7q0tefzao7ta","category_id":"cjnn81uxo001g7q0t7uls9qrp","_id":"cjnn81uys003b7q0tla0xs2qk"},{"post_id":"cjnn81ux900107q0t8guvkqhq","category_id":"cjnn81uxl001a7q0tz5oix0uq","_id":"cjnn81uyu003e7q0t1sl6kda4"},{"post_id":"cjnn81uya002k7q0ttw101vmc","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uyz003h7q0thngx5w0b"},{"post_id":"cjnn81uyc002n7q0txqtqj42p","category_id":"cjnn81uxo001g7q0t7uls9qrp","_id":"cjnn81uz0003k7q0tr6hihbc2"},{"post_id":"cjnn81uxb00147q0tn30rnylf","category_id":"cjnn81uxl001a7q0tz5oix0uq","_id":"cjnn81uz1003n7q0tag6udfo8"},{"post_id":"cjnn81uye002q7q0th6ipek6m","category_id":"cjnn81uwe00037q0tr5pvkwp7","_id":"cjnn81uz2003p7q0tkug3ndg2"},{"post_id":"cjnn81uyh002u7q0t1vc1t0tx","category_id":"cjnn81uws000e7q0taaw4b611","_id":"cjnn81uz2003r7q0t5xa5w5ug"},{"post_id":"cjnn81uxe00177q0t8e33trnr","category_id":"cjnn81uxo001g7q0t7uls9qrp","_id":"cjnn81uz2003t7q0tk6qcb6i5"},{"post_id":"cjnn81uyj002y7q0t3v0zq7u2","category_id":"cjnn81uwm00087q0t55s5op88","_id":"cjnn81uz3003v7q0tjcawqweq"},{"post_id":"cjnn81uxy00207q0tme8ei5an","category_id":"cjnn81uyl00317q0tt9465rfy","_id":"cjnn81uz5003x7q0tkblbpf7f"},{"post_id":"cjnn81uyn00367q0tk8p2ms2i","category_id":"cjnn81uxo001g7q0t7uls9qrp","_id":"cjnn81uz5003z7q0tsf324e9r"},{"post_id":"cjnn81uyr003a7q0tbsjlr0v0","category_id":"cjnn81uxo001g7q0t7uls9qrp","_id":"cjnn81uz600417q0ta3ft47ut"},{"post_id":"cjnn81uyt003d7q0tkjql0j9q","category_id":"cjnn81uws000e7q0taaw4b611","_id":"cjnn81uz700437q0tt9g4fw8q"},{"post_id":"cjnn81uyl00327q0t27b4ouw8","category_id":"cjnn81uyq00397q0tg3xsy3yg","_id":"cjnn81uz700447q0tt99p5q3u"},{"post_id":"cjnn81uyy003g7q0tlfg9flin","category_id":"cjnn81uz1003l7q0t8vzcbtvm","_id":"cjnn81uz700477q0t27bkg589"},{"post_id":"cjnn81wft00537q0t8l3ftih4","category_id":"cjnn81uwm00087q0t55s5op88","_id":"cjnn81wgp00587q0t5eitk8o6"},{"post_id":"cjnn81wg700557q0t2xbl4gzx","category_id":"cjnn81uwm00087q0t55s5op88","_id":"cjnn81wgw005a7q0te8nifyby"},{"post_id":"cjnn81wg300547q0t2ko92q7v","category_id":"cjnn81wgo00567q0tdpl86uln","_id":"cjnn81wgz005c7q0tgkem410m"},{"post_id":"cjnn81wh4005d7q0t9rui7r3z","category_id":"cjnn81uwm00087q0t55s5op88","_id":"cjnn81wh6005e7q0tugbwlddz"}],"PostTag":[{"post_id":"cjnn81uw600007q0to3pmx7wt","tag_id":"cjnn81uwh00047q0tz7v57omk","_id":"cjnn81uwn000a7q0tmm6wdhcd"},{"post_id":"cjnn81uwc00027q0t8ksgygrn","tag_id":"cjnn81uwm00097q0tf8voohvz","_id":"cjnn81ux1000n7q0t1ccndinz"},{"post_id":"cjnn81uwc00027q0t8ksgygrn","tag_id":"cjnn81uws000f7q0tdfrbl27p","_id":"cjnn81ux2000p7q0txi00j55m"},{"post_id":"cjnn81uwi00057q0t9e6h4wm0","tag_id":"cjnn81uwz000k7q0t3bt2z9m5","_id":"cjnn81ux9000z7q0tvn28js20"},{"post_id":"cjnn81uwi00057q0t9e6h4wm0","tag_id":"cjnn81ux3000s7q0ttij3f54p","_id":"cjnn81uxb00137q0tehq9k7gx"},{"post_id":"cjnn81uwj00067q0tv9y7vex9","tag_id":"cjnn81uwm00097q0tf8voohvz","_id":"cjnn81uxd00167q0thtgf3ne6"},{"post_id":"cjnn81uwl00077q0th23wx5t1","tag_id":"cjnn81uwm00097q0tf8voohvz","_id":"cjnn81uxm001c7q0t3iub3dlg"},{"post_id":"cjnn81uwn000b7q0tsext06lt","tag_id":"cjnn81uxl001b7q0tjuyzjpuj","_id":"cjnn81uxp001k7q0tkycc8fju"},{"post_id":"cjnn81uwq000c7q0tmou66vc5","tag_id":"cjnn81uxo001h7q0t945q9qfd","_id":"cjnn81uxu001r7q0twd2iiv9l"},{"post_id":"cjnn81uxq001l7q0tpchyngqd","tag_id":"cjnn81uxl001b7q0tjuyzjpuj","_id":"cjnn81uxw001u7q0trfavggh9"},{"post_id":"cjnn81uws000g7q0tped9yngl","tag_id":"cjnn81uxs001o7q0tt8tzedd8","_id":"cjnn81uxy001z7q0tnh21pcj4"},{"post_id":"cjnn81uwv000h7q0tmrsfhjtt","tag_id":"cjnn81uxx001w7q0tb4dao8qp","_id":"cjnn81uy6002e7q0tj4wldmec"},{"post_id":"cjnn81uwv000h7q0tmrsfhjtt","tag_id":"cjnn81uy200257q0th6p8yz3b","_id":"cjnn81uy9002i7q0trycjbms3"},{"post_id":"cjnn81ux0000l7q0toe4u70xu","tag_id":"cjnn81uy5002b7q0ts2c0rn79","_id":"cjnn81uyg002s7q0tgoc1l99o"},{"post_id":"cjnn81ux0000l7q0toe4u70xu","tag_id":"cjnn81uxx001w7q0tb4dao8qp","_id":"cjnn81uyj002w7q0tqms9k938"},{"post_id":"cjnn81ux1000o7q0t4xvsigns","tag_id":"cjnn81uxx001w7q0tb4dao8qp","_id":"cjnn81uyk00307q0t3qyi9lff"},{"post_id":"cjnn81uyh002u7q0t1vc1t0tx","tag_id":"cjnn81uwz000k7q0t3bt2z9m5","_id":"cjnn81uym00347q0tbjhpp1p4"},{"post_id":"cjnn81ux4000t7q0t0m9wifwl","tag_id":"cjnn81uxx001w7q0tb4dao8qp","_id":"cjnn81uyq00387q0t5x3oy0j7"},{"post_id":"cjnn81ux6000u7q0tjiv13yab","tag_id":"cjnn81uxx001w7q0tb4dao8qp","_id":"cjnn81uyv003f7q0talhsbpnn"},{"post_id":"cjnn81uyt003d7q0tkjql0j9q","tag_id":"cjnn81uwz000k7q0t3bt2z9m5","_id":"cjnn81uyz003j7q0tq72xhwfm"},{"post_id":"cjnn81ux8000x7q0tajp0z6jz","tag_id":"cjnn81uxx001w7q0tb4dao8qp","_id":"cjnn81uz1003m7q0trdef3v9n"},{"post_id":"cjnn81ux900107q0t8guvkqhq","tag_id":"cjnn81uxx001w7q0tb4dao8qp","_id":"cjnn81uz2003q7q0tnjtwf0eq"},{"post_id":"cjnn81uxb00147q0tn30rnylf","tag_id":"cjnn81uxx001w7q0tb4dao8qp","_id":"cjnn81uz3003u7q0ti30923do"},{"post_id":"cjnn81uxe00177q0t8e33trnr","tag_id":"cjnn81uxl001b7q0tjuyzjpuj","_id":"cjnn81uz5003y7q0t1luiz0c6"},{"post_id":"cjnn81uxf00197q0tgtfrnf6l","tag_id":"cjnn81uz3003w7q0tr5g4j060","_id":"cjnn81uz600427q0ta1v180za"},{"post_id":"cjnn81uxm001d7q0tocrtihh0","tag_id":"cjnn81uz600407q0tcjkgm248","_id":"cjnn81uz700467q0tbqjunuv7"},{"post_id":"cjnn81uxn001e7q0t9l9tiq07","tag_id":"cjnn81uz700457q0t9gchtafv","_id":"cjnn81uz700497q0tndg50z35"},{"post_id":"cjnn81uxp001i7q0t59m5oc0s","tag_id":"cjnn81uz700487q0tw1v4iuvy","_id":"cjnn81uz8004b7q0teb8y1tpl"},{"post_id":"cjnn81uxt001p7q0ta9y7tqeb","tag_id":"cjnn81uz8004a7q0t0q4sfcdy","_id":"cjnn81uz8004d7q0t8b7kdofl"},{"post_id":"cjnn81uxv001s7q0ts8ukj2sq","tag_id":"cjnn81uz8004a7q0t0q4sfcdy","_id":"cjnn81uz9004f7q0tk0o6ei7z"},{"post_id":"cjnn81uxx001x7q0te3pwx02a","tag_id":"cjnn81uz8004e7q0t2j7ytv5d","_id":"cjnn81uz9004h7q0t42drqwhj"},{"post_id":"cjnn81uxy00207q0tme8ei5an","tag_id":"cjnn81uz9004g7q0thy52icju","_id":"cjnn81uz9004j7q0teuki1qyw"},{"post_id":"cjnn81uy000237q0tiezgml2l","tag_id":"cjnn81uz9004i7q0twcqzrhqz","_id":"cjnn81uza004m7q0t7mjggbi8"},{"post_id":"cjnn81uy000237q0tiezgml2l","tag_id":"cjnn81uza004k7q0tr0kj0vym","_id":"cjnn81uza004n7q0t2vr1uvay"},{"post_id":"cjnn81uy200267q0te5m3b4yd","tag_id":"cjnn81uza004l7q0tscxg7t1l","_id":"cjnn81uza004p7q0tp20vvivb"},{"post_id":"cjnn81uy400297q0t2xxxx3sk","tag_id":"cjnn81uza004o7q0t788kfjpa","_id":"cjnn81uzb004r7q0tycu8tdhp"},{"post_id":"cjnn81uy7002g7q0tefzao7ta","tag_id":"cjnn81uz8004a7q0t0q4sfcdy","_id":"cjnn81uzc004t7q0tvk0chmkq"},{"post_id":"cjnn81uya002k7q0ttw101vmc","tag_id":"cjnn81uza004k7q0tr0kj0vym","_id":"cjnn81uze004v7q0t8pdusyph"},{"post_id":"cjnn81uye002q7q0th6ipek6m","tag_id":"cjnn81uz8004e7q0t2j7ytv5d","_id":"cjnn81uzf004x7q0ty974u9sk"},{"post_id":"cjnn81uyj002y7q0t3v0zq7u2","tag_id":"cjnn81uy5002b7q0ts2c0rn79","_id":"cjnn81uzf004z7q0tarxsvjcq"},{"post_id":"cjnn81uyj002y7q0t3v0zq7u2","tag_id":"cjnn81uxl001b7q0tjuyzjpuj","_id":"cjnn81uzg00507q0tprroi23u"},{"post_id":"cjnn81uyj002y7q0t3v0zq7u2","tag_id":"cjnn81uzf004w7q0tvrvcsmvw","_id":"cjnn81uzg00517q0tdzgi5la5"},{"post_id":"cjnn81uyj002y7q0t3v0zq7u2","tag_id":"cjnn81uzf004y7q0tybysqeoc","_id":"cjnn81uzg00527q0t0s8ijauf"},{"post_id":"cjnn81wg700557q0t2xbl4gzx","tag_id":"cjnn81uy5002b7q0ts2c0rn79","_id":"cjnn81wgt00597q0tzw048hvp"},{"post_id":"cjnn81wg300547q0t2ko92q7v","tag_id":"cjnn81wgp00577q0tg5s9zefx","_id":"cjnn81wgx005b7q0tupm966bm"}],"Tag":[{"name":"Sass","_id":"cjnn81uwh00047q0tz7v57omk"},{"name":"ES6","_id":"cjnn81uwm00097q0tf8voohvz"},{"name":"ES5","_id":"cjnn81uws000f7q0tdfrbl27p"},{"name":"性能","_id":"cjnn81uwz000k7q0t3bt2z9m5"},{"name":"CDN","_id":"cjnn81ux3000s7q0ttij3f54p"},{"name":"HTTP","_id":"cjnn81uxl001b7q0tjuyzjpuj"},{"name":"Jest","_id":"cjnn81uxo001h7q0t945q9qfd"},{"name":"Nodejs","_id":"cjnn81uxs001o7q0tt8tzedd8"},{"name":"React","_id":"cjnn81uxx001w7q0tb4dao8qp"},{"name":"diff算法","_id":"cjnn81uy200257q0th6p8yz3b"},{"name":"Javascript","_id":"cjnn81uy5002b7q0ts2c0rn79"},{"name":"XMLHttpRequest","_id":"cjnn81uz3003w7q0tr5g4j060"},{"name":"YAML","_id":"cjnn81uz600407q0tcjkgm248"},{"name":"axios","_id":"cjnn81uz700457q0t9gchtafv"},{"name":"HTML","_id":"cjnn81uz700487q0tw1v4iuvy"},{"name":"git","_id":"cjnn81uz8004a7q0t0q4sfcdy"},{"name":"Hexo","_id":"cjnn81uz8004e7q0t2j7ytv5d"},{"name":"jQuery源码","_id":"cjnn81uz9004g7q0thy52icju"},{"name":"Less","_id":"cjnn81uz9004i7q0twcqzrhqz"},{"name":"vscode","_id":"cjnn81uza004k7q0tr0kj0vym"},{"name":"mock","_id":"cjnn81uza004l7q0tscxg7t1l"},{"name":"node","_id":"cjnn81uza004o7q0t788kfjpa"},{"name":"安全","_id":"cjnn81uzf004w7q0tvrvcsmvw"},{"name":"Node","_id":"cjnn81uzf004y7q0tybysqeoc"},{"name":"函数式编程","_id":"cjnn81wgp00577q0tg5s9zefx"}]}}