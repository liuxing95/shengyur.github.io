<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Element-React之 排坑日常</title>
      <link href="/2018/07/14/Element-react%E6%8E%92%E5%9D%91%E6%97%A5%E5%B8%B8/"/>
      <url>/2018/07/14/Element-react%E6%8E%92%E5%9D%91%E6%97%A5%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><ol><li>TimePicker</li></ol><p>（1）TimePicker的默认时间要设置成标准时间格式，其value值也是标准时间格式的。可以使用new Date()来设置。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此组件是用来选择时分秒的，所以年月日可以随意填写</span></span><br><span class="line">let defaultTimePicker = new Date(<span class="number">2018</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>（2）可能需要将标准时间格式转换为接口需要的格式，比如’YYYY-MM-DD HH:mm:ss’。  </p><a id="more"></a><h3 id="组件的修改与扩充"><a href="#组件的修改与扩充" class="headerlink" title="组件的修改与扩充"></a>组件的修改与扩充</h3><p>有的组件并不能满足业务要求，所以会在其内容上增加一下修改以及扩充。</p><hr><p><strong>1. Upload增加支持“only-picture”(只展示图片)的listType。</strong></p><pre><code>思路：增加this.props.listType名为&quot;only-picture&quot;的类型。修改点：（1）在Upload/Upload.js中，Upload.propTypes.listType增加一个&quot;only-picture&quot;的参数。（2）在Upload/UploadList.js中，在render方法中，</code></pre><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;li</span><br><span class="line">    className=&#123;this.classNames(&#123;</span><br><span class="line">    <span class="symbol">'ishow</span>-upload-list__item': <span class="literal">true</span>,</span><br><span class="line">    [`is-$&#123;file.status&#125;`]: <span class="literal">true</span>,</span><br><span class="line">    <span class="symbol">'ishow</span>-upload-only-picture': listType !== <span class="symbol">'only</span>-picture'?<span class="literal">false</span>:<span class="literal">true</span></span><br><span class="line">    &#125;)&#125;</span><br><span class="line">    key=&#123;file.uid&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &#123;[<span class="symbol">'picture</span>-card', <span class="symbol">'picture'</span>,<span class="symbol">'only</span>-picture'].includes(listType) &amp;&amp;</span><br><span class="line">    isFinished(file.status) &amp;&amp;</span><br><span class="line">    &lt;img</span><br><span class="line">        className=<span class="string">"ishow-upload-list__item-thumbnail"</span></span><br><span class="line">        src=&#123;file.url&#125;</span><br><span class="line">        alt=<span class="string">""</span></span><br><span class="line">    /&gt;&#125;</span><br><span class="line"></span><br><span class="line">    &#123;listType !== <span class="symbol">'only</span>-picture'?</span><br><span class="line">    &lt;a</span><br><span class="line">        className=<span class="string">"ishow-upload-list__item-name"</span></span><br><span class="line">        onClick=&#123;<span class="literal">()</span> =&gt; onPreview(file)&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;i className=<span class="string">"ishow-icon-document"</span> /&gt;&#123;file.name&#125;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    :<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;label</span><br><span class="line">        className=<span class="string">"ishow-upload-list__item-status-label"</span></span><br><span class="line">    &gt;</span><br><span class="line">        &lt;i</span><br><span class="line">        className=&#123;this.classNames(&#123;</span><br><span class="line">            <span class="symbol">'ishow</span>-icon-upload-success': <span class="literal">true</span>,</span><br><span class="line">            <span class="symbol">'ishow</span>-icon-circle-check': listType === <span class="symbol">'text'</span>,</span><br><span class="line">            <span class="symbol">'ishow</span>-icon-check': [<span class="symbol">'picture</span>-card', <span class="symbol">'picture'</span>,<span class="symbol">'only</span>-picture'].includes(</span><br><span class="line">                listType</span><br><span class="line">            )</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">    &lt;i className=<span class="string">"ishow-icon-close"</span> onClick=&#123;<span class="literal">()</span> =&gt; onRemove(file)&#125; /&gt;</span><br><span class="line">    &lt;<span class="type">View</span></span><br><span class="line">        className=<span class="string">"ishow-upload-list__item-actions"</span></span><br><span class="line">        show=&#123;listType === <span class="symbol">'picture</span>-card' &amp;&amp; isFinished(file.status)&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;span&gt;</span><br><span class="line">            &lt;span</span><br><span class="line">                onClick=&#123;<span class="literal">()</span> =&gt; onPreview(file)&#125;</span><br><span class="line">                className=<span class="string">"ishow-upload-list__item-preview"</span></span><br><span class="line">            &gt;</span><br><span class="line">                &lt;i className=<span class="string">"ishow-icon-view"</span> /&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">            &lt;span</span><br><span class="line">                className=<span class="string">"ishow-upload-list__item-delete"</span></span><br><span class="line">                onClick=&#123;<span class="literal">()</span> =&gt; onRemove(file)&#125;</span><br><span class="line">            &gt;</span><br><span class="line">                &lt;i className=<span class="string">"ishow-icon-delete2"</span> /&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">    &lt;/<span class="type">View</span>&gt;</span><br><span class="line">    &#123;file.status === <span class="symbol">'uploading'</span> &amp;&amp;</span><br><span class="line">    &lt;<span class="type">Progress</span></span><br><span class="line">        strokeWidth=&#123;listType === <span class="symbol">'picture</span>-card' ? <span class="number">6</span> : <span class="number">2</span>&#125;</span><br><span class="line">        <span class="keyword">type</span>=&#123;listType === <span class="symbol">'picture</span>-card' ? <span class="symbol">'circle'</span> : <span class="symbol">'line'</span>&#125;</span><br><span class="line">        percentage=&#123;parseInt(file.percentage, <span class="number">10</span>)&#125;</span><br><span class="line">        status=&#123;</span><br><span class="line">        isFinished(file.status) &amp;&amp; file.showProgress ? <span class="symbol">'success'</span> : <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    /&gt;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><pre><code>（3）在Common/css/Upload.css中增加：</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ishow-upload-only-picture</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">125px</span>;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">margin-right</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ishow-upload-only-picture</span> <span class="selector-class">.ishow-upload-list__item-thumbnail</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. TimePicker的组件增加支持时分的选择（原本只支持时分秒的选择）。</strong></p><pre><code>思路：通过format的设置，改变isShowSeconds的值。修改点：（1）在DatePicker/TimePicker.js中，converSelectRange方法修改如下：        const format = props.format==&quot;HH:mm&quot;?props.format: DEFAULT_FORMATS.timerange;（2）在DatePicker/panel/TimePanel.js中，render方法修改如下：        const seconds = isShowSeconds?currentDate.getSeconds():null;（3）在DatePicker/basic/TimeSpinner.js，constructor方法修改如下：        //如果isShowSeconds为false，seconds设置为null        this.state.seconds = props.isShowSeconds?this.state.seconds:null;</code></pre><hr><p><strong>3. Checkbox的文本说明，增加title。</strong></p><pre><code>思路：增加this.props.showTitle的属性，如果showTitle为true，则展示title。修改点：    （1）在Checkbox/CheckBox.js中，render方法中修改如下：        let title = this.props.showTitle?(this.props.children || this.state.label):&apos;&apos;;        &lt;span className=&quot;ishow-checkbox__label&quot; title={title}&gt;            {this.props.children || this.state.label}        &lt;/span&gt;</code></pre><hr><p><strong>4. Table的展开行可以自定义展开title与内容。</strong></p><pre><code>思路：在column中增加expandText和expandTitle两个值。修改点：    (1)在Table/TableBody.js中，renderCell方法中修改如下：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; type, selectable,expandText,expandTitle &#125; = column;</span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">'expand'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div</span><br><span class="line">            className=&#123;<span class="keyword">this</span>.classNames(<span class="string">'ishow-table__expand-icon '</span>, &#123;</span><br><span class="line">                <span class="string">'ishow-table__expand-icon--expanded'</span>: <span class="keyword">this</span>.context.store.isRowExpanding(row, rowKey),</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">            onClick=&#123;<span class="keyword">this</span>.handleExpandClick.bind(<span class="keyword">this</span>, row, rowKey)&#125;</span><br><span class="line">        &gt;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            expandText?</span><br><span class="line">                &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;expandTitle&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">className</span>=<span class="string">"ishow-icon ishow-icon-arrow-right"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            :<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>收缩<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        &#125;               </span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><hr><p><strong>5. Table中正常使用Select</strong></p><pre><code>思路：在Select中增加selectUnderTable={true}，     将.ishow-select-dropdown设置为position:fixed，再计算其正确的top值。修改点：（1）在Select/Select.js中，    A.增加全局样式：</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ishow-select-dropdown</span><span class="selector-class">.ishow-select-undertable</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>B.在onEnter() 方法的new Popper中增加一个option：</code></pre><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectUnderTable: this<span class="selector-class">.props</span><span class="selector-class">.selectUnderTable</span></span><br></pre></td></tr></table></figure><pre><code>C.在渲染.ishow-select-dropdown时，根据标识增加一个className：</code></pre><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=<span class="string">"popper"</span> className=&#123;<span class="keyword">this</span>.classNames(<span class="string">'ishow-select-dropdown'</span>, &#123;</span><br><span class="line">    <span class="string">'is-multiple'</span>: multiple</span><br><span class="line">&#125;,<span class="keyword">this</span>.props.selectUnderTable?<span class="string">'ishow-select-undertable'</span>:<span class="string">''</span>)&#125; style=&#123;&#123;</span><br><span class="line">  minWidth: inputWidth,</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure><pre><code>（2）在Common/popper.js中，    A.Popper.prototype.update方法中，增加一行传值：</code></pre><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span>.selectUnderTable = <span class="keyword">this</span>._options.selectUnderTable;</span><br></pre></td></tr></table></figure><pre><code>B.Popper.prototype.modifiers.applyStyle方法中，根据窗口滚动条高度计算top值：</code></pre><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data.selectUnderTable)&#123;//表格内部的Select框    </span><br><span class="line">    styles.<span class="built_in">top</span> = <span class="built_in">top</span>-this.getScrollTop();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    styles.<span class="built_in">top</span> = <span class="built_in">top</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>C.增加一个获取窗口滚动条高度的方法：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Popper.prototype.getScrollTop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.documentElement &amp;&amp; <span class="built_in">document</span>.documentElement.scrollTop) &#123;</span><br><span class="line">    scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.body) &#123;</span><br><span class="line">    scrollTop = <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scrollTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>6.Table中的数据不展示title</strong></p><pre><code>思路：在column中，增加一个字段（notShowTitle: true）区分是否显示title修改点：</code></pre><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）在Table/TableBody.js，renderCell方法中：</span><br><span class="line"></span><br><span class="line">     renderCell(<span class="built_in">row</span>, <span class="built_in">column</span>, <span class="built_in">index</span>, rowKey)&#123;</span><br><span class="line">        const &#123; <span class="built_in">type</span>, selectable,expandText,notShowTitle &#125; = <span class="built_in">column</span>;//引入notShowTitle</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）在Table/TableBody.js，render方法中：</span><br><span class="line">    &lt;div className=<span class="string">"cell"</span></span><br><span class="line">        title=&#123;column.notShowTitle?<span class="string">""</span><span class="symbol">:</span> this.renderTitle(this.renderCell(<span class="built_in">row</span>, <span class="built_in">column</span>, rowIndex, rowKey))&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;this.renderCell(<span class="built_in">row</span>, <span class="built_in">column</span>, rowIndex, rowKey)&#125;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>7.Pagination靠右展示</strong></p><pre><code>思路：当增加right={true}时，设置text-align:right样式修改点：（1）在Pagination/Pagination.js中，在render方法中：</code></pre><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const className = <span class="keyword">this</span>.classNames(&#123;</span><br><span class="line">    <span class="string">'ishow-pagination'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'ishow-pagination__rightwrapper'</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'ishow-pagination--small'</span>: <span class="keyword">this</span>.props.small,</span><br><span class="line">    <span class="string">'ishow-pagination--right'</span>: <span class="keyword">this</span>.props.right</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>（2）在Common/css/Pagination.css中，增加：</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ishow-pagination--right</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>8.Table下方，如果使用了Pagination组件，当切换分页大小时，table表格会出现横向滚动条，为解决这一问题，增加一个选项：</strong></p><pre><code>思路：当增加overflowXHidden={true}时，设置overflow-x: hidden样式修改点：</code></pre><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）在<span class="keyword">Table</span>/<span class="keyword">Table</span>.js中，在render方法中修改：</span><br><span class="line"></span><br><span class="line">    className=&#123;props.overflowXHidden?<span class="string">"ishow-table__body-wrapper ishow-table__overflow-x-hidden"</span>:<span class="string">"ishow-table__body-wrapper"</span>&#125;</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）在Common/css/<span class="keyword">Table</span>.css中，增加：</span><br><span class="line"></span><br><span class="line">    .ishow-table__overflow-x-hidden&#123;</span><br><span class="line">        overflow-x: hidden;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>9.Table中，currentRowKey字段的优化</strong></p><pre><code>问题：在文档中，currentRowKey表示：当前选中行的 key，传入数组时可以控制多选。    但在实际运用中，我发现使用数组时，会有warning提示currentRowKey的类型不合法。修改点：在Table/TableStore.js中，propTypes对象修改：</code></pre><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentRowKey: PropTypes.oneOfType([PropTypes<span class="selector-class">.string</span>, PropTypes<span class="selector-class">.number</span>,PropTypes.arrayOf(PropTypes.oneOfType([PropTypes<span class="selector-class">.string</span>, PropTypes.number]))])</span><br></pre></td></tr></table></figure><hr><p>原文：</p><ul><li><a href="https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/%E3%80%90React%E3%80%91element-react%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.md" target="_blank" rel="noopener">王教授的积累</a></li></ul>]]></content>
      
      <categories>
          
          <category> 库/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Element-React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React基础之 使用排坑指南</title>
      <link href="/2018/07/13/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20%E6%8E%92%E5%9D%91%E6%97%A5%E5%B8%B8/"/>
      <url>/2018/07/13/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20%E6%8E%92%E5%9D%91%E6%97%A5%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h3 id="state-状态-更新可能是异步的"><a href="#state-状态-更新可能是异步的" class="headerlink" title="state(状态) 更新可能是异步的"></a>state(状态) 更新可能是异步的</h3><p>React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。</p><p><strong>因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。</strong></p><p>例如, 以下代码可能导致 counter(计数器)更新失败：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>要弥补这个问题，需要使用另一种 setState() 的形式，<strong>它接受一个函数,而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">//prevState:更新之前的状态state值</span></span><br><span class="line">  <span class="comment">//props:更新之前的props</span></span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p><p>我们在上面使用了一个箭头函数，但是也可以使用一个常规的函数：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span><span class="params">(prevState, props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Props-是只读的-声明组件的函数必须是纯函数"><a href="#Props-是只读的-声明组件的函数必须是纯函数" class="headerlink" title="Props 是只读的,声明组件的函数必须是纯函数"></a>Props 是只读的,声明组件的函数必须是纯函数</h3><p>无论你用函数或类的方法来声明组件, 它都无法修改其自身 props. 思考下列 sum (求和)函数:<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">sum</span>(a, b) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">a</span> + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种函数称为 <strong>“纯函数”</strong> ，因为它们不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。<br>反之， 以下是非纯函数， 因为它改变了自身的输入值：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span><span class="params">(account, amount)</span> </span>&#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有 React 组件都必须是纯函数，并禁止修改其自身 props 。</p><h3 id="单向数据流-数据向下流动）"><a href="#单向数据流-数据向下流动）" class="headerlink" title="单向数据流(数据向下流动）"></a>单向数据流(数据向下流动）</h3><p>state(状态)经常被称为 本地状态 或 封装状态，是因为它不能 被拥有并设置它的组件以外的任何组件 访问。<br>一个组件可以选择将state向下传递，作为其子组件的props属性：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;h2&gt;</span>it is &#123;this.<span class="keyword">state</span>.date.<span class="keyword">to</span>LocalTimeString()&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure></p><p>同样适用于用户定义组件：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Formatte <span class="keyword">date</span>=&#123;<span class="keyword">this</span>.state.<span class="keyword">date</span>&#125;&gt;</span><br></pre></td></tr></table></figure></p><p>Formatte组件通过props属性接受了date的值，但它仍任然不能获知该值是来自于哪。</p><p>这通常称为”从上而下”，或者单项数据流。任何state始终由某个特定组件所有，并且从该state导出的任何数据 或 UI只能影响树种 “下方”的组件。</p><h3 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h3><p>React支持一个可以附加到任何组件的特殊属性ref。ref属性可以是一个字符串或一个回调函数。<br>当ref属性是一个回调函数时，函数接收底层DOM元素或类实例（取决于元素的类型）作为参数。这使你可以直接访问DOM元素或组件实例。</p><h3 id="理解JSX"><a href="#理解JSX" class="headerlink" title="理解JSX"></a>理解JSX</h3><p>直接在js代码中书写html标记，JSX的本质就是动态创建组件的语法糖<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name= <span class="string">'shengyu'</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello,&#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p><p>也可以表示为<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">name</span>=<span class="string">'shengyu'</span>;</span><br><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>, <span class="comment">//标签名</span></span><br><span class="line">  null, <span class="comment">//属性</span></span><br><span class="line">  <span class="string">'hello,'</span>, <span class="comment">//内容</span></span><br><span class="line">  <span class="keyword">name</span> <span class="comment">//内容</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p><p>优点：无需多学习一门模板语言，用js就可以动态创建UI</p><p>核心概念：在JSX中使用表达式</p><ol><li><p>JSX本身也是表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ele=<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在属性中使用表达式</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyCompnonent yee=&#123;<span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">5</span>&#125; &gt;</span><br></pre></td></tr></table></figure></li><li><p>延展属性</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const props</span> = &#123;firstName:<span class="string">'Ben'</span>,lastName:<span class="string">'Hector'</span>&#125;;</span><br><span class="line"><span class="attribute">const greeting</span> =&lt;Greeting &#123;...props&#125; &gt;</span><br></pre></td></tr></table></figure></li></ol><p>解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值(数组，对象，函数)，那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;a:&#123;b:<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;...x&#125; = obj;</span><br><span class="line">obj.a.b = <span class="number">2</span>;</span><br><span class="line">x.a.b // <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>表达式作为子元素<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ele=<span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.xxx&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h3 id="React生命周期-以及使用场景"><a href="#React生命周期-以及使用场景" class="headerlink" title="React生命周期 以及使用场景"></a>React生命周期 以及使用场景</h3><p><a href="https://www.cnblogs.com/yangzhou33/p/8799278.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangzhou33/p/8799278.html</a></p><h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><ol><li><p>以组件方式考虑UI的构建</p></li><li><p>理解React状态机 （props + state ==&gt; view ）</p><ul><li>React组件一般不提供方法，而是某种状态机</li><li>React组件可以理解为一个纯函数</li><li>单项数据绑定</li></ul></li><li><p>创建组件的步骤</p><ul><li>创建静态ui</li><li>考虑组件的状态组成</li><li>考虑组件的交互方式</li></ul></li><li><p>受控组件 vs 非受控组件<br>受控组件：表单元素的状态由使用者维护<br>非受控组件：表单元素状态DOM自身维护</p></li><li><p>如何创建组件？</p></li></ol><ul><li>单一责任原则<br>1.每个组件只做一件事<br>2.如果组件变的复杂，那么应该拆分成小组件</li></ul><ol start="6"><li>数据状态管理:DRY（Don’t repeat yourself）原则<br>1.能计算得到的状态就不要单独存储<br>2.组件尽量无状态，所需数据通过props获取</li></ol><h3 id="实际开发中遇到的问题"><a href="#实际开发中遇到的问题" class="headerlink" title="实际开发中遇到的问题"></a>实际开发中遇到的问题</h3><ol><li><p>render()里面只能return一个JSX，</p><p>因此在使用数组的.map()方法时，每次循环都要return一个JSX。</p></li><li><p>在使用数组的.map()方法时，建议使用ES6的箭头函数，避免出现this指向的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oneArray.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;a onClick=&#123;<span class="keyword">this</span>.play.bind(<span class="keyword">this</span>)&#125;&gt;test&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>在写一个onClick的时候，如果这个function中没有用到this.state或者this.props时，</p><p> 建议不要使用this.test.bind(this)这种形式的写法，因为都要重新渲染组件，影响性能。</p><p> 常用的几种写法有:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)没有入参时</span><br><span class="line"><span class="keyword">on</span>Click=&#123;this.test&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)有入参时</span><br><span class="line"><span class="keyword">on</span>Click=&#123;this.test('<span class="number">1</span>')&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)语句很少时</span><br><span class="line"><span class="keyword">on</span>Click=&#123;() =&gt; this.<span class="keyword">state</span>.triggle = !this.<span class="keyword">state</span>.triggle&#125;</span><br></pre></td></tr></table></figure></li><li><p>父组件调用子组件的方法：<br> <a href="https://shengyur.github.io/2018/06/02/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">父组件调用子组件的方法</a></p></li><li><p>es6中，寻找数组中是否包含某个元素，</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-5</span>]</span><br><span class="line">arr.find((n) =&gt; n&lt;<span class="number">0</span>)  <span class="comment">//-5</span></span><br><span class="line">arr.findIndex((n) =&gt; n&lt;<span class="number">0</span>)  <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p> 注意:indexOf方法无法识别数组的NaN成员，但是findIndex可以通过Object.is方法做到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>,y))</span><br></pre></td></tr></table></figure></li><li><p>使用this.forceUpdate()来更新当前组件的render()方法。</p></li><li><p>如果两个兄弟组件A和B，A想调用B组件的方法，必须通过两兄弟的父组件C来调用。</p></li></ol><ol start="8"><li><p>将一个形如”a:b:c”的字符串转换成数组，其中a、b、c为整型，转换后的数组内也是整数。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.<span class="keyword">from</span>(<span class="string">"1:3:5"</span>.split(<span class="string">":"</span>),<span class="function"><span class="params">(value)</span> =&gt;</span> Number(value))</span><br></pre></td></tr></table></figure></li><li><p>代码优化：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;store,onChange,disabled&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">this</span>.props.store;</span><br><span class="line"><span class="keyword">let</span> onChange = <span class="keyword">this</span>.props.onChange;</span><br><span class="line"><span class="keyword">let</span> disabled = <span class="keyword">this</span>.props.disabled;</span><br></pre></td></tr></table></figure></li><li><p>回调方法：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">callback</span> &amp;&amp; typeof (callback) == 'function' &amp;&amp; callback();</span><br></pre></td></tr></table></figure></li><li><p>render中的双重循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form.Item label=<span class="string">"出游人群"</span> labelWidth=<span class="string">"120px"</span>&gt;</span><br><span class="line">  &#123;   </span><br><span class="line">    tabAttrObj.touristType.length ?</span><br><span class="line">      <span class="keyword">this</span>.touristTypeList.map(<span class="function">(<span class="params">allType,key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">          tabAttrObj.touristType.map(<span class="function">(<span class="params">type, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">          &#125;)</span><br><span class="line">        )                                     </span><br><span class="line">      &#125;)</span><br><span class="line">    :<span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/Form.Item&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>传入子组件的代码优化：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;CollectMethod &#123;..<span class="selector-class">.this</span><span class="selector-class">.props</span>&#125;  /&gt;</span><br><span class="line">相当于</span><br><span class="line">&lt;AddInput store=&#123;this<span class="selector-class">.props</span><span class="selector-class">.store</span>&#125;</span><br><span class="line">            basicListIndex=&#123;this<span class="selector-class">.props</span><span class="selector-class">.basicListIndex</span>&#125;</span><br><span class="line">            tabAttrObj=&#123;this<span class="selector-class">.props</span><span class="selector-class">.tabAttrObj</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>class 的取值函数（getter）和存值函数（setter）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">prop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">prop</span>(<span class="params"><span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    console.log(<span class="string">'setter: '</span>+<span class="keyword">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.prop&#125;&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复制数组，修改a2的值，并不会影响a1的值。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">a1</span> = [<span class="number">1</span>, <span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">const <span class="built_in">a2</span> = [...a1]<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><ul><li><a href="http://www.css88.com/react/docs/handling-events.html" target="_blank" rel="noopener">React中文文档</a></li><li><a href="https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.md" target="_blank" rel="noopener">王老师的积累</a></li></ul>]]></content>
      
      <categories>
          
          <category> 库/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP状态码解读</title>
      <link href="/2018/07/10/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2018/07/10/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>平时在工作中，经常遇到客户端与服务端交互有问题的情况，复习下状态码以快速定位问题~~</p><p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">状态码  响应类别                       原因短语</span><br><span class="line"><span class="number">1</span>XX    信息性状态码（Informational）    服务器正在处理请求</span><br><span class="line"><span class="number">2</span>XX    成功状态码（Success）           请求已正常处理完毕</span><br><span class="line"><span class="number">3</span>XX    重定向状态码（Redirection）      需要进行额外操作以完成请求</span><br><span class="line"><span class="number">4</span>XX    客户端错误状态码（Client Error） 客户端原因导致服务器无法处理请求</span><br><span class="line"><span class="number">5</span>XX    服务器错误状态码（Server Error） 服务器原因导致处理请求出错</span><br></pre></td></tr></table></figure></p><h3 id="HTTP1状态码（1-1）"><a href="#HTTP1状态码（1-1）" class="headerlink" title="HTTP1状态码（1.1）"></a>HTTP1状态码（1.1）</h3><p>仅记录在 RFC2616 上的HTTP状态码就多达40种，若再加上 RFC4912、5842状态码等扩展，数量就多达60多种，虽然种类繁多，但是常用的只有14种，<br>下面就简单介绍一下</p><h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h3><p>2xx的响应结果表明请求被正常处理了</p><ol><li><p>200 OK<br>表示从客户端发来的请求在服务器端被正常处理了。</p></li><li><p>204 No Content<br>代表服务器接受的请求已成功受理，但在返回的响应报文中不含实体的主体部分。<br>一般在只需要往服务器发送消息，而对客户端不需要发送新信息内容的情况下使用。</p></li><li><p>206 Partial Content<br>表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。相应报文中包含由 Content-Range 指定范围的实体内容。</p></li></ol><h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h3><p>3xx表明浏览器需要执行某些特殊的处理以正确处理请求。</p><ol><li><p>301 Moved Permanently 永久重定向<br>表示请求的资源已经被分配到了新的URI，<strong>以后</strong> 应使用资源现在所指的URI</p></li><li><p>302 Found 临时重定向<br>表示请求的资源已经被分配到了新的URI，希望用户 <strong>本次</strong> 使用资源新的URI</p></li><li><p>303 See Other 临时重定向<br>表示由于请求的资源存在着另一个URI，应该使用GET方法定向获取请求的资源<br>302、303的区别？</p></li></ol><ul><li>303明确表示客户端应该采用 get 方式获取资源 ，这点与 302 有明显区别</li></ul><ol start="4"><li><p>304 Not Modified<br>该状态码表示客户端发送附带条件的请求(采用GET方法的请求报文中 包含 If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任一首部)时，服务端允许请求访问资源，但因发送请求未能满足条件的情况后，直接返回304 Not Unmodified</p></li><li><p>307 Temporary Redirect 临时重定向</p></li></ol><h3 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h3><p>4xx的相应结果表明客户端是发生错误的原因所在</p><ol><li><p>400 Bad Request<br>表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容之后再次发送。另外，浏览器会像对待 200 OK 一样对待该状态码</p></li><li><p>401 Unauthorized<br>该状态码表示发送的请求需要通过HTTP认证的认证信息，另外若之前已经进行过1次请求，则表示用户认证失败。</p></li><li><p>403 Forbidden<br>表明 对请求资源的访问被服务器拒绝了，服务器端没有必要给出拒绝的理由，要是想给的话，会放在实体的主体部分对原因进行描述。<br><strong>未获得文件系统的访问授权，访问权限出现某些问题，都是403发生的原因</strong></p></li><li><p>404 Not Found<br>服务器上没有请求的资源，服务器拒绝且不想解释的时候，会使用</p></li></ol><h3 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h3><p>5xx的相应结果表明服务器本身发生错误。</p><ol><li><p>500 Internal Server Error<br>表示 服务器端在执行请求时发生了错误</p></li><li><p>503 Service Unavilable<br>表示服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。</p></li></ol>]]></content>
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React基础之 组件生命周期</title>
      <link href="/2018/07/09/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/07/09/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/shengyur/Images/master/lifecycle.jpg" alt=""></p><a id="more"></a><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><ol><li>用于初始化内部状态，很少使用</li><li>唯一可以直接修改state的地方</li></ol><h3 id="getDerivedStateFromProps-（react-16-3）"><a href="#getDerivedStateFromProps-（react-16-3）" class="headerlink" title="getDerivedStateFromProps （react 16.3）"></a>getDerivedStateFromProps （react 16.3）</h3><ol><li>当state需要从props初始化时，使用</li><li><strong>尽量不要使用，维护两者状态一致性会增加复杂度</strong></li><li>每次render都会调用<br>运用场景：表单空间获取默认值</li></ol><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><ol><li>ui渲染完之后调用</li><li>只执行一次<br>运用场景：获取外部资源</li></ol><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><ol><li>组件移除时被调用<br>运用场景：资源释放</li></ol><h3 id="getSnapshotBeforeUpdate-react-16-3）"><a href="#getSnapshotBeforeUpdate-react-16-3）" class="headerlink" title="getSnapshotBeforeUpdate (react 16.3）"></a>getSnapshotBeforeUpdate (react 16.3）</h3><ol><li>在页面render之前调用，state已跟新<br>运用场景：获取render之前的dom状态</li></ol><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><ol><li>每次UI跟新时被调用<br>运用场景：页面需要根据props变化重新获取数据</li></ol><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><ol><li>决定 Virtual Dom是否要重绘</li><li>一般不需要手动调用，可以使用 PureComponent 自动实现<br>运用场景：性能优化</li></ol><p><a href="https://github.com/shengyur/react-demo-code-16.3-" target="_blank" rel="noopener">点击查看demo</a></p><p>原文：</p><ul><li>图片来自 <a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></li><li><a href="https://www.zhihu.com/question/278328905/answer/399344422" target="_blank" rel="noopener">https://www.zhihu.com/question/278328905/answer/399344422</a></li></ul>]]></content>
      
      <categories>
          
          <category> 库/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6之扩展运算符与应用</title>
      <link href="/2018/07/05/ES6%E4%B9%8B%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2018/07/05/ES6%E4%B9%8B%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>原文：</p><ol><li><a href="https://www.jianshu.com/p/41f499fa0e7b" target="_blank" rel="noopener">ES6之扩展运算符与应用(数组篇)</a></li><li><a href="https://www.jianshu.com/p/35f9efe95fff" target="_blank" rel="noopener">ES6之扩展运算符与应用(对象篇)</a></li></ol>]]></content>
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node_module无法删除？</title>
      <link href="/2018/07/03/node_module%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%EF%BC%9F/"/>
      <url>/2018/07/03/node_module%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>windows下 删除node_modules文件夹，解决目录层次太深删除报错的问题</p><p>解决方法：</p><p>使用npm中的插件rimraf，专门用于删除的模块插件<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、安装：npm install -g rimraf（全局安装）</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span>、使用：先定位目标文件夹的父级目录，然后命令行输入rimraf xxx（xxx为需要删除的文件夹名称）。</span><br></pre></td></tr></table></figure></p><p>原文链接：<a href="http://blog.csdn.net/sensation_cyq/article/details/51657595" target="_blank" rel="noopener">http://blog.csdn.net/sensation_cyq/article/details/51657595</a></p><p>亲测可用~</p>]]></content>
      
      <categories>
          
          <category> 十万个为什么 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React基础之 React基础之 key的必要性与使用</title>
      <link href="/2018/06/28/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20key%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/28/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20key%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p> <a href="https://segmentfault.com/a/1190000009149186" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009149186</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p><strong>数组数据变更时，不要使用index作为key。</strong></p></li><li><p>key的值要保持稳定且唯一，不能使用random来生成key的值。</p><p>new Date().getTime()好像不太好，但是感觉可以解决问题呢。==</p></li><li><p>key属性是添加到自定义的子组件上，而不是子组件内部的顶层的组件上。</p><p> &lt;MyComponent key=/&gt;</p><a id="more"></a></li><li>key值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。</li></ol><ol start="5"><li><p>不仅仅在数组生成组件上，其他地方也可以使用key，</p><p> 主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例</p><h4 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h4></li><li><p>key的作用</p><pre><code>react利用key来识别组件，它是一种身份标识标识。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。</code></pre></li><li><p>有了key属性后，就可以与组件建立了一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件。</p><pre><code>A.key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。B.key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件（有状态组件的constructor和componentWillUnmount都会执行）</code></pre></li><li><p>key不是用来提升react的性能的，不过用好key对性能是有帮助的。</p></li><li><p>使用最多的场景</p><pre><code>A.由数组动态创建的子组件的情况，需要为每个子组件添加唯一的key属性值。B.为一个有复杂繁琐逻辑的组件添加key后，后续操作可以改变该组件的key属性值，从而达到先销毁之前的组件，再重新创建该组件。</code></pre></li><li><p>index作为key是一种反模式</p><pre><code>A.若数组的内容只是作为纯展示，而不涉及到数组的动态变更，其实是可以使用index作为key的。B.若涉及到数组的动态变更，例如数组新增元素、删除元素或者重新排序等，这时index作为key会导致展示错误的数据。</code></pre></li><li><p>动态数据使用index作为key的问题：</p><p> 具体更新过程我们拿key=0的元素来说明， 数组重新排序后：</p><pre><code>A.组件重新render得到新的虚拟dom；B.新老两个虚拟dom进行diff，新老版的都有key=0的组件，react认为同一个组件，则只可能更新组件；C.然后比较其children，发现内容的文本内容不同（由a---&gt;c)，而input组件并没有变化，这时触发组件的componentWillReceiveProps方法，从而更新其子组件文本内容;D.因为组件的children中input组件没有变化，其又与父组件传入的任props没有关联，所以input组件不会更新(即其componentWillReceiveProps方法不会被执行)，导致用户输入的值不会变化。</code></pre></li></ol>]]></content>
      
      <categories>
          
          <category> 库/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为啥老王要敲头？</title>
      <link href="/2018/06/27/%E4%B8%BA%E5%95%A5%E8%80%81%E7%8E%8B%E8%A6%81%E6%95%B2%E5%A4%B4%EF%BC%9F/"/>
      <url>/2018/06/27/%E4%B8%BA%E5%95%A5%E8%80%81%E7%8E%8B%E8%A6%81%E6%95%B2%E5%A4%B4%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>因为写全局的公共方法没写容错处理额==,mark一下</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把分钟数转化为day天hour小时minute分钟</span></span><br><span class="line"><span class="comment"> * @param minutes 总分钟数</span></span><br><span class="line"><span class="comment"> * @param onlyToHour 是否只精确到小时（true/false）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">transferMinutesToTime(minutes,onlyToHour) &#123;</span><br><span class="line">  <span class="keyword">const</span> basicMinute = <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">const</span> basicHour = <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">const</span> basic = basicHour*basicMinute;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果minutes不是非负整数，返回null</span></span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">this</span>.checkByRegExp.nonnegativeInt(minutes))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果minutes等于0</span></span><br><span class="line">  <span class="keyword">if</span> (minutes == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> onlyToHour ? &#123;</span><br><span class="line">      <span class="built_in">day</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="built_in">hour</span>: <span class="number">0</span></span><br><span class="line">    &#125; : &#123;</span><br><span class="line">        <span class="built_in">day</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="built_in">hour</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="built_in">minute</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果minutes为正整数</span></span><br><span class="line">  let all = Number(minutes);</span><br><span class="line">  let <span class="built_in">day</span> = Math.<span class="built_in">floor</span>(all/basic);</span><br><span class="line">  let <span class="built_in">hour</span> = Math.<span class="built_in">floor</span>((all%basic)/basicMinute);</span><br><span class="line">  let <span class="built_in">minute</span> = all%basic%basicMinute;</span><br><span class="line"></span><br><span class="line">  let data = &#123;</span><br><span class="line">    <span class="built_in">day</span>: <span class="built_in">day</span>?<span class="built_in">day</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="built_in">hour</span>: <span class="built_in">hour</span>?<span class="built_in">hour</span>:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!onlyToHour)&#123;</span><br><span class="line">    data.<span class="built_in">minute</span> = <span class="built_in">minute</span>?<span class="built_in">minute</span>:<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 十万个为什么 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Array、Object常用方法（ES3、ES5、ES6）</title>
      <link href="/2018/06/25/Array%E3%80%81Object%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/06/25/Array%E3%80%81Object%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>使用场景：<br>使用react、vue等数据驱动的框架时，dom操作基本不用了，更多的是修改数据来驱动UI渲染。<br>所以总结一下常用的方法，以提高coding效率~</p><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="数组元素的添加和删除"><a href="#数组元素的添加和删除" class="headerlink" title="数组元素的添加和删除"></a>数组元素的添加和删除</h3><ol><li><p>为新索引赋值</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">arr[0]</span>=<span class="string">"zero"</span></span><br></pre></td></tr></table></figure></li><li><p>使用arr.push()在数组末尾增加一个或多个元素：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="keyword">push</span>(<span class="string">"zero"</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用arr.pop()来从末尾推出一个值，并返回被推出的值</p></li><li><p>使用arr.shift()方法，从数组头部删除一个元素,返回被删除的元素，整个数组的index少1</p></li><li><p>使用arr.unshift()方法，从数组头部推入一个元素，返回新数组的长度</p></li><li><p>使用delete运算符来删除数组元素(原数组会变成稀疏数组)</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">delete a[<span class="number">1</span>];</span><br><span class="line"><span class="number">1</span> in a   <span class="comment">//false</span></span><br><span class="line">a.length <span class="comment">//3 delete操作并不会影响数组长度</span></span><br></pre></td></tr></table></figure></li><li><p>设置length属性为一个新的期望长度来删除数组 <strong>末尾</strong> 的元素arr</p></li><li><p>splice()方法用来插入、删除、替换元素</p></li></ol><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><ol><li><p>for循环<br>Object.keys(arr)可以获得数组的下标</p></li><li><p>for in (可以枚举继承的属性名，如添加到Array.property中的方法)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!a.hasOwnProperty(i)) <span class="keyword">continue</span>;<span class="comment">//跳过继承的属性</span></span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">String</span>(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(i))))!==i) <span class="keyword">continue</span>;<span class="comment">//跳过不是非负整数的i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>es5中提供了forEach()方法</p></li></ol><h3 id="数组方法-1"><a href="#数组方法-1" class="headerlink" title="数组方法"></a>数组方法</h3><p>(ES3)</p><ol><li>Array.join()方法<br>将数组中的所有元素转化为字符串并拼接在一起，<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr.join(<span class="string">","</span>)   <span class="comment">//"1,2,3,4"</span></span><br></pre></td></tr></table></figure></li></ol><p>Array.join()方法是String.split()方法的逆向操作，后者是把字符串分割成若干块来创建一个数组。</p><ol start="2"><li>Array.reverse() （修改原数组）<br>不通过用重新排列的元素创建新数组，而是在原先的数组中重新排列他们</li></ol><h3 id="对象属性的遍历-ES6"><a href="#对象属性的遍历-ES6" class="headerlink" title="对象属性的遍历 ES6"></a>对象属性的遍历 ES6</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><p>（1）for…in</p><p>  for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p>（2）Object.keys(obj)</p><p>  Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p>（3）Object.getOwnPropertyNames(obj)</p><p>  Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p>（4）Object.getOwnPropertySymbols(obj)</p><p>  Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p>（5）Reflect.ownKeys(obj)<br>  Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><p>参考：<br> <a href="https://segmentfault.com/a/1190000014100810?utm_source=index-hottest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014100810?utm_source=index-hottest</a></p>]]></content>
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> ES5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何使用a标签或者href实现文件的下载？</title>
      <link href="/2018/06/23/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8a%E6%A0%87%E7%AD%BE%E6%88%96%E8%80%85href%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD%EF%BC%9F/"/>
      <url>/2018/06/23/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8a%E6%A0%87%E7%AD%BE%E6%88%96%E8%80%85href%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD%EF%BC%9F/</url>
      <content type="html"><![CDATA[<ol><li>利用iframe实现（下载的文件域名不方便直接写）</li></ol><p>html：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:Slide.downLoadCooperationAgreement();"</span>&gt;</span>年度合作协议<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Slide.downLoadCooperationAgreement = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">url</span> = System.domainUrlTotUedPxy[System.testTotPxyFlag]+<span class="string">'/download/annualCooperationAgreement_v1.docx'</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">size</span> = $(<span class="string">"#cooperationAgreement_download"</span>).size();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">       $(<span class="string">"body"</span>).append(<span class="string">"&lt;iframe id = 'cooperationAgreement_download' style='display:none;' src='"</span>+<span class="built_in">url</span>+<span class="string">"'&gt;&lt;/iframe&gt;"</span>);</span><br><span class="line">    &#125; <span class="title">else</span> &#123;</span><br><span class="line">      $(<span class="string">"#cooperationAgreement_download"</span>).attr(<span class="string">"src"</span>, <span class="built_in">url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用a标签实现，download属性可以用来命名下载的文件。<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span> href=<span class="string">"/i/w3school_logo_white.gif"</span> download=<span class="string">"w3logo"</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">img</span> <span class="attribute">border</span>=<span class="string">"0"</span> src=<span class="string">"/i/w3school_logo_white.gif"</span> alt=<span class="string">"W3School"</span>&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ol><p>原文：</p><ul><li><a href="https://github.com/wang-qingqing/accumulate/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB/%E5%85%B6%E5%AE%83/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88a%E6%A0%87%E7%AD%BE%E7%9A%84href%E5%AE%9E%E7%8E%B0%EF%BC%89.md" target="_blank" rel="noopener">王老师的积累</a></li></ul>]]></content>
      
      <categories>
          
          <category> 十万个为什么 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>git菜鸟踩坑日常</title>
      <link href="/2018/06/20/git%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/06/20/git%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>在工作中使用的代码管理工具之前一直是svn，最近接触了几个使用git管理代码的项目，拉个代码拉了半天，十分生气，记录下踩坑日常，避免重蹈覆辙~<br><a id="more"></a></p><h3 id="权限已经开，但是git-clone提示找不到该路径"><a href="#权限已经开，但是git-clone提示找不到该路径" class="headerlink" title="权限已经开，但是git clone提示找不到该路径?"></a>权限已经开，但是git clone提示找不到该路径?</h3><ol><li>首先，确定权限已经是开好</li><li>回忆了一下公司的代码仓库，猜测可能是用户名与自己本地默认的自己github的账号密码不一样</li><li><p>查看当前用户的配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global  --list</span><br></pre></td></tr></table></figure></li><li><p>发现显示的用户名果然与公司的域账号用户名密码不一致，每次拉代码也没让输用户名密码，怕不是默认记住密码了？？?</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--system --list</span><br></pre></td></tr></table></figure></li></ol><ul><li>查看系统config文件中，对是否记住密码的配置，果然有记住密码的配置<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">credential <span class="keyword">helper</span>== credential <span class="keyword">helper</span></span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>清除保存的用户名密码</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git credential-manager delete</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">git credential-manager remove <span class="string">[--path &lt;installion_path&gt;]</span> <span class="string">[--passive]</span> <span class="string">[--force]</span>   //停止使用管理工具<span class="string">[中括号选填]</span></span><br></pre></td></tr></table></figure></li><li><p>重新拉取代码，提示输入用户名密码，切换账户后问题解决</p></li></ol><h3 id="git-clone-默认的是master分支，如何切换到branch分支？"><a href="#git-clone-默认的是master分支，如何切换到branch分支？" class="headerlink" title="git clone 默认的是master分支，如何切换到branch分支？"></a>git clone 默认的是master分支，如何切换到branch分支？</h3><p>git初始化一般是这样。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git <span class="keyword">clone</span> <span class="title">.git</span>地址</span><br></pre></td></tr></table></figure></p><p>之后重点来了，因为clone下来的一般为master分支，有可能不是想拉下来的分支。可以使用以下的方法<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">branch </span>-a 先查看当前远端分支情况</span><br><span class="line"></span><br><span class="line">git  checkout <span class="keyword">origin/xxx </span> 选择远端xxx分支</span><br><span class="line"></span><br><span class="line">git <span class="keyword">branch </span>xxx  创建本地xxx分支</span><br><span class="line"></span><br><span class="line">git checkout xxx  选择新创建的分支就可以了。</span><br></pre></td></tr></table></figure></p><p>当然还有更简单的方法。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接指定clone某个分支即可：</span><br><span class="line"></span><br><span class="line">git <span class="keyword">clone</span> <span class="title">-b</span> xxx .git地址</span><br></pre></td></tr></table></figure></p><h3 id="tuniu内部的代码npm-install报错？"><a href="#tuniu内部的代码npm-install报错？" class="headerlink" title="tuniu内部的代码npm install报错？"></a>tuniu内部的代码npm install报错？</h3><p>先安装<a href="https://www.npmjs.com/package/cnpm" target="_blank" rel="noopener">cnpm</a>：<br> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> cnpm -g</span><br></pre></td></tr></table></figure></p><p> 设置公司内部镜像：<br> <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">set</span> registry <span class="comment">http:</span>//<span class="comment">10.40.189.154:7001</span></span><br></pre></td></tr></table></figure></p><p>不报错的话，就设置好了，使用命令检查一下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="built_in">config</span> <span class="built_in">get</span> registry <span class="comment">//看下是否返回 http://10.40.189.154:7001</span></span><br></pre></td></tr></table></figure></p><p>是的话,再<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cnpm i</span></span><br></pre></td></tr></table></figure></p><p>安装依赖就行了。</p><p>参考：<br><a href="https://segmentfault.com/q/1010000007962678" target="_blank" rel="noopener">https://segmentfault.com/q/1010000007962678</a><br><a href="https://blog.csdn.net/yun__yang/article/details/74466059" target="_blank" rel="noopener">https://blog.csdn.net/yun__yang/article/details/74466059</a></p>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>YAML语言入门</title>
      <link href="/2018/06/20/YAML%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/2018/06/20/YAML%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>使用场景：</p><p>编程免不了要写配置文件，写配置文件的时候，除了json格式，yaml格式的配置文件也很常见。所以决定系统学习一下。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。</p><h3 id="YAML的基本语法规范"><a href="#YAML的基本语法规范" class="headerlink" title="YAML的基本语法规范"></a>YAML的基本语法规范</h3><p>YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。<br><a id="more"></a><br>它的基本语法规则如下：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>大小写敏感</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>使用缩进表示层级关系</span><br><span class="line"></span><br><span class="line"><span class="bullet">3. </span>缩进时不允许使用Tab键，只允许使用空格。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4. </span>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</span><br><span class="line"></span><br><span class="line"><span class="bullet">5. </span>#表示注释，从这个字符一直到行尾，都会被解析器忽略。</span><br></pre></td></tr></table></figure></p><h3 id="YAML支持的数据格式"><a href="#YAML支持的数据格式" class="headerlink" title="YAML支持的数据格式"></a>YAML支持的数据格式</h3><p>YAML支持的数据格式有三种。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 数组：一组按次序排列的值，又称为序列（sequence） / 列表（<span class="type">list</span>）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 纯量（scalars）：单个的、不可再分的值</span><br></pre></td></tr></table></figure></p><p>以下分别介绍这三种数据结构。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象的一组键值对，使用冒号结构表示。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animal</span>: pets</span><br><span class="line"></span><br><span class="line">转为javascript表示为：</span><br><span class="line"></span><br><span class="line"> &#123; animal: 'pets' &#125;</span><br></pre></td></tr></table></figure><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">hash</span>: &#123; <span class="attribute">name</span>: Steve, foo: bar &#125;</span><br><span class="line"></span><br><span class="line">转为<span class="selector-tag">js</span>表示为：</span><br><span class="line"></span><br><span class="line">&#123; <span class="attribute">hash</span>: &#123; name: <span class="string">'Steve'</span>, foo: <span class="string">'bar'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一组连词线开头的行，构成一个数组。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> Cat</span></span><br><span class="line"><span class="ruby">- Dog</span></span><br><span class="line"><span class="ruby">- Goldfish</span></span><br></pre></td></tr></table></figure><p>转为js表示为<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="symbol">'Cat</span>', <span class="symbol">'Dog</span>', <span class="symbol">'Goldfish</span>' ]</span><br></pre></td></tr></table></figure></p><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"></span></span><br><span class="line"><span class="ruby"> - Cat</span></span><br><span class="line"><span class="ruby"> - Dog</span></span><br><span class="line"><span class="ruby"> - Goldfish</span></span><br></pre></td></tr></table></figure></p><p>转为 JavaScript 如下。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [ <span class="symbol">'Cat</span>', <span class="symbol">'Dog</span>', <span class="symbol">'Goldfish</span>' ] ]</span><br></pre></td></tr></table></figure></p><p>数组也可以采用行内表示法。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">animal</span>: <span class="comment">[Cat, Dog]</span></span><br></pre></td></tr></table></figure></p><p>转为js表示为：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">animal</span>: [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span> ] &#125;</span><br></pre></td></tr></table></figure></p><h3 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h3><p>对象和数组可以结合使用，形成复合结构。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">languages:</span><br><span class="line"> - Ruby</span><br><span class="line"> - Perl</span><br><span class="line"> - Python</span><br><span class="line">websites:</span><br><span class="line"> YAML: yaml.org</span><br><span class="line"> Ruby: ruby-lang.org</span><br><span class="line"> Python: python.org</span><br><span class="line"> Perl: use<span class="selector-class">.perl</span><span class="selector-class">.org</span></span><br></pre></td></tr></table></figure></p><p>转为 JavaScript 如下<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">languages</span>: [ <span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span> ],</span><br><span class="line">  <span class="attribute">websites</span>:</span><br><span class="line">   &#123; <span class="attribute">YAML</span>: <span class="string">'yaml.org'</span>,</span><br><span class="line">     <span class="attribute">Ruby</span>: <span class="string">'ruby-lang.org'</span>,</span><br><span class="line">     <span class="attribute">Python</span>: <span class="string">'python.org'</span>,</span><br><span class="line">     <span class="attribute">Perl</span>: <span class="string">'use.perl.org'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h3><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">字符串</span></span><br><span class="line"><span class="string">布尔值</span></span><br><span class="line"><span class="string">整数</span></span><br><span class="line"><span class="string">浮点数</span></span><br><span class="line"><span class="literal">Null</span></span><br><span class="line"><span class="string">时间</span></span><br><span class="line"><span class="string">日期</span></span><br></pre></td></tr></table></figure></p><p>注意：</p><ul><li>null 用 ~ 表示。</li><li><p>时间采用 ISO8601 格式。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iso8601: 2001<span class="string">-12</span><span class="string">-14</span>t21:59:43.10<span class="string">-05</span>:00  </span><br><span class="line">(js表示：&#123; iso8601: new Date('2001<span class="string">-12</span><span class="string">-14</span>t21:59:43.10<span class="string">-05</span>:00') &#125;)</span><br></pre></td></tr></table></figure></li><li><p>日期采用复合 iso8601 格式的年、月、日表示。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">date</span>: 1976-07-31</span><br><span class="line"></span><br><span class="line">转为 JavaScript 如下。</span><br><span class="line">&#123; date: new Date('1976-07-31') &#125;</span><br></pre></td></tr></table></figure></li><li><p>YAML 允许使用两个感叹号，强制转换数据类型。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">e</span>: !!str 123</span><br><span class="line"><span class="attribute">f</span>: !!str true</span><br><span class="line"></span><br><span class="line">转为 JavaScript 如下。</span><br><span class="line">&#123; e: '123', f: 'true' &#125;</span><br></pre></td></tr></table></figure></li></ul><p>未完待续。。。</p><p>参考：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YAML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数式编程入门</title>
      <link href="/2018/06/19/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
      <url>/2018/06/19/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h3 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h3><p>它详细的解释可以参考维基百科。缘起数学家 Alonzo Church 提出了 Lambda 演算的概念，可以用函数组合的方式来描述计算过程，换句话来说，<strong>如果一个问题能够用一系列函数组合的算法来表达，那么这个问题就认为是可计算的。</strong></p><p><figure><br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/fl.jpeg" alt="Gardenia jasminoides"><br></figure><br><a id="more"></a></p><p>它和面向对象编程一样，也是一种编程范式。强调执行的过程而非结果，通过一系列的嵌套的函数调用，完成一个运算过程。它主要有以下几个特点：</p><ul><li><p>函数是”一等公民”：函数优先，和其他数据类型一样。</p></li><li><p>只用”表达式”，不用”语句”：通过表达式（expression）计算过程得到一个返回值，而不是通过一个语句（statement）修改某一个状态。</p></li><li><p>无副作用：不污染变量，同一个输入永远得到同一个数据。</p></li><li><p>不可变性：前面一提到，不修改变量，返回一个新的值。</p></li></ul><h3 id="范畴论与函数式编程"><a href="#范畴论与函数式编程" class="headerlink" title="范畴论与函数式编程"></a>范畴论与函数式编程</h3><ul><li>在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。</li><li>所以，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</li><li><strong>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。</strong></li></ul><h3 id="函数的合成与柯里化"><a href="#函数的合成与柯里化" class="headerlink" title="函数的合成与柯里化"></a>函数的合成与柯里化</h3><p>函数式编程有两个最基本的运算：<strong>合成和柯里化</strong>。</p><h4 id="函数的合成"><a href="#函数的合成" class="headerlink" title="函数的合成"></a>函数的合成</h4><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。<br>合成两个函数的简单代码如下。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span> <span class="params">(f, g)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数的合成还必须满足结合律。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">compose</span><span class="params">(f, compose(g, h)</span></span>)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="title">compose</span><span class="params">(compose(f, g)</span></span>, h)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="title">compose</span><span class="params">(f, g, h)</span></span></span><br></pre></td></tr></table></figure></p><p><strong>合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？</strong><br>前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。<br><strong>这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addX</span><span class="params">(y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addX(<span class="number">2</span>)(<span class="number">1</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。</p><h4 id="函子"><a href="#函子" class="headerlink" title="函子"></a>函子</h4><p>函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。</p><h3 id="函数式编程在前端开发中的应用"><a href="#函数式编程在前端开发中的应用" class="headerlink" title="函数式编程在前端开发中的应用"></a>函数式编程在前端开发中的应用</h3><p>函数式编程的概念其实出来也已经好几十年了，我们能在很多编程语言身上看到它的身影。比如比较纯粹的 Haskell，以及一些语言开始逐渐成为多范式编程语言，比如 Swift，还有 Kotlin，Java，Js 等都开始具备函数式编程的特性。这么多语言开始逐渐有了支持，函数式编程对于我们的生活到底能够带来一些什么好处呢?</p><p>提到现代前端开发，那么 React 肯定是逃不开的一个话题。在 React 技术栈中，函数式编程有哪些体现呢？</p><h4 id="Stateless-components"><a href="#Stateless-components" class="headerlink" title="Stateless components"></a>Stateless components</h4><p>在 React 0.14 之后推出的，先来看一段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>My props name &#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个简单的无状态组件，我们没有用createClass或者是extends React.Component来创建一个组件，而是通过一个 Pure function 返回了一个组件。<br>那么这里的好处是什么呢？</p><ol><li><p>简洁，一眼可以看出这个组件的作用；</p></li><li><p>无副作用，只要传入同一个 props 那么 render 出来的组件一定是相同的；</p></li><li><p>测试更友好；</p></li><li><p>没有this，要知道this还是难倒了好多英雄好汉的；</p></li><li><p>更容易实现 SSR（这一点我并未考证，有知道的朋友可以补充）。</p></li></ol><p>当然，使用Stateless component并不是万能的，可以很明显的看到没有了 React 的生命周期，这个问题通常我们会结合 HOC 来解决。你看这一点就印证了前面说的，通过函数的组合完成对结果的表达，是不是很有意思。</p><h4 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h4><p>在前端应用越来越复杂的今天，数据流管理是一件很重要的事，Redux 就是来解决这个问题的。它是 Flux 架构的演化实现，官方 GitHub 解释为 <strong>Predictable state container（可预测状态机）。</strong></p><p>在 Redux 中我们存在一个单的树形结构的 state，单一数据源降低了多数据源的信任问题。State 是通过每个 reducer 的结果组合而来的，每个 reducer 都是一个 Pure function，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isLoading = <span class="function">(<span class="params">state = <span class="literal">false</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> MarketActionsTypes.FETCH_MARKET_DATA_START: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>在 reducer 中不会直接修改每个 state 中的状态，而是返回一个新的状态，然后整个 state 的结果通过一个个 reducer 的结果归纳出来。</strong> 我们来看 reducer 源码是怎么工作的：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">    <span class="comment">// from https://github.com/reduxjs/redux/blob/b02310b359a0832f65873d024570d411b465ced9/src/combineReducers.js#L162</span></span><br><span class="line">    let hasChanged = <span class="keyword">false</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">key</span> = finalReducerKeys[i]</span><br><span class="line">      <span class="keyword">const</span> reducer = finalReducers[<span class="built_in">key</span>]</span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[<span class="built_in">key</span>]</span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      <span class="keyword">if</span> (typeof nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(<span class="built_in">key</span>, action)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(errorMessage)</span><br><span class="line">      &#125;</span><br><span class="line">      nextState[<span class="built_in">key</span>] = nextStateForKey</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p><p>我们可以很直观的看到，最后的 state 结果是通过将每个 reducer 生成的局部结果组合起来得到一个新的 nextState，而不是直接在原有的 state 上进行修改。</p><p>所以，我们再回过头来看看它的定义——可预测状态机。<br><strong>每个 reducer 都是一个纯函数，只要输入恒定，那么输出肯定是恒定的。同时，无副作用的特性可以保证 state 不会被意外修改，那么整个应用的 state 都是可以准确的知道的。</strong><br>最终的结果可以通过一系列的信息组合得来，这是一个很重要的改变。</p><p>在函数式编程中，我们将一个个复杂的问题抽象成一个个过程的表达，然后再将不同的过程结果组合起来，更加容易找到问题的解决办法。对于我们在其他领域的编码也是一样的道理，剥离问题表面，还原问题本质。有了这样的思维的时候，当你和别人在看同一个问题的时候，你会更容易有一种拨云见日的感觉。</p><p>除了抽象的能力，分解问题的能力也是很重要的一个启发。将问题化小，分而治之，然后组合结果。当然这个能力不仅仅是函数式编程才具备的，分治法在很多算法里已经体现得淋漓尽致了。不过这里还是想再提一下这个话题，分而治之可以在各个维度的工作上进行运用，小到一个算法的具体实现，然后到一个问题的过程分解，甚至大到一个工作任务的拆解，都可以用分而治之的思维去寻找解题之法。</p><p>当然函数式编程还有其他的一些不足之处，比如有人会说在函数式编程中数据复制可能会比较严重，可能会造成性能问题。这个问题我是这样看的，局部来说他可能确实看起来会存在一定的影响。但是从另一个角度来说，在我们使用函数式编程的时候，不用担心全局变量被破坏，没有执行顺序的依赖。我们在并行编程的时候，也不需要依赖于过多的锁的，那么反而最终可以提升最终性能。</p><p>参考：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门教程</a></li><li><a href="https://mp.weixin.qq.com/s/25Azr08BJivOBmPbkYwKTQ" target="_blank" rel="noopener">漫谈函数式编程在前后端开发中的应用</a></li></ul>]]></content>
      
      <categories>
          
          <category> 技术思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>说大人，则渺之。</title>
      <link href="/2018/06/18/%E8%AF%B4%E5%A4%A7%E4%BA%BA%EF%BC%8C%E5%88%99%E6%B8%BA%E4%B9%8B%E3%80%82/"/>
      <url>/2018/06/18/%E8%AF%B4%E5%A4%A7%E4%BA%BA%EF%BC%8C%E5%88%99%E6%B8%BA%E4%B9%8B%E3%80%82/</url>
      <content type="html"><![CDATA[<p>孟子曰：说①大人，则藐之，勿视其巍巍然。堂高数仞，榱题②数尺，我得志，弗为也。食前方丈，侍妾数百人，我得志，弗为也。般乐饮酒，驱骋田猎，后车千乘，我得志，弗为也。在彼者，皆我所不为也；在我者，皆古之制也。吾何畏彼哉？”</p><a id="more"></a><p>①说（Shui）：向……进言。<br>②榱（cuī）题：也叫“出檐”，指屋檐的前端。</p>]]></content>
      
      <categories>
          
          <category> 人间不值得 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>利用hexo在多台电脑上提交和更新github pages博客</title>
      <link href="/2018/06/16/%E5%88%A9%E7%94%A8hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0github%20pages%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/06/16/%E5%88%A9%E7%94%A8hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0github%20pages%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Hexo部署到GitHub上的文件，是本地的.md文件编译生成的html文件（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，没有编译之前的母本文件，操作就很麻烦了。</p><p>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，操作简单，效率更高。</p><p>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，就会多出许多不必要的仓库（10个项目需要20个仓库）。所以，本文选择利用分支。</p><p>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p><p>下面以我的博客作为例子详细地讲述。</p><h4 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h4><p>1 . 创建仓库，shengyur.github.io；</p><p>2 . 创建两个分支：master 与 hexo；</p><p>3 . 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</p><p>4 . 使用git clone xxx.github.io.git拷贝仓库；</p><p>5 . 在本地xxx.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</p><p>6 . 修改_config.yml中的deploy参数，分支应为master；</p><p>7 . 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</p><p>8 . 执行hexo generate -d生成网站并部署到GitHub上。</p><p>这样一来，在GitHub上的xxx.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。多端登陆修改博客就可以实现了~</p><p>参考：</p><ol><li><a href="https://www.jianshu.com/p/0b1fccce74e0" target="_blank" rel="noopener">https://www.jianshu.com/p/0b1fccce74e0</a></li><li><a href="https://formulahendry.github.io/2016/12/04/hexo-ci/" target="_blank" rel="noopener">https://formulahendry.github.io/2016/12/04/hexo-ci/</a></li><li><a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more" target="_blank" rel="noopener">http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more</a></li></ol>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>axios常用攻略</title>
      <link href="/2018/06/14/axios%E5%B8%B8%E7%94%A8%E6%94%BB%E7%95%A5/"/>
      <url>/2018/06/14/axios%E5%B8%B8%E7%94%A8%E6%94%BB%E7%95%A5/</url>
      <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>npm install axios</p><p><strong>axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。</strong></p><a id="more"></a><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><ol><li>执行get请求</li></ol><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向具有指定ID的用户发出请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(response);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">error</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 params 对象传递参数</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(response);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>执行post请求</li></ol><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(response);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>执行多个并发请求</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">getUserAccount</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">axios.get('/user/12345')</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">getUserPermissions</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">axios.get('/user/12345/permissions')</span>;</span><br><span class="line">&#125;</span><br><span class="line">axios.<span class="keyword">all</span>([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .<span class="keyword">then</span>(axios.spread(<span class="keyword">function</span> <span class="title"></span>(acct, perms) &#123;</span><br><span class="line">    //两个请求现已完成</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><p>更多可参考：<br><a href="https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/" target="_blank" rel="noopener">https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/</a></p>]]></content>
      
      <categories>
          
          <category> 库/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mock工具使用</title>
      <link href="/2018/06/14/mock%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/14/mock%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="mock的基础解释"><a href="#mock的基础解释" class="headerlink" title="mock的基础解释"></a>mock的基础解释</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>  可以在不依赖后端环境的情况下，进行前端开发，帮助编写单元测试,减少联调成本，提高工作效率。</p><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>  A.能渲染模板<br>  B.实现请求路由映射<br>  C.数据接口代理到生产或者测试环境</p><a id="more"></a><h3 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h3><p>  在开发过程中，模拟后台接口数据，快速地实现前端开发。</p><h2 id="mock的用法"><a href="#mock的用法" class="headerlink" title="mock的用法"></a>mock的用法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> mockjs</span><br></pre></td></tr></table></figure><h3 id="使用mock"><a href="#使用mock" class="headerlink" title="使用mock"></a>使用mock</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> Mock = <span class="keyword">require</span>(<span class="string">'mockjs'</span>);</span><br><span class="line"><span class="built_in">var</span> mock = Mock.mock(&#123;</span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p> mock的语法规范包含两层规范：数据模板（DTD）和数据占位符（DPD）。</p><h4 id="数据模板DTD"><a href="#数据模板DTD" class="headerlink" title="数据模板DTD"></a>数据模板DTD</h4><pre><code>A.模板规则：&apos;name|rule&apos;:value</code></pre><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中，<span class="built_in">na</span><span class="symbol">me:</span>属性名； ru<span class="symbol">le:</span>属性规则；<span class="built_in">value</span>：属性值。</span><br><span class="line">    属性名和规则之间用|隔开，规则是可以选的。</span><br></pre></td></tr></table></figure><pre><code>B.7个rule<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">'name|<span class="built_in">min</span>-<span class="built_in">max</span>':<span class="built_in">value</span></span><br><span class="line">'name|<span class="built_in">count</span>':<span class="built_in">value</span></span><br><span class="line">'name|<span class="built_in">min</span>-<span class="built_in">max</span>.dmin-dmax':<span class="built_in">value</span></span><br><span class="line">'name|<span class="built_in">min</span>-<span class="built_in">max</span>.dcount':<span class="built_in">value</span></span><br><span class="line">'name|<span class="built_in">count</span>.dmin-dmax':<span class="built_in">value</span></span><br><span class="line">'name|<span class="built_in">count</span>.dcount':<span class="built_in">value</span></span><br><span class="line">'name|+step':<span class="built_in">value</span></span><br></pre></td></tr></table></figure></code></pre><p><strong>（1）生成规则需要根据属性值的类型才能确定（2）属性值可以含有@占位符（3）属性值可以指定最终值的初始值和类型</strong></p><pre><code>C.属性值是String</code></pre><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name1|1-3'</span> : <span class="string">'a'</span>, <span class="comment">//重复生成1到3个a</span></span><br><span class="line">    <span class="string">'name2|2'</span> : <span class="string">'b'</span> <span class="comment">//生成bb</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>D.属性值是Number</code></pre><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name1|+1'</span> : <span class="number">4</span>,  <span class="comment">//生成4,如果循环每次加1</span></span><br><span class="line">    <span class="string">'name2|1-7'</span> : <span class="number">2</span>, <span class="comment">//生成一个数字，1到7之间</span></span><br><span class="line">    <span class="string">'name3|1-4.5-8'</span> : <span class="number">1</span>  <span class="comment">//生成一个小数，整数部分1到4，小数部分5到8位（！！！表示小数点之后的位数范围）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>E.属性值是Boolean</code></pre><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name|1'</span>: <span class="keyword">true</span>, <span class="regexp">//</span>生成一个布尔值，各一半</span><br><span class="line">    <span class="string">'name1|1-3'</span>: <span class="keyword">true</span>  /<span class="regexp">/ 1/</span><span class="number">4</span>是<span class="keyword">true</span>，<span class="number">3</span>/<span class="number">4</span>是<span class="keyword">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>F.属性值是Object</code></pre><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> obj = &#123;</span><br><span class="line">    <span class="selector-tag">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="selector-tag">b</span>:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span>,</span><br><span class="line">    d:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name|1-3'</span>: obj,</span><br><span class="line">    <span class="string">'name|2'</span>: obj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>G.属性值是Array</code></pre><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name1|1'</span>: arr, <span class="comment">//从数组里随机取出1个值</span></span><br><span class="line">    <span class="string">'name2|2'</span>: arr, <span class="comment">//数组重复count次，这里count为2</span></span><br><span class="line">    <span class="string">'name3|1-3'</span>: arr  <span class="comment">//数组重复1到3次</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>H.属性值是Function</code></pre><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">fun</span> = <span class="title">function</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="function"><span class="title">fun</span><span class="params">(<span class="number">10</span>)</span></span>         <span class="comment">//返回函数的返回值20</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>I.属性值是RegExp    根据正则表达式反向生成对应的字符串，用于生成自定义格式的字符串</code></pre><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">var</span> <span class="class"><span class="keyword">data</span> = <span class="type">Mock</span>.mock(&#123;</span></span><br><span class="line"><span class="class">    ‘<span class="title">name1'</span>:/[<span class="title">a</span>-<span class="title">z</span>][<span class="type">A</span>-<span class="type">Z</span>]/,</span></span><br><span class="line"><span class="class">    '<span class="title">name2'</span>:/\<span class="title">d</span>&#123;1,3&#125;/</span></span><br><span class="line"><span class="class">&#125;)</span></span><br></pre></td></tr></table></figure><pre><code>会根据各自的正则表达式进行适配，并且随机返回</code></pre><h4 id="数据占位符DPD"><a href="#数据占位符DPD" class="headerlink" title="数据占位符DPD"></a>数据占位符DPD</h4><p>关于占位符，占位符只是在属性值是字符串的时候，在字符串里占个位置，并不会出现在最终的属性值中。</p><p>占位符的格式为：@占位符,关于占位符需要知道以下几点：</p><ul><li><p>用@标识符标识后面的字符串是占位符</p></li><li><p>占位符的值是从Mock.Random方法中引用的</p></li><li><p>可以通过Mock.Random.extend()来扩展自定义占位符</p></li><li><p>占位符可以引用数据模板中的属性</p></li><li><p>占位符优先引用数据模板中的属性</p></li><li><p>占位符支持相对路径和决定路径</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">var</span> <span class="class"><span class="keyword">data</span> = <span class="type">Mock</span>.mock(&#123;</span></span><br><span class="line"><span class="class">    <span class="title">name</span>:&#123;</span></span><br><span class="line"><span class="class">        <span class="title">name1</span>:'@<span class="type">FIRST</span>',</span></span><br><span class="line"><span class="class">        <span class="title">name2</span>:'@<span class="type">LAST</span>'</span></span><br><span class="line"><span class="class">    &#125;    </span></span><br><span class="line"><span class="class">&#125;)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Mock-mock"><a href="#Mock-mock" class="headerlink" title="Mock.mock()"></a>Mock.mock()</h4><ul><li>Mock.mock(rurl,rtype,template|function(opt))</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">rurl:</span> ajax请求的地址</span><br><span class="line"><span class="symbol">rtype:</span> ajax请求的类型，如’GET<span class="string">','</span>POST'</span><br><span class="line"><span class="symbol">template:</span> 数据模板，就是之前那些个例子</span><br><span class="line"><span class="symbol">function:</span> 生成相应数据的函数</span><br></pre></td></tr></table></figure><ul><li>常用的方法</li></ul><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A. Mock.mock(<span class="keyword">template</span>)</span><br><span class="line"></span><br><span class="line">B. Mock.mock(rurl,<span class="keyword">template</span>)，模拟ajax,匹配接收到url的ajax请求，把<span class="keyword">template</span>对应的数据返回返回</span><br><span class="line"></span><br><span class="line">C. Mock.mock(rurl,<span class="built_in">function</span>(opt)),模拟ajax,会把函数执行的结果作为ajax回调返回</span><br><span class="line"></span><br><span class="line">D. Mock.mock(rurl,rtype,<span class="keyword">template</span>) 同上，只是对ajax的类型有要求</span><br><span class="line"></span><br><span class="line">E. Mock.mock(rurl,rtype,<span class="built_in">function</span>) 同上</span><br></pre></td></tr></table></figure><h4 id="Mock-setup-setting"><a href="#Mock-setup-setting" class="headerlink" title="Mock.setup(setting)"></a>Mock.setup(setting)</h4><p>配置拦截ajax请求的行为，支持的配置项有timeout。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mock.setup(&#123;</span><br><span class="line">    <span class="keyword">timeout</span>:<span class="number">200</span></span><br><span class="line">&#125;)</span><br><span class="line">Mock.setup(&#123;</span><br><span class="line">    <span class="keyword">timeout</span>:'<span class="number">200</span><span class="number">-500</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Mock-valid-template-data"><a href="#Mock-valid-template-data" class="headerlink" title="Mock.valid(template,data)"></a>Mock.valid(template,data)</h4><p>这个函数用来判断，数据模板和数据是否一样。</p><h4 id="Mock-toJSONShema-template"><a href="#Mock-toJSONShema-template" class="headerlink" title="Mock.toJSONShema(template)"></a>Mock.toJSONShema(template)</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> template = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name|1-3'</span>:<span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> tjs = Mock.toJSONSchema(tempalte);</span><br></pre></td></tr></table></figure><h4 id="Mock-Random"><a href="#Mock-Random" class="headerlink" title="Mock.Random"></a>Mock.Random</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Random = Mock.Random;</span><br><span class="line"><span class="keyword">var</span> em1 = Mock.email();</span><br><span class="line"><span class="keyword">var</span> em2 = Mock.mock(<span class="string">'@email'</span>);</span><br><span class="line"><span class="keyword">var</span> em3 = Mock.mock(&#123;</span><br><span class="line">    email:<span class="string">'@email'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="mock的原理"><a href="#mock的原理" class="headerlink" title="mock的原理"></a>mock的原理</h2><ol><li><p>Mock主要是关于测被测体与外部的交互逻辑。一般是指在不同场景下多次的与外部交互。</p></li><li><p>当外部依赖是硬件，或者外部程序没有准备好的情况下，Mock就能帮助完成单元测试。</p></li><li><p>Mock的作用就是能通过设置输入输出值，让被测代码的各种工作场景都可以被测试覆盖。</p></li><li><p>为方便测试，程序设计应该采用依赖倒置原则，让被测试类依赖于接口，Mock类实现该接口。</p></li></ol><p><strong>被测类通过调用接口最终调用到Mock类，完成测试。而被测试类可以不作任何修改就能在实际系统里工作。<br>这就是使用TDD能很自然的使产品代码于外部依赖松耦合。</strong></p><p>参考：</p><ul><li><a href="https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%85%B3%E4%BA%8Emock.md" target="_blank" rel="noopener">王老师的总结</a></li><li><a href="https://www.zhihu.com/question/35436669/answer/62753889" target="_blank" rel="noopener">https://www.zhihu.com/question/35436669/answer/62753889</a></li><li><a href="https://segmentfault.com/a/1190000010211622" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010211622</a></li><li><a href="https://blog.csdn.net/ibelieve1974/article/details/55220015" target="_blank" rel="noopener">深入理解Mock工作原理</a></li></ul>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对象与数组的深浅拷贝</title>
      <link href="/2018/06/13/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2018/06/13/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<!-- <img src="https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg" style="width:56%"></img> --><p>使用场景：</p><p>引用类型（Object, Array, Function, Date, Math, RegExp, Error）指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，由该位置保存对象。</p><p>当在实际开发中，如果使用 = 来给引用类型的数据赋值，由于指向的都是同一个对象，所以会修改原对象。于是需要拷贝一个副本，对副本进行数据操作<br><a id="more"></a></p><h2 id="Javascript中的深拷贝与浅拷贝为什么会有区别？"><a href="#Javascript中的深拷贝与浅拷贝为什么会有区别？" class="headerlink" title="Javascript中的深拷贝与浅拷贝为什么会有区别？"></a>Javascript中的深拷贝与浅拷贝为什么会有区别？</h2><p>对于这个问题，可以考虑从深拷贝和浅拷贝的使用或者起源说起，也就是为什么会出现这个问题。</p><p>首先了解一些javascript的基本知识。</p><h3 id="1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。"><a href="#1-javascript变量包含两种不同数据类型的值：基本类型和引用类型。" class="headerlink" title="1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。"></a>1.javascript变量包含两种不同数据类型的值：基本类型和引用类型。</h3><p><strong>基本类型</strong> 值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：</p><p>number、string、boolean、null、undefined、symbol</p><p><strong>引用类型</strong> 值指那些可能由多个值构成的对象，只有一种如下：</p><p>object（Array也属于对象）</p><p>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br>引用类型的值是保存在内存中的对象。与其他语言不同，<strong>JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。</strong></p><h3 id="2-javascript的变量的存储方式–栈（stack）和堆（heap）"><a href="#2-javascript的变量的存储方式–栈（stack）和堆（heap）" class="headerlink" title="2.javascript的变量的存储方式–栈（stack）和堆（heap）"></a>2.javascript的变量的存储方式–栈（stack）和堆（heap）</h3><p><strong>栈</strong> ：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址<br><strong>堆</strong> ：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。<br><!-- <img src="https://pic2.zhimg.com/80/v2-e79fc1f234a9b78d4241e3187dffa11b_hd.jpg"></img> --></p><h3 id="3-javascript值传递与址传递"><a href="#3-javascript值传递与址传递" class="headerlink" title="3.javascript值传递与址传递"></a>3.javascript值传递与址传递</h3><p>基本类型与引用类型最大的区别实际就是 <strong>传值与传址的区别</strong><br>值传递：基本类型采用的是值传递。每次为基本类型赋值时，改变的就是当前值本身。<br>址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。每次使用=为引用类型赋值时，改变的是把新对象指向的地址值指向旧对象的地址值。</p><p>所以当<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var obj</span>=&#123;&#125;;</span><br><span class="line"><span class="attribute">var newObj</span>=obj;</span><br><span class="line"><span class="attribute">newObj</span>=&#123;<span class="string">"name"</span>:<span class="string">"shengyu"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>时候，打印出obj的值，会发现obj的值与newObj一起被修改了</p><p>那么如何解决上面出现的问题，就是使用浅拷贝或者深拷贝了。</p><h2 id="什么是深拷贝-浅拷贝？"><a href="#什么是深拷贝-浅拷贝？" class="headerlink" title="什么是深拷贝/浅拷贝？"></a>什么是深拷贝/浅拷贝？</h2><p>本文认为<br>浅拷贝：浅拷贝是复制引用，复制后的引用都是指向同一个对象的实例，<strong>彼此之间的操作会互相影响</strong>。<br>深拷贝：深拷贝不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象 <strong>是完全隔离的</strong>。<br>由深复制的定义来看，深复制要求如果源对象存在对象属性，那么需要进行递归复制，从而 <strong>保证复制的对象与源对象完全隔离</strong> 。然而，<em>还有一种可以说处在浅复制和深复制的粒度之间，也是jQuery的extend方法在deep参数为false时所谓的“浅复制”，这种复制只进行一个层级的复制：即如果源对象中存在对象属性，那么复制的对象上也会引用相同的对象。这不符合深复制的要求，但又比简单的复制引用的复制粒度有了加深</em>。</p><h2 id="如何对常见引用类型进行深-浅拷贝？"><a href="#如何对常见引用类型进行深-浅拷贝？" class="headerlink" title="如何对常见引用类型进行深/浅拷贝？"></a>如何对常见引用类型进行深/浅拷贝？</h2><p><em>本文认为，浅复制就是简单的引用复制，这种情况较很简单，通过如下代码简单理解一下</em><br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var src = &#123;</span><br><span class="line">       <span class="built_in">name</span>:<span class="string">"src"</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//复制一份src对象的应用</span></span><br><span class="line">   var target = src;</span><br><span class="line">   target.<span class="built_in">name</span> = <span class="string">"target"</span>;</span><br><span class="line">   console.<span class="built_in">log</span>(src.<span class="built_in">name</span>);   <span class="comment">//输出 "target"</span></span><br></pre></td></tr></table></figure></p><p>target对象只是src对象的引用值的复制，因此target的改变也会影响src。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组的浅拷贝"><a href="#数组的浅拷贝" class="headerlink" title="数组的浅拷贝"></a>数组的浅拷贝</h4><ul><li>拷贝原数组的引用，这是最简单的浅拷贝。</li></ul><h4 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h4><ul><li>Array的slice和concat方法</li></ul><p>Array的slice和concat方法都会返回一个新的数组实例，但是这两个方法 <strong>对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制</strong>，通过以下代码进行理解：<br>concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = [<span class="string">'darko'</span>, &#123;<span class="attr">age</span>: <span class="number">22</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> o2 = o1.slice(); <span class="comment">// 根据Array.prototype.slice()的特性，这里会返回一个o1的深拷贝对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// =&gt; false，说明o2拷贝的是o1的一个实例</span></span><br><span class="line"></span><br><span class="line">o2[<span class="number">0</span>] = <span class="string">'lee'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1[<span class="number">0</span>]); <span class="comment">// =&gt; "darko" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响</span></span><br><span class="line"></span><br><span class="line">o2[<span class="number">1</span>].age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1[<span class="number">1</span>].age); <span class="comment">// =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响，属于浅拷贝</span></span><br></pre></td></tr></table></figure><p>通过代码的输出可以看出concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象的浅拷贝"><a href="#对象的浅拷贝" class="headerlink" title="对象的浅拷贝"></a>对象的浅拷贝</h4><ul><li>拷贝原对象的引用，这是最简单的浅拷贝。</li></ul><h4 id="对象的深拷贝"><a href="#对象的深拷贝" class="headerlink" title="对象的深拷贝"></a>对象的深拷贝</h4><ul><li>(1) JSON对象的parse和stringify<br>JSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深复制</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var source = &#123;</span><br><span class="line">    <span class="keyword">name</span>:<span class="string">"source"</span>,</span><br><span class="line">    child:&#123;</span><br><span class="line">        <span class="keyword">name</span>:<span class="string">"child"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var <span class="keyword">target</span> = JSON.parse(JSON.stringify(source));</span><br><span class="line">//改变<span class="keyword">target</span>的<span class="keyword">name</span>属性</span><br><span class="line"><span class="keyword">target</span>.<span class="keyword">name</span> = <span class="string">"target"</span>;</span><br><span class="line">console.<span class="built_in">log</span>(source.<span class="keyword">name</span>);   //source</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">target</span>.<span class="keyword">name</span>);   //<span class="keyword">target</span></span><br><span class="line">//改变<span class="keyword">target</span>的child</span><br><span class="line"><span class="keyword">target</span>.child.<span class="keyword">name</span> = <span class="string">"target child"</span>;</span><br><span class="line">console.<span class="built_in">log</span>(source.child.<span class="keyword">name</span>);  //child</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">target</span>.child.<span class="keyword">name</span>);  //<span class="keyword">target</span> child</span><br></pre></td></tr></table></figure><p>从代码的输出可以看出，复制后的target与source是完全隔离的，二者不会相互影响。<br><em>这个方法使用较为简单，可以满足基本的深复制需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深复制(而且会直接丢失相应的值)，同时如果对象中存在循环引用的情况也无法正确处理</em></p><ul><li>jQuery中的extend方法可以用来扩展对象，这个方法可以传入一个参数:deep(true or false)，表示是否执行深复制(如果是深复制则会执行递归复制)，我们首先看一下jquery中的源码(1.9.1)<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.extend = function() &#123;</span><br><span class="line">    var <span class="keyword">options</span>, name, src, <span class="keyword">copy</span>, copyIsArray, clone,</span><br><span class="line">        target = arguments[<span class="number">0</span>] || &#123;&#125;,</span><br><span class="line">        i = <span class="number">1</span>,</span><br><span class="line">        length = arguments.length,</span><br><span class="line">        deep = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle a deep copy situation</span></span><br><span class="line">    <span class="keyword">if</span> ( typeof target === <span class="string">"boolean"</span> ) &#123;</span><br><span class="line">        deep = target;</span><br><span class="line">        target = arguments[<span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">        <span class="comment">// skip the boolean and the target</span></span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></span><br><span class="line">    <span class="keyword">if</span> ( typeof target !== <span class="string">"object"</span> &amp;&amp; !jQuery.isFunction(target) ) &#123;</span><br><span class="line">        target = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// extend jQuery itself if only one argument is passed</span></span><br><span class="line">    <span class="keyword">if</span> ( length === i ) &#123;</span><br><span class="line">        target = <span class="keyword">this</span>;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</span><br><span class="line">        <span class="comment">// Only deal with non-null/undefined values</span></span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">options</span> = arguments[ i ]) != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="comment">// Extend the base object</span></span><br><span class="line">            <span class="keyword">for</span> ( name in <span class="keyword">options</span> ) &#123;</span><br><span class="line">                src = target[ name ];</span><br><span class="line">                <span class="keyword">copy</span> = <span class="keyword">options</span>[ name ];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Prevent never-ending loop</span></span><br><span class="line">                <span class="keyword">if</span> ( target === <span class="keyword">copy</span> ) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Recurse if we're merging plain objects or arrays</span></span><br><span class="line">                <span class="keyword">if</span> ( deep &amp;&amp; <span class="keyword">copy</span> &amp;&amp; ( jQuery.isPlainObject(<span class="keyword">copy</span>) || (copyIsArray = jQuery.isArray(<span class="keyword">copy</span>)) ) ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( copyIsArray ) &#123;</span><br><span class="line">                        copyIsArray = <span class="keyword">false</span>;</span><br><span class="line">                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Never move original objects, clone them</span></span><br><span class="line">                    target[ name ] = jQuery.extend( deep, clone, <span class="keyword">copy</span> );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Don't bring in undefined values</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">copy</span> !== undefined ) &#123;</span><br><span class="line">                    target[ name ] = <span class="keyword">copy</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the modified object</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个方法是jQuery中重要的基础方法之一，可以用来扩展jQuery对象及其原型，也是我们编写jQuery插件的关键方法，事实上这个方法基本的思路就是如果碰到array或者object的属性，那么就执行递归复制，这也导致对于Date,Function等引用类型，jQuery的extend也无法支持。下面我们大致分析一下这个方法：</p><p>（1）第1-6行定义了一些局部变量，这些局部变量将在以后用到，这种将函数中可能用到的局部变量先统一定义好的方式也就是“单var”模式</p><p>（2）第9-13行用来修正deep参数，jQuery的这个方法是将deep作为第一个参数传递的，因此这里就判断了第一个参数是不是boolean类型，如果是，那么就调整target和i值，i值表示第一个source对象的索引</p><p>（3）第17-19行修正了target对象，如果target的typeof操作符返回的不是对象，也不是函数，那么说明target传入的是一个基本类型，因此需要修正为一个空的对象字面量{}</p><p>（4）第22-25行来处理只传入了一个参数的情况，这个方法在传入一个参数的情况下为扩展jQuery对象或者其原型对象</p><p>（5）从27行开始使用for in去遍历source对象列表，因为extend方法是可以传入多个source对象，取出每一个source对象，然后再嵌套一个for in循环，去遍历某个source对象的属性</p><p>（6）第32行分别取出了target的当前属性和source的当前属性，35-38行的主要作用在于防止深度遍历时的死循环。然而如果source对象本身存在循环引用的话，extend方法依然会报堆栈溢出的错误</p><p>（7）第41行的if用来处理深复制的情况，如果传入的deep参数为true，并且当前的source属性值是plainObject(使用对象字面量创建的对象或new Object()创建的对象)或数组，则需要进行递归深复制</p><p>（8）第42-48根据copy的类型是plainObject还是Array，对src进行处理：如果copy是数组，那么src如果不是数组，就改写为一个空数组；如果copy是chainObject，那么src如果不是chainObject，就改写为{}</p><p>（9）如果41行的if条件不成立，那么直接把target的src属性用copy覆盖</p><p>jQuery的extend方法使用基本的递归思路实现了深度复制，但是这个方法也无法处理source对象内部循环引用的问题，同时对于Date、Function等类型的值也没有实现真正的深度复制，但是这些类型的值在重新定义时一般都是直接覆盖，所以也不会对源对象造成影响，因此一定程度上也符合深复制的条件</p><ul><li>(2) 自己实现一个copy方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//util作为判断变量具体类型的辅助模块</span></span><br><span class="line">   <span class="keyword">var</span> util = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> class2type = &#123;&#125;;</span><br><span class="line">       [<span class="string">"Null"</span>,<span class="string">"Undefined"</span>,<span class="string">"Number"</span>,<span class="string">"Boolean"</span>,<span class="string">"String"</span>,<span class="string">"Object"</span>,<span class="string">"Function"</span>,<span class="string">"Array"</span>,<span class="string">"RegExp"</span>,<span class="string">"Date"</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">           class2type[<span class="string">"[object "</span>+ item + <span class="string">"]"</span>] = item.toLowerCase();</span><br><span class="line">       &#125;)</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">obj, type</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getType(obj) === type;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> class2type[<span class="built_in">Object</span>.prototype.toString.call(obj)] || <span class="string">"object"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">           isType:isType,</span><br><span class="line">           getType:getType</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj,deep</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//如果obj不是对象，那么直接返回值就可以了</span></span><br><span class="line">       <span class="keyword">if</span>(obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">"object"</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> obj;</span><br><span class="line">       &#125;</span><br><span class="line">　　　　<span class="comment">//定义需要的局部变脸，根据obj的类型来调整target的类型</span></span><br><span class="line">       <span class="keyword">var</span> i, target = util.isType(obj,<span class="string">"array"</span>) ? [] : &#123;&#125;,value,valueType;</span><br><span class="line">       <span class="keyword">for</span>(i <span class="keyword">in</span> obj)&#123; value = obj[i];</span><br><span class="line">           valueType = util.getType(value);</span><br><span class="line">　　　　　　　<span class="comment">//只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制</span></span><br><span class="line">           <span class="keyword">if</span>(deep &amp;&amp; (valueType === <span class="string">"array"</span> || valueType === <span class="string">"object"</span>))&#123;</span><br><span class="line">               target[i] = copy(value);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               target[i] = value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ES6中对象的浅拷贝"><a href="#ES6中对象的浅拷贝" class="headerlink" title="ES6中对象的浅拷贝"></a>ES6中对象的浅拷贝</h3><p>扩展运算符(…)用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123;a:<span class="number">3</span>,b:<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123;...z&#125;;</span><br><span class="line">n <span class="comment">//&#123;a:3,b:4&#125;&#125;</span></span><br></pre></td></tr></table></figure></p><p>原文：</p><ol><li><a href="https://blog.csdn.net/yiifaa/article/details/73438088" target="_blank" rel="noopener">快速浅拷贝一个数组</a></li><li><a href="https://www.zhihu.com/question/23031215" target="_blank" rel="noopener">https://www.zhihu.com/question/23031215</a></li><li><a href="https://www.cnblogs.com/tracylin/p/5346314.html" target="_blank" rel="noopener">推荐！</a></li><li><a href="https://segmentfault.com/a/1190000011492291" target="_blank" rel="noopener">JavaScript复制（合并）对象</a></li><li><a href="https://www.jianshu.com/p/35f9efe95fff" target="_blank" rel="noopener">ES6之扩展运算符与应用</a></li></ol>]]></content>
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React-Element中的StyleSheet.reset方法为何可以重置样式？</title>
      <link href="/2018/06/13/React-Element%E4%B8%AD%E7%9A%84StyleSheet.reset%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%87%8D%E7%BD%AE%E6%A0%B7%E5%BC%8F%EF%BC%9F/"/>
      <url>/2018/06/13/React-Element%E4%B8%AD%E7%9A%84StyleSheet.reset%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%87%8D%E7%BD%AE%E6%A0%B7%E5%BC%8F%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>在React-Element的Select组件中，一上来就来了行看不懂的代码，<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">StyleSheet</span><span class="selector-class">.reset</span>(`</span><br><span class="line">  <span class="selector-class">.ishow-select-dropdown</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">`)</span><br></pre></td></tr></table></figure></p><p>发现该方法可以实现，在当前页面插入带着样式的style标签，来实现对css的覆盖，心生疑虑，这到底是react的API还是es7黑魔法？</p><p>而后发现 Style只是从外部引入的一个模块，代码 动态添加了style节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">exports.reset = <span class="function"><span class="params">css</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>); <span class="comment">//通过指定名称创建一个style元素</span></span><br><span class="line"></span><br><span class="line">  style.type = <span class="string">'text/css'</span>;</span><br><span class="line">  <span class="comment">//1.必需的 type 属性规定样式表的 MIME 类型。  2.type 属性指示 &lt;style&gt; 与 &lt;/style&gt; 标签之间的内容。 3.值 "text/css" 指示内容是标准的 CSS。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (style.styleSheet)&#123;</span><br><span class="line">    style.styleSheet.cssText = css;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line">  &#125;</span><br><span class="line">«»</span><br><span class="line">  (<span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]).appendChild(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被这波原生js操作晃瞎了眼呀~只好再复习下原生用法</p><ul><li><a href="http://www.w3school.com.cn/tags/att_style_type.asp" target="_blank" rel="noopener">style 标签的 type 属性</a></li></ul>]]></content>
      
      <categories>
          
          <category> 十万个为什么 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React进阶之 使用mobx进行状态管理</title>
      <link href="/2018/06/11/React%E8%BF%9B%E9%98%B6%E4%B9%8B%20%E4%BD%BF%E7%94%A8mobx%E8%BF%9B%E8%A1%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2018/06/11/React%E8%BF%9B%E9%98%B6%E4%B9%8B%20%E4%BD%BF%E7%94%A8mobx%E8%BF%9B%E8%A1%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="http://cn.mobx.js.org/" target="_blank" rel="noopener">mobx中文文档</a></p></li><li><p><a href="https://codesandbox.io/s/2vmzpM0wK" target="_blank" rel="noopener">mobx todolist</a></p></li><li><p><a href="https://blog.csdn.net/u012125579/article/details/69400169" target="_blank" rel="noopener">mobx 在ReactJS项目中的运用</a></p></li></ul><a id="more"></a><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>任何源自应用状态的东西都应该自动地获得。</p><h4 id="与react的关系"><a href="#与react的关系" class="headerlink" title="与react的关系"></a>与react的关系</h4><p>react提供了优化UI渲染的机制，这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。mobx提供了优化应用状态与react组件同步的机制，这种机制就是使用响应式虚拟依赖状态图标，它只有在真正需要的时候才更新并且永远保持是最新的。</p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><h5 id="Observable-state（可观察的状态）"><a href="#Observable-state（可观察的状态）" class="headerlink" title="Observable state（可观察的状态）"></a>Observable state（可观察的状态）</h5><p> 通过使用@observable装饰器来给现有的数据结构（如对象、数组和类实例）添加可观察的功能。<br> 注：@observable是es.next的写法，在es5中，使用extendObservable()来实现。</p><h5 id="Computed-values（计算值）"><a href="#Computed-values（计算值）" class="headerlink" title="Computed values（计算值）"></a>Computed values（计算值）</h5><p> 定义在相关数据发生变化时自动更新的值，可通过@computed 装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用。</p><h5 id="Reactions（反应）"><a href="#Reactions（反应）" class="headerlink" title="Reactions（反应）"></a>Reactions（反应）</h5><ul><li><p>reactions在响应式编程和命令式编程之间建立沟通的桥梁。</p></li><li><p>reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新react组件数以修补dom等。</p></li><li><p>observer()会将组件转换为它们需要渲染的数据的衍生。<br>import {observer} from ‘mobx-react’</p></li><li>自定义reactions：<br>使用autorun、reaction、when函数即可简单的创建自定义reactions，用来满足具体场景。<h5 id="Actions-动作"><a href="#Actions-动作" class="headerlink" title="Actions(动作)"></a>Actions(动作)</h5></li><li>状态应该以某种状态来更新。</li></ul><h4 id="mobx会对什么作出响应？"><a href="#mobx会对什么作出响应？" class="headerlink" title="mobx会对什么作出响应？"></a>mobx会对什么作出响应？</h4><p>会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应。</p><h4 id="mobx的优点：（简单且可扩展）"><a href="#mobx的优点：（简单且可扩展）" class="headerlink" title="mobx的优点：（简单且可扩展）"></a>mobx的优点：（简单且可扩展）</h4><p>A.使用类和真正的引用 B.保证参照完整性 C.更简单的actions更便于维护 D.细粒度的可观测性是高效的 E.易操作性</p><h4 id="mobx要点-将一个应用变成响应式的步骤"><a href="#mobx要点-将一个应用变成响应式的步骤" class="headerlink" title="mobx要点 将一个应用变成响应式的步骤"></a>mobx要点 将一个应用变成响应式的步骤</h4><p>(1)定义状态并使其可观察<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable&#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="keyword">var</span> appState = observable(&#123; <span class="attr">timer</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure></p><p>(2)创建视图以响应状态的变化<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observer&#125; from <span class="symbol">'mobx</span>-react';</span><br><span class="line"></span><br><span class="line"> <span class="meta">@observer</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="type">Seconds</span> passed: &#123;<span class="keyword">this</span>.props.appState.timer&#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     onReset()&#123;</span><br><span class="line">         <span class="keyword">this</span>.props.appState.resetTimer();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">ReactDOM</span>.render(&lt;<span class="type">TimerView</span> appState=&#123;appState&#125; /&gt;,document.body);</span><br></pre></td></tr></table></figure></p><p>(3)更新状态（mobx帮助你以一种简单直观的方式来完成工作） appState.resetTimer = action(function reset(){ appState.timer = 0; })<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="name">action</span>(<span class="name">function</span> tick()&#123;</span><br><span class="line">    appState.timer += <span class="number">1</span><span class="comment">;</span></span><br><span class="line">),<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li><p>State(状态)</p><p>状态是驱动应用的数据。</p></li><li>Dervations(衍生)</li></ol><ul><li>任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。</li><li>衍生的存在形式：用户界面、衍生数据、后端集成</li><li>mobx区分了两种类型的衍生：Computed values 和 Reactions</li><li>黄金法则：如果想创建一个基于当前状态的值时，使用computed</li></ul><ol start="3"><li><p>Actions(动作)</p><p>动作是任一一段可以改变状态的代码。</p><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4></li></ol><ul><li><p>mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。</p><p>Action -&gt; State -&gt; Views</p></li><li><p>当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。</p></li><li><p>所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。</p></li><li><p>计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么他会自动被垃圾回收。</p></li><li><p>所有的计算值都应该是纯净的。它们不应该用来改变状态。</p></li></ul><h3 id="实际开发中遇到的问题及解决过程"><a href="#实际开发中遇到的问题及解决过程" class="headerlink" title="实际开发中遇到的问题及解决过程"></a>实际开发中遇到的问题及解决过程</h3><ol><li><p>@observable 数组</p><p>A.将数组变成可观察的对象时，map、forEach、indexOf、find等原生数组可用的方法，仍可以使用。</p><p>B.在控制台打印这个数组时，已经变成了ObservableArray,并不是Array对象了。</p><p>C.可以使用xxx.slice()将其变成原生数组。</p></li></ol><p>原文：</p><ol><li><a href="https://juejin.im/post/59f1c484f265da431c6f8940" target="_blank" rel="noopener">JS 装饰器（Decorator）场景实战</a></li><li><a href="https://github.com/wang-qingqing/accumulate/blob/f5779c2a734420200a34531d2ad7bdcfd91bd0ec/%E6%A1%86%E6%9E%B6%E7%B1%BB/REACT/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8EMobx.md" target="_blank" rel="noopener">王老师的积累</a></li><li><a href="https://gismanli.github.io/MobX-ZH/intro/overview.html" target="_blank" rel="noopener">MOBX中文文档</a></li></ol>]]></content>
      
      <categories>
          
          <category> 库/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>XMLHttpRequest</title>
      <link href="/2018/06/10/XMLHttpRequest/"/>
      <url>/2018/06/10/XMLHttpRequest/</url>
      <content type="html"><![CDATA[<h3 id="XMLHttpRequest-是什么？"><a href="#XMLHttpRequest-是什么？" class="headerlink" title="XMLHttpRequest 是什么？"></a>XMLHttpRequest 是什么？</h3><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p><h3 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h3><p>所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。</p><p>通过一行简单的 JavaScript 代码，我们就可以创建 XMLHttpRequest 对象。</p><h3 id="创建-XMLHttpRequest-对象的语法"><a href="#创建-XMLHttpRequest-对象的语法" class="headerlink" title="创建 XMLHttpRequest 对象的语法"></a>创建 XMLHttpRequest 对象的语法</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">xmlhttp</span>=new XMLHttpRequest()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">xmlhttp</span>=new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用-XMLHttpRequest-对象"><a href="#使用-XMLHttpRequest-对象" class="headerlink" title="使用 XMLHttpRequest 对象"></a>使用 XMLHttpRequest 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params">url</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    xmlhttp=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)&#123;<span class="comment">// code for all new browsers</span></span><br><span class="line">      xmlhttp=<span class="keyword">new</span> XMLHttpRequest(); <span class="comment">//创建xml对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject)&#123;<span class="comment">// code for IE5 and IE6</span></span><br><span class="line">      xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp!=<span class="literal">null</span>)&#123;</span><br><span class="line">          xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span>)&#123;<span class="comment">// 4 = "loaded" 整个请求过程已经完毕</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (xmlhttp.status==<span class="number">200</span>)&#123;请求的响应状态码 (例如, 状态码<span class="number">200</span> 表示一个成功的请求).</span><br><span class="line">                  <span class="comment">// ...our code here...TODO</span></span><br><span class="line">                  &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                  alert(<span class="string">"Problem retrieving XML data"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          xmlhttp.open(<span class="string">"GET"</span>,url,<span class="literal">true</span>);</span><br><span class="line">          xmlhttp.send(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      alert(<span class="string">"Your browser does not support XMLHTTP."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a></li><li><a href="http://www.w3school.com.cn/xml/xml_http.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xml/xml_http.asp</a></li></ul>]]></content>
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XMLHttpRequest </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ramda 函数库的使用</title>
      <link href="/2018/06/10/Ramda%20%E5%87%BD%E6%95%B0%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/10/Ramda%20%E5%87%BD%E6%95%B0%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="http://www.ruanyifeng.com/blog/2017/03/ramda.html" target="_blank" rel="noopener">Ramda 函数库参考教程</a></li><li><a href="https://ramdajs.com/docs/" target="_blank" rel="noopener">Ramda文档</a></li></ol>]]></content>
      
      <categories>
          
          <category> 库/框架 </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ramda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端自动化测试探索</title>
      <link href="/2018/06/04/JavaScript-test-framework/"/>
      <url>/2018/06/04/JavaScript-test-framework/</url>
      <content type="html"><![CDATA[<h3 id="常用的前端测试工具一览"><a href="#常用的前端测试工具一览" class="headerlink" title="常用的前端测试工具一览"></a>常用的前端测试工具一览</h3><p>前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为 <strong>测试框架</strong>、<strong>断言库</strong>、<strong>测试覆盖率工具</strong> 等几类。在正式开始本文之前，我们先来大致了解下它们：</p><h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。<br>测试一般分两种：BDD和TDD<br><a id="more"></a></p><ol><li>先介绍Test-Driven Development(TDD)即测试驱动开发，TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。国外使用这种开发模式较多，github上大型的开源项目，如果没跑过测试用例，大概是没人敢在生产环境中使用的。<br>测试驱动对开发过程的要求：</li></ol><ul><li>单元尽量解耦，否则单元不可测</li><li>开发前，先设计接口，再实现细节</li><li>便于回归和内部代码重构 (把所有单元测试，集成测试等都做好之后，实现重构就更加从容，可以一块一块进行)</li></ul><ol start="2"><li>BDD指的是Behavior Drive Development，也就是行为驱动开发。传统的开发模式中，客户很难从技术层面理解问题，开发人员很难从业务需求考虑问题，BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析需求，然后将这些需求写成一个个的故事(应用场景)。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，通过设定各种业务场景中该展示的状态、适用的事件，以及场景的执行结果，基本就完成了一个完整测试的定义。</li></ol><p>常见的测试框架有 <a href="https://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>, <a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>,以及本文要介绍的 <a href="https://facebook.github.io/jest/zh-Hans/" target="_blank" rel="noopener">Jest</a> 。</p><h3 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h3><p>断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 <a href="https://shouldjs.github.io/" target="_blank" rel="noopener">Should.js</a>, <a href="http://www.chaijs.com/" target="_blank" rel="noopener">Chai.js</a> 等。</p><h3 id="测试覆盖率工具"><a href="#测试覆盖率工具" class="headerlink" title="测试覆盖率工具"></a>测试覆盖率工具</h3><p>用于统计测试用例对代码的测试情况，生成相应的报表，比如 <a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a>。</p><h3 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h3><ol><li>为什么选择Jest<br>Jest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</li></ol><p>而作为一个面向前端的测试框架， Jest 可以利用其特有的<a href="https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content" target="_blank" rel="noopener">快照测试</a>功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。</p><p>此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。</p><ol start="2"><li>安装<br>Jest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Jest 的测试脚本名形如<em>.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的</em>.test.js 或.spec.js 文件、完成测试。</p><ol start="3"><li>基本使用</li><li>用例的表示<br>表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：<br>sum.js<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">sum</span>(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">module</span>.exports = <span class="built_in">sum</span>;</span><br></pre></td></tr></table></figure></li></ol><p>sum.test.js<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const sum = require('./sum')<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">test('adds <span class="number">1</span> + <span class="number">2</span> to equal <span class="number">3</span>', () =&gt; &#123;</span><br><span class="line">  //expect(<span class="name">sum</span>(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>)<span class="comment">;//成功</span></span><br><span class="line">  expect(<span class="name">sum</span>(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">5</span>)<span class="comment">;//失败  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>其中toBe(‘Hello world’)便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档<a href="https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。" target="_blank" rel="noopener">https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。</a><br>写完了用例，运行在项目目录下执行npm test，即可看到测试结果：<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg" alt=""><br>修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg" alt=""></p><ol start="5"><li>用例的预处理或后处理：<br>有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。</li></ol><ul><li>对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；</li><li>如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；</li><li>后处理，可以使用对应的 afterAll() 和 afterEach() 函数。</li><li>如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：</li></ul><p>checkAll.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> o=&#123;</span><br><span class="line">    foo:<span class="literal">true</span>,</span><br><span class="line">    bar:<span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports=obj();</span><br></pre></td></tr></table></figure></p><p>checkAll.test.js<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var testObject = <span class="built_in">require</span>(<span class="string">'./checkAll'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test testObject'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="regexp">//</span> 预处理操作</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'is foo'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       expect(testObject.foo).toBeTruthy();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'is not bar'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        expect(testObject.bar).toBeFalsy();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="regexp">//</span> 后处理操作</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>执行npm test<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg" alt=""></p><h3 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h3><p>Mocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.js内置的assert模块作为断言<br>让我们一起看看assert有哪些常见用法：</p><p>原文：</p><ul><li><a href="https://segmentfault.com/a/1190000004558796" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004558796</a></li><li><a href="https://zhuanlan.zhihu.com/p/28162082" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28162082</a></li></ul>]]></content>
      
      <categories>
          
          <category> 前端自动化测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jest </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React基础之 父组件调用子组件的方法</title>
      <link href="/2018/06/02/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/06/02/React%E5%9F%BA%E7%A1%80%E4%B9%8B%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>直接上代码~~<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">     render() &#123;</span><br><span class="line">         <span class="keyword">return</span>(</span><br><span class="line">             &lt;div&gt;</span><br><span class="line">                 &lt;<span class="type">Child</span> alias=&#123;<span class="keyword">this</span>.doSth&#125; /&gt;&lt;br/&gt;</span><br><span class="line">                 &lt;button onClick=&#123;<span class="keyword">this</span>.click&#125; &gt;父组件click&lt;/button&gt;</span><br><span class="line">             &lt;/div&gt;</span><br><span class="line">         )</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     doSth = (ref) =&gt; &#123;    <span class="comment">//获取子组件的作用域</span></span><br><span class="line">         <span class="keyword">this</span>.anything = ref</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     click = (e) =&gt; &#123;</span><br><span class="line">         <span class="keyword">this</span>.anything.myName()</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">     componentDidMount()&#123;</span><br><span class="line">         <span class="keyword">this</span>.props.alias(<span class="keyword">this</span>)  <span class="comment">//子组件中的this作为参数传入</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     myName = () =&gt; alert(<span class="symbol">'click</span> me ')</span><br><span class="line"></span><br><span class="line">     render() &#123;</span><br><span class="line">         <span class="keyword">return</span> ('我是子组件')</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>简化下代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">      <span class="keyword">return</span>(</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">              &lt;<span class="type">Child</span> alias=&#123;(ref)=&gt;&#123;<span class="keyword">this</span>.anything = ref&#125;&#125;/&gt;&lt;br/&gt;</span><br><span class="line">              &lt;button onClick=&#123;()=&gt;&#123;<span class="keyword">this</span>.anything.myName()&#125;&#125; &gt;父组件click&lt;/button&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">      <span class="keyword">this</span>.props.alias(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myName = () =&gt; alert(<span class="symbol">'click</span> me ')</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">      <span class="keyword">return</span> ('我是子组件')</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面点击按钮,会弹出子组件的输出</p><p>原文：<br><a href="https://blog.csdn.net/hesonggg/article/details/79373565" target="_blank" rel="noopener">https://blog.csdn.net/hesonggg/article/details/79373565</a></p>]]></content>
      
      <categories>
          
          <category> 库/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vscode 之多设备配置同步</title>
      <link href="/2018/06/01/vscode%E4%B9%8B%E5%A4%9A%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE%E5%90%8C%E6%AD%A5/"/>
      <url>/2018/06/01/vscode%E4%B9%8B%E5%A4%9A%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h4 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h4><p>多台电脑同时使用的情况下，每次换电脑都重新配置一次就太麻烦了。得同步一把啊~</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。<br><a id="more"></a></p><p>这个配置并不复杂，下面来简单介绍下它的使用：</p><ul><li>在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync；</li><li>安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置；</li><li>如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入；</li><li>下载后等待安装，然后重启即可</li></ul><p>顺便纪念下2018儿童节的第一分钟，以及那些年我们吹过的牛逼<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/lufi.jpg" alt="我们的征途，是星辰大海"><br>原文：<br><a href="https://www.barretlee.com/blog/2017/04/21/something-about-vsc/" target="_blank" rel="noopener">https://www.barretlee.com/blog/2017/04/21/something-about-vsc/</a></p>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS效率工具之 Sass的常见用法</title>
      <link href="/2018/05/25/CSS%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E4%B9%8B%20Sass%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
      <url>/2018/05/25/CSS%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E4%B9%8B%20Sass%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><figure><br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/sass.jpg"><br></figure></p><h3 id="一-使用变量"><a href="#一-使用变量" class="headerlink" title="一 使用变量"></a>一 使用变量</h3><ol><li><p>可以使用变量：<br>声明变量的方式：使用$符号，$highlight-color  $sidebar-width</p></li><li><p>变量存在作用域<br>作用域使用方式：类似ES6的块级作用域，使用{}区分作用域</p><a id="more"></a></li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$nav-color</span>: <span class="number">#F90</span>;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="variable">$width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$nav-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#F90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>变量如何命名更好<br>sass的变量名可以包括中划线和下划线，如$highlight-color（更普遍）、$highlight_color ，在sass中，这两种写法的内容是互通的，比如，对sass来说$link-color和$link_color其实指向的是同一个变量，但是在sass中纯css部分不互通，比如类名、ID或属性名。</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$link</span>-<span class="attribute">color</span>: blue;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$link_color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-嵌套CSS"><a href="#二-嵌套CSS" class="headerlink" title="二 嵌套CSS"></a>二 嵌套CSS</h3><ol><li>可以避免书写重复的长串选择器</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">article</span> <span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: <span class="number">#333</span> &#125;</span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">1.4em</span> &#125;</span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">aside</span> &#123; <span class="attribute">background-color</span>: <span class="number">#EEE</span> &#125;</span><br><span class="line"> <span class="comment">/* 编译后 */</span></span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">article</span> <span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: <span class="number">#333</span> &#125;</span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">1.4em</span> &#125;</span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">aside</span> &#123; <span class="attribute">background-color</span>: <span class="number">#EEE</span> &#125;</span><br></pre></td></tr></table></figure><p>例外情况：<br>比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构 &amp;。</p><ol start="2"><li>父选择器的标识符&amp;</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  &amp;:hover &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123; <span class="attribute">color</span>: blue &#125;</span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span>:hover &#123; <span class="attribute">color</span>: red &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>群组选择器的嵌套(减少重复敲写)<br>.container h1, .container h2, .container h3 { margin-bottom: .8em }<br>可以写成：</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">container </span>&#123;</span><br><span class="line">  h1, h2, <span class="class">h3 </span>&#123;margin-bottom: <span class="number">.8</span>em&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>子组合选择器和同层组合选择器：&gt;、+和~ 都支持使用</li></ol><p>&gt;:子组合选择器,用于选择一个元素的直接子元素<br>+:同层相邻组合选择器+选择header元素后紧跟的p元素<br>~:同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> ~ <span class="selector-tag">article</span> &#123; <span class="attribute">border-top</span>: <span class="number">1px</span> dashed <span class="number">#ccc</span> &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>属性也可以嵌套</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: &#123;</span><br><span class="line">  style: solid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套属性的规则：<br>把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、导入SASS文件"><a href="#三、导入SASS文件" class="headerlink" title="三、导入SASS文件"></a>三、导入SASS文件</h3><p>css原生的特性@import规则，允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。</p><p>sass的@import规则，在生成css文件时，就会把相关样式导入进来。而且导入时，可以省略后缀的书写<br>如@import”sidebar”;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。</p><p>常用的就以上几点了，记录一下方便以后翻阅。</p><p>参考：<a href="https://www.sass.hk/guide/" target="_blank" rel="noopener">https://www.sass.hk/guide/</a></p>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sass </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6 Class的继承之super关键字</title>
      <link href="/2018/05/22/ES6_super/"/>
      <url>/2018/05/22/ES6_super/</url>
      <content type="html"><![CDATA[<p>super关键字有两种用法，既可以当成函数使用，也可以当成对象使用。在这两种情况下，它的用法完全不同。</p><p>在使用 JavaScript classes 时，你必须调用 super(); 方法才能在继承父类的子类中正确获取到类型的 this 。</p><ol><li>当super作为函数调用时<br>super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();<span class="comment">//调用父类的构造函数，否则会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。<br><a id="more"></a></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。<br><strong>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错</strong></p><p>提示：<br>new.target属性，一般用在构造函数之中，返回new命令作用于的那个构造函数。</p><ol start="2"><li>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  static ping() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="symbol">'pin</span>g';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  static pingpong() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.ping() + ' pong';<span class="comment">//在 静态方法 中，super指向父类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Computer</span>.pingpong(); <span class="comment">// 'ping pong'</span></span><br></pre></td></tr></table></figure><p>提示：<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法 <strong>不会被实例继承，而是直接通过类来调用</strong>，这就称为“静态方法”。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    console.log(<span class="keyword">super</span>.p()); <span class="comment">// 2 在普通方法中，super指向父类的原型对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = <span class="keyword">new</span> <span class="type">B</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。<br>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">this</span>.p = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  get m() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = <span class="keyword">new</span> <span class="type">B</span>();</span><br><span class="line">b.m <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p><p>如果属性定义在父类的原型对象上，super就可以取到。</p><p>ES6 规定,<strong>在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</strong>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">//this指向当前的子类实例--b</span></span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = <span class="keyword">new</span> <span class="type">B</span>();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>由于this指向子类实例，所以 <strong>如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性</strong>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;  <span class="comment">//b.x=2</span></span><br><span class="line">    <span class="keyword">super</span>.x = <span class="number">3</span>;  <span class="comment">//this.x=3</span></span><br><span class="line">    console.log(<span class="keyword">super</span>.x); <span class="comment">// undefined</span></span><br><span class="line">    console.log(<span class="keyword">this</span>.x); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = <span class="keyword">new</span> <span class="type">B</span>();</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super</a><br><a href="http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends" target="_blank" rel="noopener">http://es6.ruanyifeng.com/?search=prop&amp;x=0&amp;y=0#docs/class-extends</a></p>]]></content>
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React进阶之 React性能优化</title>
      <link href="/2018/05/21/React%E8%BF%9B%E9%98%B6%E4%B9%8B%20React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/05/21/React%E8%BF%9B%E9%98%B6%E4%B9%8B%20React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="react性能查看工具"><a href="#react性能查看工具" class="headerlink" title="react性能查看工具"></a>react性能查看工具</h3><h3 id="react组件的性能优化（渲染角度优化）"><a href="#react组件的性能优化（渲染角度优化）" class="headerlink" title="react组件的性能优化（渲染角度优化）"></a>react组件的性能优化（渲染角度优化）</h3><h3 id="利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性"><a href="#利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性" class="headerlink" title="利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性"></a>利用shouldComponentUpdate钩子函数优化react性能以及引入immutable库的必要性</h3><h3 id="谈一谈创建React-Component的几种方式"><a href="#谈一谈创建React-Component的几种方式" class="headerlink" title="谈一谈创建React Component的几种方式"></a>谈一谈创建React Component的几种方式</h3><h3 id="React-PureComponent-使用指南"><a href="#React-PureComponent-使用指南" class="headerlink" title="React PureComponent 使用指南"></a>React PureComponent 使用指南</h3><p>原文：<br><a href="https://www.cnblogs.com/penghuwan/p/6707254.html" target="_blank" rel="noopener">https://www.cnblogs.com/penghuwan/p/6707254.html</a><br><a href="https://www.cnblogs.com/Unknw/p/6431375.html" target="_blank" rel="noopener">https://www.cnblogs.com/Unknw/p/6431375.html</a><br><a href="http://www.wulv.site/2017-05-31/react-purecomponent.html" target="_blank" rel="noopener">http://www.wulv.site/2017-05-31/react-purecomponent.html</a><br><a href="https://www.jianshu.com/p/333f390f2e84" target="_blank" rel="noopener">https://www.jianshu.com/p/333f390f2e84</a></p>]]></content>
      
      <categories>
          
          <category> 库/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nodejs之npm&amp;package.json学习</title>
      <link href="/2018/05/18/Nodejs%E4%B9%8Bnpm&amp;package.json%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/05/18/Nodejs%E4%B9%8Bnpm&amp;package.json%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>作为前端，因为经常用到gulp，webpack等工具，所以我们最常见到的是npm和package.json，所以先总结一下它们俩的常用命令。</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">init</span> <span class="comment">//会询问package.json的各种信息，从而确认</span></span><br><span class="line"></span><br><span class="line">npm <span class="keyword">init</span> --y <span class="comment">//全部使用默认值,快速生成package.json</span></span><br></pre></td></tr></table></figure><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; ...</span><br><span class="line"></span><br><span class="line">npm <span class="keyword">install</span> &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; -g</span><br><span class="line"></span><br><span class="line">npm <span class="keyword">install</span> &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; <span class="comment">--save</span></span><br><span class="line"></span><br><span class="line">npm <span class="keyword">install</span> &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; <span class="comment">--save-dev</span></span><br><span class="line"></span><br><span class="line">npm <span class="keyword">install</span> &lt;pacakage <span class="keyword">name</span>&gt;  <span class="comment">--O //--save-optional  -B: --save-bundle  -E: --save-exact</span></span><br></pre></td></tr></table></figure><p>npm install <package name=""> -g :全局安装，需要注意的是全局模式并不是将一个模块安装包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用，-g的含义是将一个包安装为全局可用的可执行命令,例如gulp，webpack等。</package></p><p>–save与–save-dev的区别 :<br>–save:是生产环境中项目运行需要的依赖,比如代码所依赖的库或框架(Jquery,React等)，安装后被记录在package.json中的dependencies关键字下；<br>–save-dev:开发时候需要的依赖，安装后被记录在devDependencies关键字下。如一些开发时候需要用的gulp，webpack工具。</p><p>同样–O/B/E分别会被记录到对应的关键字下。</p><h3 id="更新依赖包"><a href="#更新依赖包" class="headerlink" title="更新依赖包"></a>更新依赖包</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> update</span><br><span class="line"></span><br><span class="line"><span class="built_in">npm</span> update  -g</span><br><span class="line"></span><br><span class="line"><span class="built_in">npm</span> outdated</span><br><span class="line"></span><br><span class="line"><span class="built_in">npm</span> outdated -g</span><br></pre></td></tr></table></figure><p>在项目目录下运行npm update可以升级项目中所用依赖到最新版本，而npm update -g则可以升级全局安装的依赖包到最新版。</p><p>npm outdated用于检查模块是否过时并列出。</p><h3 id="卸载依赖"><a href="#卸载依赖" class="headerlink" title="卸载依赖"></a>卸载依赖</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; ...</span><br><span class="line"></span><br><span class="line">npm <span class="keyword">uninstall</span> &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; -g</span><br><span class="line"></span><br><span class="line">npm <span class="keyword">uninstall</span> &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; <span class="comment">--save</span></span><br><span class="line"></span><br><span class="line">npm <span class="keyword">uninstall</span> &lt;<span class="keyword">package</span> <span class="keyword">name</span>&gt; <span class="comment">--save-dev</span></span><br></pre></td></tr></table></figure><p>使用npm uninstall可以卸载依赖，但是卸载后，在package.json中的纪录并不会被删除，要想在卸载依赖的同时删除在package.json中的纪录，需要在卸载的时候使用安装时的所有的选项，例如，如果安装时候使用了npm install <package name=""> –save则卸载的时候，同样使用npm uninstall <pacakage name=""> –save，而如果使用了–save-dev，卸载时候也需要加相同的选项。</pacakage></package></p><h3 id="使用自定义npm命令"><a href="#使用自定义npm命令" class="headerlink" title="使用自定义npm命令"></a>使用自定义npm命令</h3><p>在package.json中，有一个scripts关键字，只需要在该关键字内写入自定义命令以及对应执行的实际命令即可。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>:&#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"nonde ./test.js"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"gulp --gulpfile gulpfile-dev.js"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"gulp --gulpfile gulpfile-build.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的配置中，只要我们在终端运行npm dev就是运行了gulp –gulpfile gulpfile-dev.js，这样就省去了我们在终端输入很长的一段命令，非常方便。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>npm view <pacakage name="">可以查看包的package.json文件，如果只是看包的某个特性，在后面加上相应的key即可，例如npm v zepto version就是查看当前安装的zepto的版本，v是view的简写。</pacakage></p><p>npm ls可以分析出当前当前项目下能够通过模块路径找到的所有包，并生成依赖树。</p><p>npm doc <package name="">可以打开该依赖包的官网，其实就是打开了package.json中的homepage。</package></p><h2 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h2><p>在运行npm init后会生成package.json文件，该文件用于记录项目中所用到的依赖以及项目的配置信息（比如名称、版本、许可证等）。npm install命令根据这个配置文件自动下载项目运行和开发所需要的依赖。<br>一个比较完整的package.json文件如下：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"project"</span>, //包名</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.0.0"</span>, //版本号</span><br><span class="line">    <span class="string">"author"</span>: <span class="string">"张三"</span>, //包的作者的名字</span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"第一个node.js程序"</span>,//包的描述</span><br><span class="line">    <span class="string">"keywords"</span>:[<span class="string">"node.js"</span>,<span class="string">"javascript"</span>], //关键字</span><br><span class="line">    <span class="string">"repository"</span>: &#123; //包代码存放的地方，可以是git或者svn</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"https://path/to/url"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"license"</span>:<span class="string">"MIT"</span>,//开源许可证</span><br><span class="line">    <span class="string">"engines"</span>: &#123;<span class="string">"node"</span>: <span class="string">"0.10.x"</span>&#125;,</span><br><span class="line">    <span class="string">"bugs"</span>:&#123;<span class="string">"url"</span>:<span class="string">"http://path/to/bug"</span>,<span class="string">"email"</span>:<span class="string">"bug@example.com"</span>&#125;,</span><br><span class="line">    <span class="string">"contributors"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"李四"</span>,<span class="string">"email"</span>:<span class="string">"lisi@example.com"</span>&#125;],</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="string">"start"</span>: <span class="string">"node index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="string">"express"</span>: <span class="string">"latest"</span>,</span><br><span class="line">        <span class="string">"mongoose"</span>: <span class="string">"~3.8.3"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">        <span class="string">"grunt"</span>: <span class="string">"~0.4.1"</span>,</span><br><span class="line">        <span class="string">"grunt-contrib-concat"</span>: <span class="string">"~0.3.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>小标签1：如何为代码选择开源许可证，这是一个问题。<br>世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是阮一峰老师制作的中文版，请点击看大图。<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/license.png" alt=""></li><li><p>engines</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可选字段。既可以指定node版本:</span><br><span class="line"> &#123; <span class="string">"engines"</span> : &#123;<span class="string">"node"</span> : <span class="string">"&gt;=0.10.3 &lt;0.12"</span> &#125; &#125;</span><br><span class="line">也可以指定npm版本：</span><br><span class="line"> &#123; <span class="string">"engines"</span> : &#123;<span class="string">"npm"</span> : <span class="string">"~1.0.20"</span> &#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包.<br>示例如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"scripts"</span>:&#123;</span><br><span class="line"></span><br><span class="line">    “<span class="keyword">install</span>”:<span class="string">"install.js"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">"test"</span>:<span class="string">"test.js"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果该字段不存在，则node会检查目录下的index.js，index.node，index.json作为默认入口。</p></li></ol><h3 id="使用淘宝-NPM-镜像"><a href="#使用淘宝-NPM-镜像" class="headerlink" title="使用淘宝 NPM 镜像"></a>使用淘宝 NPM 镜像</h3><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p><p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p><p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g cnpm --registry=https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure></p><p>这样就可以使用 cnpm 命令来安装模块了：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">install</span> [<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure></p><h3 id="NPM-常用命令"><a href="#NPM-常用命令" class="headerlink" title="NPM 常用命令"></a>NPM 常用命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NPM提供了很多命令，例如<span class="keyword">install</span>和publish，使用npm <span class="keyword">help</span>可查看所有命令。</span><br><span class="line"></span><br><span class="line">NPM提供了很多命令，例如<span class="keyword">install</span>和publish，使用npm <span class="keyword">help</span>可查看所有命令。</span><br><span class="line"></span><br><span class="line">使用npm <span class="keyword">help</span> &lt;command&gt;可查看某条命令的详细帮助，例如npm <span class="keyword">help</span> <span class="keyword">install</span>。</span><br><span class="line"></span><br><span class="line">在package.json所在目录下使用npm <span class="keyword">install</span> . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</span><br><span class="line"></span><br><span class="line">使用npm <span class="keyword">update</span> &lt;<span class="keyword">package</span>&gt;可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</span><br><span class="line"></span><br><span class="line">使用npm <span class="keyword">update</span> &lt;<span class="keyword">package</span>&gt; -g可以把全局安装的对应命令行程序更新至最新版。</span><br><span class="line"></span><br><span class="line">使用npm <span class="keyword">cache</span> <span class="keyword">clear</span>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</span><br><span class="line"></span><br><span class="line">使用npm unpublish &lt;<span class="keyword">package</span>&gt;@&lt;<span class="keyword">version</span>&gt;可以撤销发布自己发布过的某个版本代码。</span><br></pre></td></tr></table></figure><p>原文：<br><a href="https://segmentfault.com/a/1190000007624021" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007624021</a><br><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a><br><a href="https://www.runoob.com/nodejs/nodejs-npm.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-npm.html</a></p>]]></content>
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flex布局从懵逼到运用</title>
      <link href="/2018/05/06/flex%E5%B8%83%E5%B1%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%90%E7%94%A8/"/>
      <url>/2018/05/06/flex%E5%B8%83%E5%B1%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%90%E7%94%A8/</url>
      <content type="html"><![CDATA[<figure><br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png"><br></figure><p>本文包括了Flex布局的语法介绍，以及几种运用Flex布局实现的实例，涵盖了常见的使用场景。</p><h3 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>行内元素也可以使用 Flex 布局。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Webkit 内核的浏览器，必须加上-webkit前缀。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<strong>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</strong>。</p><h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flex.png"><br>容器默认存在两根轴，水平的叫做 <strong>主轴</strong>(main axis),垂直的叫做 <strong>交叉轴</strong>(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h3 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">1</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">2</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">3</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>以下6个属性设置在容器上<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span></span><br><span class="line"><span class="attribute">flex-wrap</span></span><br><span class="line"><span class="attribute">flex-flow</span></span><br><span class="line"><span class="attribute">justify-content</span></span><br><span class="line"><span class="attribute">align-items</span></span><br><span class="line"><span class="attribute">align-content</span></span><br></pre></td></tr></table></figure></p><h4 id="1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值"><a href="#1-flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值" class="headerlink" title="1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值"></a>1. flex-direction属性决定主轴的方向（即项目的排列方向），有4个属性值</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>row(默认值)：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><h4 id="2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值"><a href="#2-flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值" class="headerlink" title="2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值"></a>2. flex-wrap属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。可能取3个值</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nowrap（默认）：不换行。</li><li>wrap：换行，第一行在上方。</li><li>wrap-reverse：换行，第一行在下方。</li></ul><h4 id="3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap"><a href="#3-flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap" class="headerlink" title="3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap"></a>3. flex-flow属性，是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-justify-content属性，定义了项目在-主轴-上的对齐方式"><a href="#4-justify-content属性，定义了项目在-主轴-上的对齐方式" class="headerlink" title="4.justify-content属性，定义了项目在 主轴 上的对齐方式"></a>4.justify-content属性，定义了项目在 <strong>主轴</strong> 上的对齐方式</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">  justify-content: flex-start | flex-<span class="keyword">end</span> | center | <span class="literal">space</span>-<span class="keyword">between</span> | <span class="literal">space</span>-<span class="keyword">around</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul><h4 id="5-align-items属性-定义项目在-交叉轴-上如何对齐"><a href="#5-align-items属性-定义项目在-交叉轴-上如何对齐" class="headerlink" title="5.align-items属性,定义项目在 交叉轴 上如何对齐"></a>5.align-items属性,定义项目在 <strong>交叉轴</strong> 上如何对齐</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">  align-items: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h4 id="6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。"><a href="#6-align-content属性-定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。" class="headerlink" title="6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。"></a>6.align-content属性,定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">space</span>-between | <span class="type">space</span>-around | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h4 id="1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。"><a href="#1-order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。" class="headerlink" title="1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。"></a>1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。"><a href="#2-flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。" class="headerlink" title="2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。"></a>2.flex-grow属性,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h4 id="3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。"><a href="#3-flex-shrink属性-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。" class="headerlink" title="3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。"></a>3.flex-shrink属性,定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><h4 id="4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）"><a href="#4-flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）" class="headerlink" title="4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）"></a>4.flex-basis属性,定义了在分配多余空间之前，项目占据的主轴空间（main size）</h4><p>浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h4 id="5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。"><a href="#5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。" class="headerlink" title="5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。"></a>5.flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt; &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h4 id="6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式"><a href="#6-align-self属性-属性允许单个项目有与其他项目不一样的对齐方式" class="headerlink" title="6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式."></a>6.align-self属性,属性允许单个项目有与其他项目不一样的对齐方式.</h4><p>可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: <span class="built_in">auto</span> | <span class="type">flex</span>-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><p>flex布局练习代码：<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/flexDemo.jpg" alt=""><br>HTML:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">1</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">2</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">3</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">4</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">5</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">6</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">7</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">8</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">9</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">10</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;<span class="number">11</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><p>CSS:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="comment">/* height: 400px; */</span></span><br><span class="line">    <span class="attribute">background-color</span>: blanchedalmond;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">    <span class="comment">/* 默认 */</span></span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">    <span class="attribute">align-content</span>: space-around;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0, 0, 255, 0.315)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-of-type(1)</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">7</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-of-type(2)</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*flex-shrink为0时，即使空间不够，也不缩小*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-of-type(3)</span> &#123;</span><br><span class="line">    <span class="comment">/* order: 1; */</span></span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-of-type(4)</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-of-type(5)</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">70px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="五、flex运用实例"><a href="#五、flex运用实例" class="headerlink" title="五、flex运用实例"></a>五、flex运用实例</h3><ol><li>如何使用flex布局绘制筛子的6个面？</li></ol><ol start="2"><li><p>网格布局</p></li><li><p>圣杯布局</p></li><li><p>输入框组件的布局</p></li><li><p>悬挂式布局</p></li><li><p>固定的底栏</p></li><li><p>流式布局</p></li></ol><p>未完待续…</p><p>原文：阮老师的博客</p><ul><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>node版本切换工具的常用命令</title>
      <link href="/2018/05/05/node%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%E5%B7%A5%E5%85%B7nvm%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/05/05/node%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%E5%B7%A5%E5%85%B7nvm%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>使用场景：同时处理几个项目时，依赖的node版本不同，使用nvm工具，可以实现快速切换。</p><ul><li>nvm install <version>  ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4</version></li><li>nvm uninstall <version>  ## 删除已安装的指定版本，语法与install类似</version></li><li>nvm use <version>  ## 切换使用指定的版本node</version></li><li>nvm ls  ## 列出所有安装的版本</li><li>nvm ls-remote  ## 列出所以远程服务器的版本（官方node version list）</li><li>nvm current  ## 显示当前的版本</li><li>nvm alias <name> <version>  ## 给不同的版本号添加别名</version></name></li><li>nvm unalias <name>  ## 删除已定义的别名</name></li><li>nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包</version></li></ul>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>less配合vscode使用的配置</title>
      <link href="/2018/05/05/less%E9%85%8D%E5%90%88vscode%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/05/05/less%E9%85%8D%E5%90%88vscode%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>使用场景：写jquery老项目懒得配置css预编译的情况下，安装即用，提升效率。</p><ol><li><p>安装 easy less</p></li><li><p>安装Preview on web server</p></li><li><p>在.less 文件最后一行敲下回车，就可以实现编译main.less到main.css了。</p></li></ol><p>如果不生效，就试试下面这个：</p><ol><li><p>安装less转码器</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g <span class="keyword">node</span><span class="title">-sass</span> less</span><br></pre></td></tr></table></figure></li><li><p>在css文件下建个less文件（后缀名为less）</p></li><li><p>Ctrl + Shift + P（配置任务运行器）<br>选择Others<br>替换内容为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment">// Less configuration</span></span><br><span class="line"><span class="number">2.</span> &#123;</span><br><span class="line"><span class="number">3.</span> <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line"><span class="number">4.</span> <span class="string">"command"</span>: <span class="string">"lessc"</span>,</span><br><span class="line"><span class="number">5.</span> <span class="string">"isShellCommand"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="number">6.</span> <span class="string">"args"</span>: [<span class="string">"css/名字.less"</span>, <span class="string">"css/名字.css"</span>]</span><br><span class="line"><span class="number">7.</span> &#125;</span><br><span class="line"><span class="number">8.</span> &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Less </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端技能积累</title>
      <link href="/2018/05/02/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%E7%A7%AF%E7%B4%AF/"/>
      <url>/2018/05/02/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%E7%A7%AF%E7%B4%AF/</url>
      <content type="html"><![CDATA[<h3 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h3><ol><li>如何实现一个三栏布局，要求两边固定宽度，中间宽度自适应？</li><li>圣杯布局 双飞翼布局 flex布局分别是什么？</li><li>css的几种垂直居中的方法</li></ol><a id="more"></a><h3 id="Javascript基础"><a href="#Javascript基础" class="headerlink" title="Javascript基础"></a>Javascript基础</h3><ol><li>js中的变量提升是什么原理？</li><li>标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？<ul><li>先冒泡还是先捕获？</li><li>各浏览器监听函数的写法是否一致？</li><li>冒泡和捕获的区别是什么？</li></ul></li><li>闭包的原理是什么？为什么会造成内存泄露？</li><li>XMLHttpRequest</li></ol><h3 id="前端缓存"><a href="#前端缓存" class="headerlink" title="前端缓存"></a>前端缓存</h3><ol><li><a href="http://www.cnblogs.com/Darren_code/archive/2011/11/24/Cookie.html" target="_blank" rel="noopener">cookie</a></li></ol><h3 id="HTTP协议-amp-缓存"><a href="#HTTP协议-amp-缓存" class="headerlink" title="HTTP协议 &amp; 缓存"></a>HTTP协议 &amp; 缓存</h3><ol><li>下面的状态码代表的是什么意思？200、204、301、302、304、404？</li><li>HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?</li><li>对运营商劫持有什么好的处理办法？</li></ol><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ol><li>富文本编辑器如何解决XSS问题？</li><li>为什么Restfal API不应当使用’Access-Cross-Origin:* ‘来实现跨域？</li></ol><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ol><li>Express 和 Koa有什么差别？</li><li>怎么在Node做CI测试？</li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol><li>Yslow 和 PageSpeed用过吗?记得其中多少规则？</li><li>CDN是什么?为什么能资源加速?</li><li>前端怎么样拿到DNS的查询时间？</li></ol><h3 id="设计-amp-交互-amp-体验"><a href="#设计-amp-交互-amp-体验" class="headerlink" title="设计&amp;交互&amp;体验"></a>设计&amp;交互&amp;体验</h3><ol><li>PNG 和 JPG 的区别是什么？</li></ol><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><ol><li>你使用过构建工具来编译前端代码吗?使用过 Grunt、Gulp、webpack、FIS中的一些吗？</li><li><a href="https://segmentfault.com/q/1010000008058766/a-1020000008058892" target="_blank" rel="noopener">Grunt、Gulp、webpack的区别是什么？</a></li><li><a href="https://segmentfault.com/a/1190000011383224" target="_blank" rel="noopener">webpack基本配置入门</a></li><li><a href="https://blog.csdn.net/u014445339/article/details/55517770" target="_blank" rel="noopener">AMD与CMD分别是什么？有什么区别？</a></li><li><a href="https://segmentfault.com/a/1190000003970448" target="_blank" rel="noopener">webpack是如何进行依赖管理的？</a></li></ol><h3 id="经验考察"><a href="#经验考察" class="headerlink" title="经验考察"></a>经验考察</h3><ol><li>你遇到过兼容性问题吗?最令你影响深刻的兼容问题什么?</li></ol><h3 id="框架类"><a href="#框架类" class="headerlink" title="框架类"></a>框架类</h3><ol><li><a href="https://segmentfault.com/a/1190000008102870" target="_blank" rel="noopener">React 常用面试题目与分析</a></li><li><a href="">Vue双向绑定原理</a></li></ol><h3 id="持续更新中······欢迎补充"><a href="#持续更新中······欢迎补充" class="headerlink" title="持续更新中······欢迎补充"></a>持续更新中······欢迎补充</h3>]]></content>
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Javascript </tag>
            
            <tag> 安全 </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复制知乎/简书的文本内容，为什么会自带版权声明？</title>
      <link href="/2018/05/01/%E5%A4%8D%E5%88%B6%E7%9F%A5%E4%B9%8E%E7%AE%80%E4%B9%A6%E7%9A%84%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%87%AA%E5%B8%A6%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%EF%BC%9F/"/>
      <url>/2018/05/01/%E5%A4%8D%E5%88%B6%E7%9F%A5%E4%B9%8E%E7%AE%80%E4%B9%A6%E7%9A%84%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%87%AA%E5%B8%A6%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>实现思路：</p><ol><li>答案区域监听copy事件，并阻止这个事件的默认行为。</li><li>获取选中的内容<strong>window.getSelection()</strong>后加上版权信息，然后设置到剪切板<strong>clipboardData.setData()</strong>。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"copyText"</span>&gt;</span>我是一段即将被复制的话<span class="tag">&lt;<span class="name">b</span>&gt;</span>test<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">setClipboardText</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">        e.preventDefault();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'#copyText'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> htmlData = <span class="string">'&lt;div&gt;著作权归作者所有。&lt;br /&gt;'</span></span></span><br><span class="line"><span class="actionscript">                        + <span class="string">'商业转载请联系作者获得授权，非商业转载请注明出处。&lt;br /&gt;'</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        + '作者：shengyu <span class="tag">&lt;<span class="name">br</span>/&gt;</span>链接：https://shengyur.github.io/<span class="tag">&lt;<span class="name">br</span> /&gt;</span>'</span></span></span><br><span class="line"><span class="undefined">                        + node.innerHTML</span></span><br><span class="line"><span class="actionscript">                        + <span class="string">'&lt;/div&gt;'</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> textData = <span class="string">'著作权归作者所有。\n'</span></span></span><br><span class="line"><span class="actionscript">                        + <span class="string">'商业转载请联系作者获得授权，非商业转载请注明出处。\n'</span></span></span><br><span class="line"><span class="actionscript">                        + <span class="string">'作者：shengyu \n链接：https://shengyur.github.io/ \n'</span></span></span><br><span class="line"><span class="javascript">                        + <span class="built_in">window</span>.getSelection().getRangeAt(<span class="number">0</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(e.clipboardData)&#123;  </span></span><br><span class="line"><span class="actionscript">            e.clipboardData.setData(<span class="string">"text/html"</span>, htmlData);</span></span><br><span class="line"><span class="actionscript">            e.clipboardData.setData(<span class="string">"text/plain"</span>,textData);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.clipboardData)&#123;  </span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="built_in">window</span>.clipboardData.setData(<span class="string">"text"</span>, textData);  </span></span><br><span class="line"><span class="undefined">        &#125;  </span></span><br><span class="line"><span class="undefined">    &#125;;  </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> answer = <span class="built_in">document</span>.getElementById(<span class="string">"answer"</span>);</span></span><br><span class="line"><span class="actionscript">    answer.addEventListener(<span class="string">'copy'</span>,<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">        setClipboardText(e);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>如果是复制到纯文本编辑器，就使用clipboardData.setData(“text/plain”,textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(“text/html”, htmlData);)，比如word,就有必要保留标签了。</li><li>oncopy 事件在用户拷贝元素上的内容时触发。</li><li>有三种方式可以拷贝元素和内容：<ol><li>按下 CTRL + C</li><li>在你的浏览器的 Edit(编辑) 菜单中选择 “Copy（复制）”</li><li>右键鼠标按钮，在上下文菜单中选择 “Copy（复制）” 命令。</li></ol></li></ul><p>参考：<a href="https://blog.csdn.net/sinat_23880167/article/details/79418505" target="_blank" rel="noopener">https://blog.csdn.net/sinat_23880167/article/details/79418505</a></p>]]></content>
      
      <categories>
          
          <category> 十万个为什么 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jquery源码解析01——总体架构</title>
      <link href="/2018/04/27/jquery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB01-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/04/27/jquery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB01-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="jquery1-7-1源码的总体结构："><a href="#jquery1-7-1源码的总体结构：" class="headerlink" title="jquery1.7.1源码的总体结构："></a>jquery1.7.1源码的总体结构：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window , undefined </span>)</span>&#123;</span><br><span class="line"><span class="comment">//构造jQuery对象</span></span><br><span class="line"><span class="keyword">var</span>  jQuery =  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> jQuery =  <span class="function"><span class="keyword">function</span> (<span class="params">  selector,  context </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector,context,rootjQuery);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//工具方法：Utilities</span></span><br><span class="line"><span class="comment">//回调函数列表：Callbacks  Object</span></span><br><span class="line"><span class="comment">//异步队列：Deferred  Object</span></span><br><span class="line"><span class="comment">//浏览器功能测试：Support</span></span><br><span class="line"><span class="comment">//数据缓存：DataS</span></span><br><span class="line"><span class="comment">//队列：Queue</span></span><br><span class="line"><span class="comment">//属性操作：Attributes</span></span><br><span class="line"><span class="comment">//事件系统：Events</span></span><br><span class="line"><span class="comment">//选择器：Sizzle</span></span><br><span class="line"><span class="comment">//DOM遍历：Traversing</span></span><br><span class="line"><span class="comment">//DOM操作：Manipulation</span></span><br><span class="line"><span class="comment">//样式操作 css  (计算样式、内联样式)</span></span><br><span class="line"><span class="comment">//异步请求：Ajax</span></span><br><span class="line"><span class="comment">//动画： Effects</span></span><br><span class="line"><span class="comment">//坐标：Offset、尺寸 Dimensions</span></span><br><span class="line"><span class="built_in">window</span>.jQuery =  <span class="built_in">window</span>.$  =  jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><h3 id="为什么要创建一个自调用匿名函数？"><a href="#为什么要创建一个自调用匿名函数？" class="headerlink" title="为什么要创建一个自调用匿名函数？"></a>为什么要创建一个自调用匿名函数？</h3><p>因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突</p><h3 id="匿名函数自调有几种不同的写法？"><a href="#匿名函数自调有几种不同的写法？" class="headerlink" title="匿名函数自调有几种不同的写法？"></a>匿名函数自调有几种不同的写法？</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>（<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>:!<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h3 id="为什么匿名函数自调-要在在前面加！？"><a href="#为什么匿名函数自调-要在在前面加！？" class="headerlink" title="为什么匿名函数自调 要在在前面加！？"></a>为什么匿名函数自调 要在在前面加！？</h3><p>匿名函数自调叫做<strong>立即调用的函数表达式</strong>更为贴切,直接执行,会报错(语法错误SyntaxError)<br>语法错误的两种原因：</p><ul><li>function (){ }()<br>期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称</li><li>function g(){ }()<br>期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。<br>所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。<br>执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。<br><br><br>注意：<br>圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数</li></ul><h3 id="为什么要自调用匿名函数设置参数window，并传入window对象？"><a href="#为什么要自调用匿名函数设置参数window，并传入window对象？" class="headerlink" title="为什么要自调用匿名函数设置参数window，并传入window对象？"></a>为什么要自调用匿名函数设置参数window，并传入window对象？</h3><ul><li>通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，<br>从而可以更快的访问window对象</li><li>将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现<br>(function(a,b){…….})(window)参数window被压缩成a,参数undefined被压缩成b</li></ul><h3 id="为什么要自调用匿名函数并设置参数undefined？"><a href="#为什么要自调用匿名函数并设置参数undefined？" class="headerlink" title="为什么要自调用匿名函数并设置参数undefined？"></a>为什么要自调用匿名函数并设置参数undefined？</h3><ul><li>undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链</li><li>在压缩代码时可以进行优化</li><li>重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值</li></ul><h3 id="为什么匿名函数最后或者最开始要加分号？"><a href="#为什么匿名函数最后或者最开始要加分号？" class="headerlink" title="为什么匿名函数最后或者最开始要加分号？"></a>为什么匿名函数最后或者最开始要加分号？</h3><ul><li>因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用</li></ul>]]></content>
      
      <categories>
          
          <category> 源码浅析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Github+Hexo+Maupassant 搭建个人博客教程</title>
      <link href="/2018/04/18/hexo+github+Maupassant%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/04/18/hexo+github+Maupassant%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p><img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_c2a91a3b4a43d03bf967dda7c7425506.png" alt=""><br><a id="more"></a></p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><pre><code>用来生成静态页面。移步Node.js官网</code></pre><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><pre><code>mac下输入以下命令安装:</code></pre><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm <span class="keyword">install</span> -g hexo</span><br></pre></td></tr></table></figure><h4 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a><em>避坑指南</em></h4><ul><li>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)</li><li>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>终端cd到一个你选定的目录，执行hexo init命令：</code></pre><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init blog</span></span><br></pre></td></tr></table></figure><pre><code>blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：</code></pre><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><pre><code>执行如下命令,**开启hexo服务器**</code></pre><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure><p>此时，浏览器中打开网址<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>，能看到如下页面：<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png" alt="HEXO初始化"><br>至此，跟新博客的本地环境就搭好了！</p><h3 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h3><ul><li><p>创建仓库<br>  登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg" alt=""></p><p>  本地的blog文件夹下内容为：</p></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">db.json</span><br><span class="line">node_modules</span><br><span class="line">package.json</span><br><span class="line">scaffolds</span><br><span class="line">source</span><br><span class="line">themes</span><br></pre></td></tr></table></figure><ul><li>终端cd到blog文件夹下，打开_config.yml，命令如下：</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span> _config.yml</span><br></pre></td></tr></table></figure><ul><li>查看文件最后，修改deploy为：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/shengyur/shengyur.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><ul><li>然后将repo后面的地址中的 shengyur 换成你自己的用户名</li></ul><h4 id="避坑指南二"><a href="#避坑指南二" class="headerlink" title="避坑指南二"></a><em>避坑指南二</em></h4><p>在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。<br>在blog文件夹目录下执行<strong>生成静态页面命令</strong>：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span>     简写：hexo g</span><br></pre></td></tr></table></figure></p><p>此时若出现如下报错：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>Local hexo not found in ~/blog</span><br><span class="line"><span class="keyword">ERROR </span>Try runing: 'npm install hexo --save'</span><br></pre></td></tr></table></figure><p>则执行命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>再执行<strong>配置命令</strong>：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">deploy</span>       简写：hexo d</span><br></pre></td></tr></table></figure></p><h4 id="避坑指南三"><a href="#避坑指南三" class="headerlink" title="避坑指南三"></a><em>避坑指南三</em></h4><p>若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>再次执行hexo generate和hexo deploy命令。<br>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username <span class="keyword">for</span> <span class="symbol">'https</span>:<span class="comment">//github.com':</span></span><br><span class="line">Password <span class="keyword">for</span> <span class="symbol">'https</span>:<span class="comment">//github.com':</span></span><br></pre></td></tr></table></figure><p>hexo deploy命令执行成功后，浏览器中打开网址<a href="http://shengyur.github.io" target="_blank" rel="noopener">http://shengyur.github.io</a>,<br>将shengyur换成你的用户名,就能能看到和打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 时一样的页面了。</p><h3 id="添加ssh-key到Github"><a href="#添加ssh-key到Github" class="headerlink" title="添加ssh key到Github"></a>添加ssh key到Github</h3><h4 id="检查SSH-keys是否存在Github"><a href="#检查SSH-keys是否存在Github" class="headerlink" title="检查SSH keys是否存在Github"></a>检查SSH keys是否存在Github</h4><p>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -al ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure><h4 id="生成新的ssh-key"><a href="#生成新的ssh-key" class="headerlink" title="生成新的ssh key"></a>生成新的ssh key</h4><p>执行如下命令生成public/private rsa key pair，注意将<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> "<span class="selector-tag">your_email</span>@<span class="keyword">example</span>.<span class="keyword">com</span>"</span><br></pre></td></tr></table></figure><p>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。</p><h4 id="将ssh-key添加到Github中"><a href="#将ssh-key添加到Github中" class="headerlink" title="将ssh key添加到Github中"></a>将ssh key添加到Github中</h4><ul><li><p>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p></li><li><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p></li><li><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p></li></ul><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>终端cd到blog文件夹下，执行如下命令<strong>新建文章</strong>：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span></span><br></pre></td></tr></table></figure><p>名为postName.md的文件会建在目录 /blog/source/_posts 下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。<br>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span>                 <span class="comment">//生成静态页面</span></span><br><span class="line"></span><br><span class="line">hexo deploy                   <span class="comment">//将文章部署到Github</span></span><br></pre></td></tr></table></figure><p>至此，Mac上搭建基于Github的Hexo博客就大功告成了！</p><h3 id="跟换博客主题"><a href="#跟换博客主题" class="headerlink" title="跟换博客主题"></a>跟换博客主题</h3><p>如果不喜欢官网默认主题的话，以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题页</a>去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/yanzi1225627/article/details/54566792" target="_blank" rel="noopener">https://blog.csdn.net/yanzi1225627/article/details/54566792</a></li><li><a href="https://www.jianshu.com/p/13e64c9e2295" target="_blank" rel="noopener">https://www.jianshu.com/p/13e64c9e2295</a></li></ul>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git常用基本命令</title>
      <link href="/2018/04/17/git%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/04/17/git%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="必须记住的六条命令"><a href="#必须记住的六条命令" class="headerlink" title="必须记住的六条命令"></a>必须记住的六条命令</h3><ol><li>cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。</li><li>git status .：查看当前路径下的的状态。git下最最常用的一个命令。</li><li>git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。</li><li>git commit -m “提交时说明信息”: 更进一步提交，并说明提交log。</li><li>git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)</li><li>git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)<a id="more"></a><h3 id="当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作："><a href="#当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：" class="headerlink" title="当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作："></a>当我们在本地新建了自己的代码仓库，需要传到github上时，我们的操作：</h3></li><li><p>建立git仓库<br>cd到你的本地项目根目录下，执行git命令，此命令会在当前目录下创建一个.git文件夹。<br>git init</p></li><li><p>将项目的所有文件添加到仓库中<br>git add .<br>这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可</p></li><li><p>将add的文件commit到仓库<br>git commit -m “注释语句”</p></li><li><p>去github上创建自己的Repository，点击NewRepository。<br>点击Create repository，拿到创建的仓库的https地址</p></li><li><p>将本地的仓库关联到github上<br>git remote add origin https://自己的仓库url地址</p></li><li><p>上传代码到github远程仓库<br>git push -u origin master</p></li><li><p>执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了.</p></li></ol><h3 id="git如何全局设置用户名及邮箱："><a href="#git如何全局设置用户名及邮箱：" class="headerlink" title="git如何全局设置用户名及邮箱："></a>git如何全局设置用户名及邮箱：</h3><p>git config user.name “Your Name”<br>git config user.email <a href="mailto:you@example.com" target="_blank" rel="noopener">you@example.com</a></p><h3 id="当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下"><a href="#当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下" class="headerlink" title="当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:"></a>当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:</h3><ol><li>git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。 如果想添加某个特定的文件，只需把.换成特定的文件名即可）</li><li>git commit -m “提交时说明信息”</li><li>git push</li><li>当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull</li></ol><h3 id="这三条命令建议记住"><a href="#这三条命令建议记住" class="headerlink" title="这三条命令建议记住"></a>这三条命令建议记住</h3><ol><li>git log:查看提交历史，与各次的提交说明。</li><li>git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。</li><li>git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。</li></ol><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul><li>操作时 双击tab键的自动提示/补全功能。</li><li>q或者:q等命令代表退出(quit)。</li><li>ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页</li></ul><h1 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h1><h2 id="理解几个概念"><a href="#理解几个概念" class="headerlink" title="理解几个概念"></a>理解几个概念</h2><p>工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.</p><p><em>服务器</em>:概念已经清楚了。叫做 中央服务器/远程服务器都行。<br><em>工作区</em>:就是你电脑的工作目录<br><em>版本库</em>:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。</p><h2 id="为什么存在一个-版本库？"><a href="#为什么存在一个-版本库？" class="headerlink" title="为什么存在一个 版本库？"></a>为什么存在一个 版本库？</h2><p>我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。</p><h2 id="gitignore文件是干啥的"><a href="#gitignore文件是干啥的" class="headerlink" title=".gitignore文件是干啥的?"></a>.gitignore文件是干啥的?</h2><p>工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。</p><h2 id="gitignore文件的使用"><a href="#gitignore文件的使用" class="headerlink" title=".gitignore文件的使用"></a>.gitignore文件的使用</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）<span class="string">/mtk/</span>               过滤整个文件夹</span><br><span class="line">2）*<span class="string">.zip</span>                过滤所有<span class="string">.zip</span>文件</span><br><span class="line">3）<span class="string">/mtk/do.c</span>         过滤某个具体文件</span><br></pre></td></tr></table></figure><p>被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。<br>需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）!*.zip</span><br><span class="line"><span class="number">2</span>）!/mtk/one.txt</span><br></pre></td></tr></table></figure></p><p>唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。<br>为什么要有两种规则呢？想象一个场景： <strong>假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理</strong> ，那么我们就需要使用：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="regexp">/mtk/</span></span><br><span class="line"><span class="number">2</span>）!<span class="regexp">/mtk/</span>one.txt</span><br></pre></td></tr></table></figure></p><p>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</p><p>配置语法：<br>以斜杠“/”开头表示目录；<br>以星号通配多个字符；<br>以问号“?”通配单个字符<br>以方括号“[]”包含单个字符的匹配列表；<br>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</p><h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h3><p>git config 文件配置项</p><ul><li>参考：</li><li>小白教程：<a href="https://www.cnblogs.com/yaoxiaowen/p/8227873.html" target="_blank" rel="noopener">https://www.cnblogs.com/yaoxiaowen/p/8227873.html</a></li><li>秒秒钟入门markdown语法：<a href="https://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">https://www.jianshu.com/p/q81RER</a></li><li>Git忽略规则.gitignore梳理:<a href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/5690241.html</a></li><li>王老师的博客:<a href="https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md" target="_blank" rel="noopener">https://github.com/wang-qingqing/accumulate/blob/master/%E5%B7%A5%E5%85%B7%E7%B1%BB/Git/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md</a></li><li>git config <a href="https://blog.csdn.net/gaochenchen/article/details/76187480" target="_blank" rel="noopener">https://blog.csdn.net/gaochenchen/article/details/76187480</a></li></ul>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
