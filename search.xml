<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>前端基础知识</title>
      <link href="/2018/05/02/javascript%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/05/02/javascript%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h3 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h3><ol><li>js中的变量提升是什么原理？</li><li>标准浏览器的事件模型是什么样子的？与ie6 ie7 ie8的差异在哪里？<ul><li>先冒泡还是先捕获？</li><li>各浏览器监听函数的写法是否一致？<a id="more"></a></li></ul></li></ol><h3 id="HTTP协议-amp-缓存"><a href="#HTTP协议-amp-缓存" class="headerlink" title="HTTP协议 &amp; 缓存"></a>HTTP协议 &amp; 缓存</h3><ol><li>下面的状态码代表的是什么意思？200、204、301、302、304、404？</li><li>HTTP1 和 HTTP1.1的主要差别是什么？为什么有这些差别？catch-control/expired/E-tag/last-modify?</li></ol><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ol><li>富文本编辑器如何解决XSS问题？</li><li>为什么Restfal API不应当使用’Access-Cross-Origin:* ‘来实现跨域？</li></ol><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ol><li>Express 和 Koa有什么差别？</li><li>怎么在Node做CI测试？</li></ol>]]></content>
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复制知乎/简书的文本内容，为什么会自带版权声明？</title>
      <link href="/2018/05/01/%E5%A4%8D%E5%88%B6%E7%9F%A5%E4%B9%8E%E7%AE%80%E4%B9%A6%E7%9A%84%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%87%AA%E5%B8%A6%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%EF%BC%9F/"/>
      <url>/2018/05/01/%E5%A4%8D%E5%88%B6%E7%9F%A5%E4%B9%8E%E7%AE%80%E4%B9%A6%E7%9A%84%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%87%AA%E5%B8%A6%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>实现思路：</p><ol><li>答案区域监听copy事件，并阻止这个事件的默认行为。</li><li>获取选中的内容<strong>window.getSelection()</strong>后加上版权信息，然后设置到剪切板<strong>clipboardData.setData()</strong>。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"copyText"</span>&gt;</span>我是一段即将被复制的话<span class="tag">&lt;<span class="name">b</span>&gt;</span>test<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">setClipboardText</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">        e.preventDefault();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'#copyText'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> htmlData = <span class="string">'&lt;div&gt;著作权归作者所有。&lt;br /&gt;'</span></span></span><br><span class="line"><span class="actionscript">                        + <span class="string">'商业转载请联系作者获得授权，非商业转载请注明出处。&lt;br /&gt;'</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        + '作者：shengyu <span class="tag">&lt;<span class="name">br</span>/&gt;</span>链接：https://shengyur.github.io/<span class="tag">&lt;<span class="name">br</span> /&gt;</span>'</span></span></span><br><span class="line"><span class="undefined">                        + node.innerHTML</span></span><br><span class="line"><span class="actionscript">                        + <span class="string">'&lt;/div&gt;'</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> textData = <span class="string">'著作权归作者所有。\n'</span></span></span><br><span class="line"><span class="actionscript">                        + <span class="string">'商业转载请联系作者获得授权，非商业转载请注明出处。\n'</span></span></span><br><span class="line"><span class="actionscript">                        + <span class="string">'作者：shengyu \n链接：https://shengyur.github.io/ \n'</span></span></span><br><span class="line"><span class="javascript">                        + <span class="built_in">window</span>.getSelection().getRangeAt(<span class="number">0</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(e.clipboardData)&#123;  </span></span><br><span class="line"><span class="actionscript">            e.clipboardData.setData(<span class="string">"text/html"</span>, htmlData);</span></span><br><span class="line"><span class="actionscript">            e.clipboardData.setData(<span class="string">"text/plain"</span>,textData);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.clipboardData)&#123;  </span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="built_in">window</span>.clipboardData.setData(<span class="string">"text"</span>, textData);  </span></span><br><span class="line"><span class="undefined">        &#125;  </span></span><br><span class="line"><span class="undefined">    &#125;;  </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> answer = <span class="built_in">document</span>.getElementById(<span class="string">"answer"</span>);</span></span><br><span class="line"><span class="actionscript">    answer.addEventListener(<span class="string">'copy'</span>,<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">        setClipboardText(e);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>如果是复制到纯文本编辑器，就使用clipboardData.setData(“text/plain”,textData)方法，比如记事本，就没必要保存标签，反正也没啥样式，但是如果是复制到富文本编辑器(clipboardData.setData(“text/html”, htmlData);)，比如word,就有必要保留标签了。</li><li>oncopy 事件在用户拷贝元素上的内容时触发。</li><li>有三种方式可以拷贝元素和内容：<ol><li>按下 CTRL + C</li><li>在你的浏览器的 Edit(编辑) 菜单中选择 “Copy（复制）”</li><li>右键鼠标按钮，在上下文菜单中选择 “Copy（复制）” 命令。</li></ol></li></ul><p>参考：<a href="https://blog.csdn.net/sinat_23880167/article/details/79418505" target="_blank" rel="noopener">https://blog.csdn.net/sinat_23880167/article/details/79418505</a></p>]]></content>
      
      <categories>
          
          <category> 十万个为什么 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jquery源码解析01——总体架构</title>
      <link href="/2018/04/27/jquery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB01-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/04/27/jquery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB01-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="jquery1-7-1源码的总体结构："><a href="#jquery1-7-1源码的总体结构：" class="headerlink" title="jquery1.7.1源码的总体结构："></a>jquery1.7.1源码的总体结构：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window , undefined </span>)</span>&#123;</span><br><span class="line"><span class="comment">//构造jQuery对象</span></span><br><span class="line"><span class="keyword">var</span>  jQuery =  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> jQuery =  <span class="function"><span class="keyword">function</span> (<span class="params">  selector,  context </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector,context,rootjQuery);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//工具方法：Utilities</span></span><br><span class="line"><span class="comment">//回调函数列表：Callbacks  Object</span></span><br><span class="line"><span class="comment">//异步队列：Deferred  Object</span></span><br><span class="line"><span class="comment">//浏览器功能测试：Support</span></span><br><span class="line"><span class="comment">//数据缓存：DataS</span></span><br><span class="line"><span class="comment">//队列：Queue</span></span><br><span class="line"><span class="comment">//属性操作：Attributes</span></span><br><span class="line"><span class="comment">//事件系统：Events</span></span><br><span class="line"><span class="comment">//选择器：Sizzle</span></span><br><span class="line"><span class="comment">//DOM遍历：Traversing</span></span><br><span class="line"><span class="comment">//DOM操作：Manipulation</span></span><br><span class="line"><span class="comment">//样式操作 css  (计算样式、内联样式)</span></span><br><span class="line"><span class="comment">//异步请求：Ajax</span></span><br><span class="line"><span class="comment">//动画： Effects</span></span><br><span class="line"><span class="comment">//坐标：Offset、尺寸 Dimensions</span></span><br><span class="line"><span class="built_in">window</span>.jQuery =  <span class="built_in">window</span>.$  =  jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><h3 id="为什么要创建一个自调用匿名函数？"><a href="#为什么要创建一个自调用匿名函数？" class="headerlink" title="为什么要创建一个自调用匿名函数？"></a>为什么要创建一个自调用匿名函数？</h3><p>因为js只有没有函数作用域，所以使用匿名函数自调来创建特殊的函数作用域，这个作用域中的代码不会和已有的同名函数、方法和变量以及第三方库冲突</p><h3 id="匿名函数自调有几种不同的写法？"><a href="#匿名函数自调有几种不同的写法？" class="headerlink" title="匿名函数自调有几种不同的写法？"></a>匿名函数自调有几种不同的写法？</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>（<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>:!<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h3 id="为什么匿名函数自调-要在在前面加！？"><a href="#为什么匿名函数自调-要在在前面加！？" class="headerlink" title="为什么匿名函数自调 要在在前面加！？"></a>为什么匿名函数自调 要在在前面加！？</h3><p>匿名函数自调叫做<strong>立即调用的函数表达式</strong>更为贴切,直接执行,会报错(语法错误SyntaxError)<br>语法错误的两种原因：</p><ul><li>function (){ }()<br>期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称</li><li>function g(){ }()<br>期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。<br>所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。<br>执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。<br><br><br>注意：<br>圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数</li></ul><h3 id="为什么要自调用匿名函数设置参数window，并传入window对象？"><a href="#为什么要自调用匿名函数设置参数window，并传入window对象？" class="headerlink" title="为什么要自调用匿名函数设置参数window，并传入window对象？"></a>为什么要自调用匿名函数设置参数window，并传入window对象？</h3><ul><li>通过传入window,可以把window变成局部变量，这样在jquery的代码快中访问window时，不需要将作用域链回退到顶层作用域，<br>从而可以更快的访问window对象</li><li>将window对象作为参数传入，可以在压缩代码时进行优化，在压缩文件中可以发现<br>(function(a,b){…….})(window)参数window被压缩成a,参数undefined被压缩成b</li></ul><h3 id="为什么要自调用匿名函数并设置参数undefined？"><a href="#为什么要自调用匿名函数并设置参数undefined？" class="headerlink" title="为什么要自调用匿名函数并设置参数undefined？"></a>为什么要自调用匿名函数并设置参数undefined？</h3><ul><li>undefined 是window对象的一个属性，通过把undefined当成局部变量使用，但是又不传入任何值，所以undefined的值 就是 “undefined”  可以缩短查找undefined的作用域链</li><li>在压缩代码时可以进行优化</li><li>重要：通过这个方法可以确保参数undefined的值是undefined，因为undefined有可能被重写为新的值</li></ul><h3 id="为什么匿名函数最后或者最开始要加分号？"><a href="#为什么匿名函数最后或者最开始要加分号？" class="headerlink" title="为什么匿名函数最后或者最开始要加分号？"></a>为什么匿名函数最后或者最开始要加分号？</h3><ul><li>因为如果自调用匿名函数（立即调用的函数表达）的前一行代码,没有加分号结尾,那么匿名函数的第一个括号会被认为是函数调用</li></ul>]]></content>
      
      <categories>
          
          <category> 源码浅析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端自动化测试探索</title>
      <link href="/2018/04/24/JavaScript-test-framework/"/>
      <url>/2018/04/24/JavaScript-test-framework/</url>
      <content type="html"><![CDATA[<h3 id="前端测试工具一览"><a href="#前端测试工具一览" class="headerlink" title="前端测试工具一览"></a>前端测试工具一览</h3><p>前端测试工具也和前端的框架一样纷繁复杂，其中常见的测试工具，大致可分为<strong>测试框架</strong>、<strong>断言库</strong>、<strong>测试覆盖率工具</strong>等几类。在正式开始本文之前，我们先来大致了解下它们：</p><h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。</p><p>测试框架可分为两种： TDD （测试驱动开发）和 BDD （行为驱动开发），我理解两者间的区别主要是一些语法上的不同，其中 BDD 提供了提供了可读性更好的用例语法，至于详细的区别可参见 <a href="https://joshldavis.com/2013/05/27/difference-between-tdd-and-bdd/" target="_blank" rel="noopener">The Difference Between TDD and BDD</a> 一文。</p><p>常见的测试框架有 <a href="https://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>, <a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>,以及本文要介绍的 <a href="https://facebook.github.io/jest/zh-Hans/" target="_blank" rel="noopener">Jest</a> 。</p><h3 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h3><p>断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 <a href="https://shouldjs.github.io/" target="_blank" rel="noopener">Should.js</a>, <a href="http://www.chaijs.com/" target="_blank" rel="noopener">Chai.js</a> 等。</p><h3 id="测试覆盖率工具"><a href="#测试覆盖率工具" class="headerlink" title="测试覆盖率工具"></a>测试覆盖率工具</h3><p>用于统计测试用例对代码的测试情况，生成相应的报表，比如 <a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a>。</p><h3 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h3><h3 id="为什么选择Jest"><a href="#为什么选择Jest" class="headerlink" title="为什么选择Jest"></a>为什么选择Jest</h3><p>Jest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</p><p>而作为一个面向前端的测试框架， Jest 可以利用其特有的<a href="https://facebook.github.io/jest/docs/zh-Hans/snapshot-testing.html#content" target="_blank" rel="noopener">快照测试</a>功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。</p><p>此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。目前在 Github 上其 star 数已经破万；而除了 Facebook 外，业内其他公司也开始从其它测试框架转向 Jest ，相信未来 Jest 的发展趋势仍会比较迅猛。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Jest 可以通过 npm 或 yarn 进行安装。以 npm 为例，既可用npm install -g jest进行全局安装；也可以只局部安装、并在 package.json 中指定 test 脚本：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Jest 的测试脚本名形如<em>.test.js，不论 Jest 是全局运行还是通过npm test运行，它都会执行当前目录下所有的</em>.test.js 或 *.spec.js 文件、完成测试。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="用例的表示"><a href="#用例的表示" class="headerlink" title="用例的表示"></a>用例的表示</h4><p>表示测试用例是一个测试框架提供的最基本的 API ， Jest 内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。test()函数来描述一个测试用例，举个简单的例子：<br>sum.js<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">sum</span>(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">module</span>.exports = <span class="built_in">sum</span>;</span><br></pre></td></tr></table></figure></p><p>sum.test.js<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const sum = require('./sum')<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">test('adds <span class="number">1</span> + <span class="number">2</span> to equal <span class="number">3</span>', () =&gt; &#123;</span><br><span class="line">  //expect(<span class="name">sum</span>(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>)<span class="comment">;//成功</span></span><br><span class="line">  expect(<span class="name">sum</span>(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">5</span>)<span class="comment">;//失败  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>其中toBe(‘Hello world’)便是一句断言（ Jest 管它叫 “matcher” ，想了解更多 matcher 请参考文档<a href="https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。" target="_blank" rel="noopener">https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html#content）。</a><br>写完了用例，运行在项目目录下执行npm test，即可看到测试结果：<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1%2B2.jpg" alt=""><br>修改测试用例为expect(sum(1, 2)).toBe(3)，执行npm test,可看到测试通过：<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/1_2.jpg" alt=""></p><h4 id="用例的预处理或后处理："><a href="#用例的预处理或后处理：" class="headerlink" title="用例的预处理或后处理："></a>用例的预处理或后处理：</h4><p>有时我们想在测试开始之前进行下环境的检查、或者在测试结束之后作一些清理操作，这就需要对用例进行预处理或后处理。</p><ul><li>对测试文件中所有的用例进行统一的预处理，可以使用 beforeAll() 函数；</li><li>如果想在每个用例开始前进行都预处理，则可使用 beforeEach() 函数；</li><li>后处理，可以使用对应的 afterAll() 和 afterEach() 函数。</li><li>如果只是想对某几个用例进行同样的预处理或后处理，可以将先将这几个用例归为一组。使用 describe() 函数即可表示一组用例，再将上面提到的四个处理函数置于 describe() 的处理回调内，就实现了对一组用例的预处理或后处理：</li></ul><p>checkAll.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> o=&#123;</span><br><span class="line">    foo:<span class="literal">true</span>,</span><br><span class="line">    bar:<span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports=obj();</span><br></pre></td></tr></table></figure></p><p>checkAll.test.js<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var testObject = <span class="built_in">require</span>(<span class="string">'./checkAll'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test testObject'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="regexp">//</span> 预处理操作</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'is foo'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       expect(testObject.foo).toBeTruthy();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'is not bar'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        expect(testObject.bar).toBeFalsy();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="regexp">//</span> 后处理操作</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>执行npm test<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/describe.jpg" alt=""></p><p>参考：</p><ul><li><a href="https://segmentfault.com/a/1190000004558796" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004558796</a></li><li><a href="https://zhuanlan.zhihu.com/p/28162082" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28162082</a></li></ul>]]></content>
      
      <categories>
          
          <category> 前端自动化测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jest </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github+hexo+Maupassant 搭建个人博客教程</title>
      <link href="/2018/04/18/hexo+github+Maupassant%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/04/18/hexo+github+Maupassant%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h3 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h3><pre><code>用来生成静态页面。移步Node.js官网</code></pre><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h3><pre><code>mac下输入以下命令安装:</code></pre><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm <span class="keyword">install</span> -g hexo</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a><em>避坑指南</em></h4><ul><li>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)</li><li>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。</li></ul><h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h3><pre><code>终端cd到一个你选定的目录，执行hexo init命令：</code></pre><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init blog</span></span><br></pre></td></tr></table></figure><pre><code>blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：</code></pre><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><pre><code>执行如下命令,**开启hexo服务器**</code></pre><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure><p>此时，浏览器中打开网址<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>，能看到如下页面：<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/hexo4000.png" alt="HEXO初始化"><br>至此，跟新博客的本地环境就搭好了！</p><h3 id="4-关联Github"><a href="#4-关联Github" class="headerlink" title="4.关联Github"></a>4.关联Github</h3><ul><li><p>创建仓库<br>  登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如我的博客分支名：shengyur.github.io即下图中1所示：<br><img src="https://raw.githubusercontent.com/shengyur/shengyur.github.io/master/img/BLOG.jpg" alt=""></p><p>  本地的blog文件夹下内容为：</p></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">db.json</span><br><span class="line">node_modules</span><br><span class="line">package.json</span><br><span class="line">scaffolds</span><br><span class="line">source</span><br><span class="line">themes</span><br></pre></td></tr></table></figure><ul><li>终端cd到blog文件夹下，打开_config.yml，命令如下：</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span> _config.yml</span><br></pre></td></tr></table></figure><ul><li>查看文件最后，修改deploy为：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/shengyur/shengyur.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><ul><li>然后将repo后面的地址中的 shengyur 换成你自己的用户名</li></ul><h4 id="避坑指南二"><a href="#避坑指南二" class="headerlink" title="避坑指南二"></a><em>避坑指南二</em></h4><p>在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错。<br>在blog文件夹目录下执行<strong>生成静态页面命令</strong>：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span>     简写：hexo g</span><br></pre></td></tr></table></figure></p><p>此时若出现如下报错：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>Local hexo not found in ~/blog</span><br><span class="line"><span class="keyword">ERROR </span>Try runing: 'npm install hexo --save'</span><br></pre></td></tr></table></figure><p>则执行命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>再执行<strong>配置命令</strong>：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">deploy</span>       简写：hexo d</span><br></pre></td></tr></table></figure></p><h4 id="避坑指南三"><a href="#避坑指南三" class="headerlink" title="避坑指南三"></a><em>避坑指南三</em></h4><p>若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>再次执行hexo generate和hexo deploy命令。<br>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username <span class="keyword">for</span> <span class="symbol">'https</span>:<span class="comment">//github.com':</span></span><br><span class="line">Password <span class="keyword">for</span> <span class="symbol">'https</span>:<span class="comment">//github.com':</span></span><br></pre></td></tr></table></figure><p>hexo deploy命令执行成功后，浏览器中打开网址<a href="http://shengyur.github.io" target="_blank" rel="noopener">http://shengyur.github.io</a>,<br>将shengyur换成你的用户名,就能能看到和打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 时一样的页面了。</p><h3 id="5-添加ssh-key到Github"><a href="#5-添加ssh-key到Github" class="headerlink" title="5.添加ssh key到Github"></a>5.添加ssh key到Github</h3><h4 id="5-1-检查SSH-keys是否存在Github"><a href="#5-1-检查SSH-keys是否存在Github" class="headerlink" title="5.1 检查SSH keys是否存在Github"></a>5.1 检查SSH keys是否存在Github</h4><p>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤5.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -al ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure><h4 id="5-2-生成新的ssh-key"><a href="#5-2-生成新的ssh-key" class="headerlink" title="5.2 生成新的ssh key"></a>5.2 生成新的ssh key</h4><p>执行如下命令生成public/private rsa key pair，注意将<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> "<span class="selector-tag">your_email</span>@<span class="keyword">example</span>.<span class="keyword">com</span>"</span><br></pre></td></tr></table></figure><p>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。</p><h4 id="5-3-将ssh-key添加到Github中"><a href="#5-3-将ssh-key添加到Github中" class="headerlink" title="5.3 将ssh key添加到Github中"></a>5.3 将ssh key添加到Github中</h4><ul><li><p>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p></li><li><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p></li><li><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p></li></ul><h3 id="6-发布文章"><a href="#6-发布文章" class="headerlink" title="6.发布文章"></a>6.发布文章</h3><p>终端cd到blog文件夹下，执行如下命令<strong>新建文章</strong>：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span></span><br></pre></td></tr></table></figure><p>名为postName.md的文件会建在目录/blog/source/_posts下。我使用的是vscode来编辑.md文件，语法高亮、错误提示还不错。<br>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span>                 <span class="comment">//生成静态页面</span></span><br><span class="line"></span><br><span class="line">hexo deploy                   <span class="comment">//将文章部署到Github</span></span><br></pre></td></tr></table></figure><p>至此，Mac上搭建基于Github的Hexo博客就大功告成了！</p><h3 id="7-跟换博客主题"><a href="#7-跟换博客主题" class="headerlink" title="7.跟换博客主题"></a>7.跟换博客主题</h3><p>如果不喜欢官网默认主题的话，以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题页</a>去搜寻自己喜欢的theme，或者去知乎看看推荐，找款自己心爱的皮肤，为所欲为~</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/yanzi1225627/article/details/54566792" target="_blank" rel="noopener">https://blog.csdn.net/yanzi1225627/article/details/54566792</a></li><li><a href="https://www.jianshu.com/p/13e64c9e2295" target="_blank" rel="noopener">https://www.jianshu.com/p/13e64c9e2295</a></li></ul>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小白适用git常用命令</title>
      <link href="/2018/04/17/git%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/04/17/git%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h3 id="必须记住的六条命令"><a href="#必须记住的六条命令" class="headerlink" title="必须记住的六条命令"></a>必须记住的六条命令</h3><ol><li>cd:用来切换工作目录,最常用的一个命令。简单来讲，cd A文件夹就是进入到A文件夹里面的意思。</li><li>git status .：查看当前路径下的的状态。git下最最常用的一个命令。</li><li>git add .: 把工作区的所有变化，(就是你的所有改动)，都添加到 版本库/暂存区。</li><li>git commit -m “提交时说明信息”: 更进一步提交，并说明提交log。</li><li>git push: 把版本库的所有更新内容， 都推送到远程服务器。(就是推代码/推上去)</li><li>git pull: 把代码从远程服务器拉取到本地。(俗称拉代码)<a id="more"></a></li></ol><h3 id="当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下"><a href="#当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下" class="headerlink" title="当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:"></a>当我们修改了本地代码，向远程服务器推送时，我们的操作步骤如下:</h3><ol><li>git add .</li><li>git commit -m “提交时说明信息”</li><li>git push</li><li>当我们想更新本地代码，就是把服务器上最新的代码拉取下来，只需要执行一个命令: git pull</li></ol><h3 id="这三条命令建议记住"><a href="#这三条命令建议记住" class="headerlink" title="这三条命令建议记住"></a>这三条命令建议记住</h3><ol><li>git log:查看提交历史，与各次的提交说明。</li><li>git diff:比较工作区与暂存区的差异，就是比较看看你到底都做了什么修改。</li><li>git clone url地址: 将远程服务器上项目克隆到新创建的目录中（第一次拉项目时使用， 后面的更新都用 git pull了）。</li></ol><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul><li>操作时 双击tab键的自动提示/补全功能。</li><li>q或者:q等命令代表退出(quit)。</li><li>ctrl+f,ctrl+b快捷键在termial可以翻页，就是 上一页，下一页</li></ul><h1 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h1><h2 id="理解几个概念"><a href="#理解几个概念" class="headerlink" title="理解几个概念"></a>理解几个概念</h2><p>工作区（Working Directory）， 版本库（Repository）/暂存区 ，（中央/远程）服务器.</p><p><em>服务器</em>:概念已经清楚了。叫做 中央服务器/远程服务器都行。<br><em>工作区</em>:就是你电脑的工作目录<br><em>版本库</em>:工作区有一个隐藏的 .git文件夹，这个是叫做 版本库(有些文章也叫 暂存区，不管叫什么，知道这个意思就好)。.git 是隐藏文件夹。该文件内的内容很重要，因为git的控制配置等信息，都在这个隐藏文件夹里。电脑如果设置不显示隐藏文件夹，那么就会看不到。</p><h2 id="为什么存在一个-版本库？"><a href="#为什么存在一个-版本库？" class="headerlink" title="为什么存在一个 版本库？"></a>为什么存在一个 版本库？</h2><p>我修改过的代码，直接从 工作区提交到服务器不就行了嘛，为什么还要这么麻烦。svn 等集中式版本管理系统就是这么做的，简单明了，但是如果你没网络时怎么办？所以有了 版本库，那么你可以把代码先从工作区提交到版本库，等待有网络了，可以再提交到服务器。</p><h2 id="gitignore文件是干啥的"><a href="#gitignore文件是干啥的" class="headerlink" title=".gitignore文件是干啥的?"></a>.gitignore文件是干啥的?</h2><p>工作区的目录下面，总会存在很多乱七八糟的文件，比如你本地的配置，编译生成的中间文件等，这些文件你不想(或不能)提交到 服务器。那怎么办呢。就把这些文件的规则写到 .gitignore文件中，这样git就会 ignore(忽略)这些文件，git就会像没看到这些文件一样。</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2><p>-参考：<br>-小白教程：<a href="https://www.cnblogs.com/yaoxiaowen/p/8227873.html" target="_blank" rel="noopener">https://www.cnblogs.com/yaoxiaowen/p/8227873.html</a><br>-秒秒钟入门markdown语法：<a href="https://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">https://www.jianshu.com/p/q81RER</a></p>]]></content>
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
